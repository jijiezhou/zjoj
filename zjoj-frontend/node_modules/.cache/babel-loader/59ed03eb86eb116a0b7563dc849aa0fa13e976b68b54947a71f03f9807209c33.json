{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n  static _createWord(lineContent, wordType, nextCharClass, start, end) {\n    // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n    return {\n      start: start,\n      end: end,\n      wordType: wordType,\n      nextCharClass: nextCharClass\n    };\n  }\n  static _findPreviousWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* WordType.None */;\n    for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (chClass === 0 /* WordCharacterClass.Regular */) {\n        if (wordType === 2 /* WordType.Separator */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 1 /* WordType.Regular */;\n      } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        if (wordType === 1 /* WordType.Regular */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 2 /* WordType.Separator */;\n      } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        if (wordType !== 0 /* WordType.None */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n      }\n    }\n    if (wordType !== 0 /* WordType.None */) {\n      return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n    }\n    return null;\n  }\n  static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    const len = lineContent.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        return chIndex;\n      }\n      if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        return chIndex;\n      }\n      if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _findNextWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* WordType.None */;\n    const len = lineContent.length;\n    for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (chClass === 0 /* WordCharacterClass.Regular */) {\n        if (wordType === 2 /* WordType.Separator */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 1 /* WordType.Regular */;\n      } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        if (wordType === 1 /* WordType.Regular */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 2 /* WordType.Separator */;\n      } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        if (wordType !== 0 /* WordType.None */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n      }\n    }\n    if (wordType !== 0 /* WordType.None */) {\n      return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n    }\n    return null;\n  }\n  static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        return chIndex + 1;\n      }\n      if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        return chIndex + 1;\n      }\n      if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n        return chIndex + 1;\n      }\n    }\n    return 0;\n  }\n  static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (column === 1) {\n      if (lineNumber > 1) {\n        lineNumber = lineNumber - 1;\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n      if (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */ && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n        // Skip over a word made up of one single separator and followed by a regular character\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n      while (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n        // Skip over words made up of only separators\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    // We are stopping at the ending of words\n    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n    }\n    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n  }\n  static _moveWordPartLeft(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === 1) {\n      return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column - 1; column > 1; column--) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n        // kebab-case-variables\n        return new Position(lineNumber, column);\n      }\n      if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, 1);\n  }\n  static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    let movedDown = false;\n    if (column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber < model.getLineCount()) {\n        movedDown = true;\n        lineNumber = lineNumber + 1;\n        column = 1;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n      if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n        if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n          // Skip over a word made up of one single separator and followed by a regular character\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n      if (movedDown) {\n        // If we move to the next line, pretend that the cursor is right before the first character.\n        // This is needed when the first word starts right at the first character - and in order not to miss it,\n        // we need to start before.\n        column = 0;\n      }\n      while (nextWordOnLine && (nextWordOnLine.wordType === 2 /* WordType.Separator */ || nextWordOnLine.start + 1 <= column)) {\n        // Skip over a word made up of one single separator\n        // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else {\n      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  static _moveWordPartRight(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === maxColumn) {\n      return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column + 1; column < maxColumn; column++) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n        // kebab-case-variables\n        return new Position(lineNumber, column);\n      }\n      if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, maxColumn);\n  }\n  static _deleteWordLeftWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 2;\n    const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n    if (lastNonWhitespace + 1 < startIndex) {\n      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n    }\n    return null;\n  }\n  static deleteWordLeft(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n      const position = ctx.selection.getPosition();\n      return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (lineNumber === 1 && column === 1) {\n      // Ignore deleting at beginning of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordLeftWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n      if (prevWordOnLine) {\n        column = prevWordOnLine.start + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    } else {\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      if (prevWordOnLine) {\n        column = prevWordOnLine.end + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static deleteInsideWord(wordSeparators, model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    const r = this._deleteInsideWordWhitespace(model, position);\n    if (r) {\n      return r;\n    }\n    return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n  }\n  static _charAtIsWhitespace(str, index) {\n    const charCode = str.charCodeAt(index);\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n  }\n  static _deleteInsideWordWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineContentLength = lineContent.length;\n    if (lineContentLength === 0) {\n      // empty line\n      return null;\n    }\n    let leftIndex = Math.max(position.column - 2, 0);\n    if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n      // touches a non-whitespace character to the left\n      return null;\n    }\n    let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n    if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n      // touches a non-whitespace character to the right\n      return null;\n    }\n    // walk over whitespace to the left\n    while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n      leftIndex--;\n    }\n    // walk over whitespace to the right\n    while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n      rightIndex++;\n    }\n    return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n  }\n  static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineLength = lineContent.length;\n    if (lineLength === 0) {\n      // empty line\n      if (position.lineNumber > 1) {\n        return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n      } else {\n        if (position.lineNumber < model.getLineCount()) {\n          return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n        } else {\n          // empty model\n          return new Range(position.lineNumber, 1, position.lineNumber, 1);\n        }\n      }\n    }\n    const touchesWord = word => {\n      return word.start + 1 <= position.column && position.column <= word.end + 1;\n    };\n    const createRangeWithPosition = (startColumn, endColumn) => {\n      startColumn = Math.min(startColumn, position.column);\n      endColumn = Math.max(endColumn, position.column);\n      return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n    };\n    const deleteWordAndAdjacentWhitespace = word => {\n      let startColumn = word.start + 1;\n      let endColumn = word.end + 1;\n      let expandedToTheRight = false;\n      while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n        expandedToTheRight = true;\n        endColumn++;\n      }\n      if (!expandedToTheRight) {\n        while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n          startColumn--;\n        }\n      }\n      return createRangeWithPosition(startColumn, endColumn);\n    };\n    const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n    }\n    const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n    }\n    if (prevWordOnLine && nextWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n    }\n    if (prevWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n    }\n    if (nextWordOnLine) {\n      return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n    }\n    return createRangeWithPosition(1, lineLength + 1);\n  }\n  static _deleteWordPartLeft(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartLeft(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _findFirstNonWhitespaceChar(str, startIndex) {\n    const len = str.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const ch = str.charAt(chIndex);\n      if (ch !== ' ' && ch !== '\\t') {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _deleteWordRightWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 1;\n    const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n    if (startIndex + 1 < firstNonWhitespace) {\n      // bingo\n      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n    }\n    return null;\n  }\n  static deleteWordRight(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    const lineCount = model.getLineCount();\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (lineNumber === lineCount && column === maxColumn) {\n      // Ignore deleting at end of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordRightWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    } else {\n      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static _deleteWordPartRight(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartRight(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _createWordAtPosition(model, lineNumber, word) {\n    const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n    return {\n      word: model.getValueInRange(range),\n      startColumn: range.startColumn,\n      endColumn: range.endColumn\n    };\n  }\n  static getWordAtPosition(model, _wordSeparators, position) {\n    const wordSeparators = getMapForWordSeparators(_wordSeparators);\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n    }\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n    }\n    return null;\n  }\n  static word(config, model, cursor, inSelectionMode, position) {\n    const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (!inSelectionMode) {\n      // Entering word selection for the first time\n      let startColumn;\n      let endColumn;\n      if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        // isTouchingPrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        // isTouchingNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        if (prevWord) {\n          startColumn = prevWord.end + 1;\n        } else {\n          startColumn = 1;\n        }\n        if (nextWord) {\n          endColumn = nextWord.start + 1;\n        } else {\n          endColumn = model.getLineMaxColumn(position.lineNumber);\n        }\n      }\n      return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n    }\n    let startColumn;\n    let endColumn;\n    if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n      // isInsidePrevWord\n      startColumn = prevWord.start + 1;\n      endColumn = prevWord.end + 1;\n    } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n      // isInsideNextWord\n      startColumn = nextWord.start + 1;\n      endColumn = nextWord.end + 1;\n    } else {\n      startColumn = position.column;\n      endColumn = position.column;\n    }\n    const lineNumber = position.lineNumber;\n    let column;\n    if (cursor.selectionStart.containsPosition(position)) {\n      column = cursor.selectionStart.endColumn;\n    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n      column = startColumn;\n      const possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.endColumn;\n      }\n    } else {\n      column = endColumn;\n      const possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.startColumn;\n      }\n    }\n    return cursor.move(true, lineNumber, column, 0);\n  }\n}\nexport class WordPartOperations extends WordOperations {\n  static deleteWordPartLeft(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingEnds);\n    return candidates[2];\n  }\n  static deleteWordPartRight(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingStarts);\n    return candidates[0];\n  }\n  static moveWordPartLeft(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartLeft(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[2];\n  }\n  static moveWordPartRight(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartRight(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[0];\n  }\n}\nfunction enforceDefined(arr) {\n  return arr.filter(el => Boolean(el));\n}","map":{"version":3,"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","_createWord","lineContent","wordType","nextCharClass","start","end","_findPreviousWordOnLine","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","chIndex","column","chCode","charCodeAt","chClass","get","_findEndOfWord","startIndex","len","length","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","getLineMaxColumn","prevWordOnLine","_moveWordPartLeft","maxColumn","left","right","isLowerAsciiLetter","isAsciiDigit","isUpperAsciiLetter","rightRight","moveWordRight","movedDown","getLineCount","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","lastNonWhitespaceIndex","deleteWordLeft","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","autoClosedCharacters","getPosition","positionLineNumber","positionColumn","r","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","str","index","charCode","lineContentLength","leftIndex","Math","max","rightIndex","min","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","pos","toPosition","_findFirstNonWhitespaceChar","ch","charAt","_deleteWordRightWhitespace","firstNonWhitespace","deleteWordRight","lineCount","_deleteWordPartRight","_createWordAtPosition","range","getValueInRange","getWordAtPosition","_wordSeparators","prevWord","nextWord","config","cursor","inSelectionMode","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","deleteWordPartLeft","candidates","enforceDefined","sort","compareRangesUsingEnds","deleteWordPartRight","compareRangesUsingStarts","moveWordPartLeft","compare","moveWordPartRight","arr","filter","el","Boolean"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}