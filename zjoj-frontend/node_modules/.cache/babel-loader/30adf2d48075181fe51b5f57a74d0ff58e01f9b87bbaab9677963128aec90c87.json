{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const foldSourceAbbr = {\n  [0 /* FoldSource.provider */]: ' ',\n  [1 /* FoldSource.userDefined */]: 'u',\n  [2 /* FoldSource.recovered */]: 'r'\n};\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nclass BitField {\n  constructor(size) {\n    const numWords = Math.ceil(size / 32);\n    this._states = new Uint32Array(numWords);\n  }\n  get(index) {\n    const arrayIndex = index / 32 | 0;\n    const bit = index % 32;\n    return (this._states[arrayIndex] & 1 << bit) !== 0;\n  }\n  set(index, newState) {\n    const arrayIndex = index / 32 | 0;\n    const bit = index % 32;\n    const value = this._states[arrayIndex];\n    if (newState) {\n      this._states[arrayIndex] = value | 1 << bit;\n    } else {\n      this._states[arrayIndex] = value & ~(1 << bit);\n    }\n  }\n}\nexport class FoldingRegions {\n  constructor(startIndexes, endIndexes, types) {\n    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n      throw new Error('invalid startIndexes or endIndexes size');\n    }\n    this._startIndexes = startIndexes;\n    this._endIndexes = endIndexes;\n    this._collapseStates = new BitField(startIndexes.length);\n    this._userDefinedStates = new BitField(startIndexes.length);\n    this._recoveredStates = new BitField(startIndexes.length);\n    this._types = types;\n    this._parentsComputed = false;\n  }\n  ensureParentIndices() {\n    if (!this._parentsComputed) {\n      this._parentsComputed = true;\n      const parentIndexes = [];\n      const isInsideLast = (startLineNumber, endLineNumber) => {\n        const index = parentIndexes[parentIndexes.length - 1];\n        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n      };\n      for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n        const startLineNumber = this._startIndexes[i];\n        const endLineNumber = this._endIndexes[i];\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n          throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n        }\n        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n          parentIndexes.pop();\n        }\n        const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n        parentIndexes.push(i);\n        this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n        this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n      }\n    }\n  }\n  get length() {\n    return this._startIndexes.length;\n  }\n  getStartLineNumber(index) {\n    return this._startIndexes[index] & MAX_LINE_NUMBER;\n  }\n  getEndLineNumber(index) {\n    return this._endIndexes[index] & MAX_LINE_NUMBER;\n  }\n  getType(index) {\n    return this._types ? this._types[index] : undefined;\n  }\n  hasTypes() {\n    return !!this._types;\n  }\n  isCollapsed(index) {\n    return this._collapseStates.get(index);\n  }\n  setCollapsed(index, newState) {\n    this._collapseStates.set(index, newState);\n  }\n  isUserDefined(index) {\n    return this._userDefinedStates.get(index);\n  }\n  setUserDefined(index, newState) {\n    return this._userDefinedStates.set(index, newState);\n  }\n  isRecovered(index) {\n    return this._recoveredStates.get(index);\n  }\n  setRecovered(index, newState) {\n    return this._recoveredStates.set(index, newState);\n  }\n  getSource(index) {\n    if (this.isUserDefined(index)) {\n      return 1 /* FoldSource.userDefined */;\n    } else if (this.isRecovered(index)) {\n      return 2 /* FoldSource.recovered */;\n    }\n    return 0 /* FoldSource.provider */;\n  }\n  setSource(index, source) {\n    if (source === 1 /* FoldSource.userDefined */) {\n      this.setUserDefined(index, true);\n      this.setRecovered(index, false);\n    } else if (source === 2 /* FoldSource.recovered */) {\n      this.setUserDefined(index, false);\n      this.setRecovered(index, true);\n    } else {\n      this.setUserDefined(index, false);\n      this.setRecovered(index, false);\n    }\n  }\n  setCollapsedAllOfType(type, newState) {\n    let hasChanged = false;\n    if (this._types) {\n      for (let i = 0; i < this._types.length; i++) {\n        if (this._types[i] === type) {\n          this.setCollapsed(i, newState);\n          hasChanged = true;\n        }\n      }\n    }\n    return hasChanged;\n  }\n  toRegion(index) {\n    return new FoldingRegion(this, index);\n  }\n  getParentIndex(index) {\n    this.ensureParentIndices();\n    const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n    if (parent === MAX_FOLDING_REGIONS) {\n      return -1;\n    }\n    return parent;\n  }\n  contains(index, line) {\n    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n  }\n  findIndex(line) {\n    let low = 0,\n      high = this._startIndexes.length;\n    if (high === 0) {\n      return -1; // no children\n    }\n    while (low < high) {\n      const mid = Math.floor((low + high) / 2);\n      if (line < this.getStartLineNumber(mid)) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return low - 1;\n  }\n  findRange(line) {\n    let index = this.findIndex(line);\n    if (index >= 0) {\n      const endLineNumber = this.getEndLineNumber(index);\n      if (endLineNumber >= line) {\n        return index;\n      }\n      index = this.getParentIndex(index);\n      while (index !== -1) {\n        if (this.contains(index, line)) {\n          return index;\n        }\n        index = this.getParentIndex(index);\n      }\n    }\n    return -1;\n  }\n  toString() {\n    const res = [];\n    for (let i = 0; i < this.length; i++) {\n      res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n    }\n    return res.join(', ');\n  }\n  toFoldRange(index) {\n    return {\n      startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n      endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n      type: this._types ? this._types[index] : undefined,\n      isCollapsed: this.isCollapsed(index),\n      source: this.getSource(index)\n    };\n  }\n  static fromFoldRanges(ranges) {\n    const rangesLength = ranges.length;\n    const startIndexes = new Uint32Array(rangesLength);\n    const endIndexes = new Uint32Array(rangesLength);\n    let types = [];\n    let gotTypes = false;\n    for (let i = 0; i < rangesLength; i++) {\n      const range = ranges[i];\n      startIndexes[i] = range.startLineNumber;\n      endIndexes[i] = range.endLineNumber;\n      types.push(range.type);\n      if (range.type) {\n        gotTypes = true;\n      }\n    }\n    if (!gotTypes) {\n      types = undefined;\n    }\n    const regions = new FoldingRegions(startIndexes, endIndexes, types);\n    for (let i = 0; i < rangesLength; i++) {\n      if (ranges[i].isCollapsed) {\n        regions.setCollapsed(i, true);\n      }\n      regions.setSource(i, ranges[i].source);\n    }\n    return regions;\n  }\n  /**\n   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n   * Each input must be pre-sorted on startLineNumber.\n   * The first list is assumed to always include all regions currently defined by range providers.\n   * The second list only contains the previously collapsed and all manual ranges.\n   * If the line position matches, the range of the new range is taken, and the range is no longer manual\n   * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n   * overlapping entries in the first list are discarded.\n   * Invalid entries are discarded. An entry is invalid if:\n   * \t\tthe start and end line numbers aren't a valid range of line numbers,\n   * \t\tit is out of sequence or has the same start line as a preceding entry,\n   * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n   */\n  static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {\n    maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;\n    const getIndexedFunction = (r, limit) => {\n      return Array.isArray(r) ? i => {\n        return i < limit ? r[i] : undefined;\n      } : i => {\n        return i < limit ? r.toFoldRange(i) : undefined;\n      };\n    };\n    const getA = getIndexedFunction(rangesA, rangesA.length);\n    const getB = getIndexedFunction(rangesB, rangesB.length);\n    let indexA = 0;\n    let indexB = 0;\n    let nextA = getA(0);\n    let nextB = getB(0);\n    const stackedRanges = [];\n    let topStackedRange;\n    let prevLineNumber = 0;\n    const resultRanges = [];\n    while (nextA || nextB) {\n      let useRange = undefined;\n      if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n        if (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n          if (nextB.source === 1 /* FoldSource.userDefined */) {\n            // a user defined range (possibly unfolded)\n            useRange = nextB;\n          } else {\n            // a previously folded range or a (possibly unfolded) recovered range\n            useRange = nextA;\n            useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;\n            useRange.source = 0 /* FoldSource.provider */;\n          }\n          nextA = getA(++indexA); // not necessary, just for speed\n        } else {\n          useRange = nextB;\n          if (nextB.isCollapsed && nextB.source === 0 /* FoldSource.provider */) {\n            // a previously collapsed range\n            useRange.source = 2 /* FoldSource.recovered */;\n          }\n        }\n        nextB = getB(++indexB);\n      } else {\n        // nextA is next. The user folded B set takes precedence and we sometimes need to look\n        // ahead in it to check for an upcoming conflict.\n        let scanIndex = indexB;\n        let prescanB = nextB;\n        while (true) {\n          if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {\n            useRange = nextA;\n            break; // no conflict, use this nextA\n          }\n          if (prescanB.source === 1 /* FoldSource.userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {\n            // we found a user folded range, it wins\n            break; // without setting nextResult, so this nextA gets skipped\n          }\n          prescanB = getB(++scanIndex);\n        }\n        nextA = getA(++indexA);\n      }\n      if (useRange) {\n        while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {\n          topStackedRange = stackedRanges.pop();\n        }\n        if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n          resultRanges.push(useRange);\n          prevLineNumber = useRange.startLineNumber;\n          if (topStackedRange) {\n            stackedRanges.push(topStackedRange);\n          }\n          topStackedRange = useRange;\n        }\n      }\n    }\n    return resultRanges;\n  }\n}\nexport class FoldingRegion {\n  constructor(ranges, index) {\n    this.ranges = ranges;\n    this.index = index;\n  }\n  get startLineNumber() {\n    return this.ranges.getStartLineNumber(this.index);\n  }\n  get endLineNumber() {\n    return this.ranges.getEndLineNumber(this.index);\n  }\n  get regionIndex() {\n    return this.index;\n  }\n  get parentIndex() {\n    return this.ranges.getParentIndex(this.index);\n  }\n  get isCollapsed() {\n    return this.ranges.isCollapsed(this.index);\n  }\n  containedBy(range) {\n    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n  }\n  containsLine(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n  }\n}","map":{"version":3,"names":["foldSourceAbbr","MAX_FOLDING_REGIONS","MAX_LINE_NUMBER","MASK_INDENT","BitField","constructor","size","numWords","Math","ceil","_states","Uint32Array","get","index","arrayIndex","bit","set","newState","value","FoldingRegions","startIndexes","endIndexes","types","length","Error","_startIndexes","_endIndexes","_collapseStates","_userDefinedStates","_recoveredStates","_types","_parentsComputed","ensureParentIndices","parentIndexes","isInsideLast","startLineNumber","endLineNumber","getStartLineNumber","getEndLineNumber","i","len","pop","parentIndex","push","getType","undefined","hasTypes","isCollapsed","setCollapsed","isUserDefined","setUserDefined","isRecovered","setRecovered","getSource","setSource","source","setCollapsedAllOfType","type","hasChanged","toRegion","FoldingRegion","getParentIndex","parent","contains","line","findIndex","low","high","mid","floor","findRange","toString","res","join","toFoldRange","fromFoldRanges","ranges","rangesLength","gotTypes","range","regions","sanitizeAndMerge","rangesA","rangesB","maxLineNumber","Number","MAX_VALUE","getIndexedFunction","r","limit","Array","isArray","getA","getB","indexA","indexB","nextA","nextB","stackedRanges","topStackedRange","prevLineNumber","resultRanges","useRange","scanIndex","prescanB","regionIndex","containedBy","containsLine","lineNumber"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const foldSourceAbbr = {\n    [0 /* FoldSource.provider */]: ' ',\n    [1 /* FoldSource.userDefined */]: 'u',\n    [2 /* FoldSource.recovered */]: 'r',\n};\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nclass BitField {\n    constructor(size) {\n        const numWords = Math.ceil(size / 32);\n        this._states = new Uint32Array(numWords);\n    }\n    get(index) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        return (this._states[arrayIndex] & (1 << bit)) !== 0;\n    }\n    set(index, newState) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        const value = this._states[arrayIndex];\n        if (newState) {\n            this._states[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._states[arrayIndex] = value & ~(1 << bit);\n        }\n    }\n}\nexport class FoldingRegions {\n    constructor(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new BitField(startIndexes.length);\n        this._userDefinedStates = new BitField(startIndexes.length);\n        this._recoveredStates = new BitField(startIndexes.length);\n        this._types = types;\n        this._parentsComputed = false;\n    }\n    ensureParentIndices() {\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            const parentIndexes = [];\n            const isInsideLast = (startLineNumber, endLineNumber) => {\n                const index = parentIndexes[parentIndexes.length - 1];\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                const startLineNumber = this._startIndexes[i];\n                const endLineNumber = this._endIndexes[i];\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n                }\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes.pop();\n                }\n                const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                parentIndexes.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    }\n    get length() {\n        return this._startIndexes.length;\n    }\n    getStartLineNumber(index) {\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getEndLineNumber(index) {\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getType(index) {\n        return this._types ? this._types[index] : undefined;\n    }\n    hasTypes() {\n        return !!this._types;\n    }\n    isCollapsed(index) {\n        return this._collapseStates.get(index);\n    }\n    setCollapsed(index, newState) {\n        this._collapseStates.set(index, newState);\n    }\n    isUserDefined(index) {\n        return this._userDefinedStates.get(index);\n    }\n    setUserDefined(index, newState) {\n        return this._userDefinedStates.set(index, newState);\n    }\n    isRecovered(index) {\n        return this._recoveredStates.get(index);\n    }\n    setRecovered(index, newState) {\n        return this._recoveredStates.set(index, newState);\n    }\n    getSource(index) {\n        if (this.isUserDefined(index)) {\n            return 1 /* FoldSource.userDefined */;\n        }\n        else if (this.isRecovered(index)) {\n            return 2 /* FoldSource.recovered */;\n        }\n        return 0 /* FoldSource.provider */;\n    }\n    setSource(index, source) {\n        if (source === 1 /* FoldSource.userDefined */) {\n            this.setUserDefined(index, true);\n            this.setRecovered(index, false);\n        }\n        else if (source === 2 /* FoldSource.recovered */) {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, true);\n        }\n        else {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, false);\n        }\n    }\n    setCollapsedAllOfType(type, newState) {\n        let hasChanged = false;\n        if (this._types) {\n            for (let i = 0; i < this._types.length; i++) {\n                if (this._types[i] === type) {\n                    this.setCollapsed(i, newState);\n                    hasChanged = true;\n                }\n            }\n        }\n        return hasChanged;\n    }\n    toRegion(index) {\n        return new FoldingRegion(this, index);\n    }\n    getParentIndex(index) {\n        this.ensureParentIndices();\n        const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    }\n    contains(index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n    findIndex(line) {\n        let low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    }\n    findRange(line) {\n        let index = this.findIndex(line);\n        if (index >= 0) {\n            const endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    }\n    toString() {\n        const res = [];\n        for (let i = 0; i < this.length; i++) {\n            res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n        }\n        return res.join(', ');\n    }\n    toFoldRange(index) {\n        return {\n            startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n            endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n            type: this._types ? this._types[index] : undefined,\n            isCollapsed: this.isCollapsed(index),\n            source: this.getSource(index)\n        };\n    }\n    static fromFoldRanges(ranges) {\n        const rangesLength = ranges.length;\n        const startIndexes = new Uint32Array(rangesLength);\n        const endIndexes = new Uint32Array(rangesLength);\n        let types = [];\n        let gotTypes = false;\n        for (let i = 0; i < rangesLength; i++) {\n            const range = ranges[i];\n            startIndexes[i] = range.startLineNumber;\n            endIndexes[i] = range.endLineNumber;\n            types.push(range.type);\n            if (range.type) {\n                gotTypes = true;\n            }\n        }\n        if (!gotTypes) {\n            types = undefined;\n        }\n        const regions = new FoldingRegions(startIndexes, endIndexes, types);\n        for (let i = 0; i < rangesLength; i++) {\n            if (ranges[i].isCollapsed) {\n                regions.setCollapsed(i, true);\n            }\n            regions.setSource(i, ranges[i].source);\n        }\n        return regions;\n    }\n    /**\n     * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n     * Each input must be pre-sorted on startLineNumber.\n     * The first list is assumed to always include all regions currently defined by range providers.\n     * The second list only contains the previously collapsed and all manual ranges.\n     * If the line position matches, the range of the new range is taken, and the range is no longer manual\n     * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n     * overlapping entries in the first list are discarded.\n     * Invalid entries are discarded. An entry is invalid if:\n     * \t\tthe start and end line numbers aren't a valid range of line numbers,\n     * \t\tit is out of sequence or has the same start line as a preceding entry,\n     * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n     */\n    static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {\n        maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;\n        const getIndexedFunction = (r, limit) => {\n            return Array.isArray(r)\n                ? ((i) => { return (i < limit) ? r[i] : undefined; })\n                : ((i) => { return (i < limit) ? r.toFoldRange(i) : undefined; });\n        };\n        const getA = getIndexedFunction(rangesA, rangesA.length);\n        const getB = getIndexedFunction(rangesB, rangesB.length);\n        let indexA = 0;\n        let indexB = 0;\n        let nextA = getA(0);\n        let nextB = getB(0);\n        const stackedRanges = [];\n        let topStackedRange;\n        let prevLineNumber = 0;\n        const resultRanges = [];\n        while (nextA || nextB) {\n            let useRange = undefined;\n            if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n                if (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n                    if (nextB.source === 1 /* FoldSource.userDefined */) {\n                        // a user defined range (possibly unfolded)\n                        useRange = nextB;\n                    }\n                    else {\n                        // a previously folded range or a (possibly unfolded) recovered range\n                        useRange = nextA;\n                        useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;\n                        useRange.source = 0 /* FoldSource.provider */;\n                    }\n                    nextA = getA(++indexA); // not necessary, just for speed\n                }\n                else {\n                    useRange = nextB;\n                    if (nextB.isCollapsed && nextB.source === 0 /* FoldSource.provider */) {\n                        // a previously collapsed range\n                        useRange.source = 2 /* FoldSource.recovered */;\n                    }\n                }\n                nextB = getB(++indexB);\n            }\n            else {\n                // nextA is next. The user folded B set takes precedence and we sometimes need to look\n                // ahead in it to check for an upcoming conflict.\n                let scanIndex = indexB;\n                let prescanB = nextB;\n                while (true) {\n                    if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {\n                        useRange = nextA;\n                        break; // no conflict, use this nextA\n                    }\n                    if (prescanB.source === 1 /* FoldSource.userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {\n                        // we found a user folded range, it wins\n                        break; // without setting nextResult, so this nextA gets skipped\n                    }\n                    prescanB = getB(++scanIndex);\n                }\n                nextA = getA(++indexA);\n            }\n            if (useRange) {\n                while (topStackedRange\n                    && topStackedRange.endLineNumber < useRange.startLineNumber) {\n                    topStackedRange = stackedRanges.pop();\n                }\n                if (useRange.endLineNumber > useRange.startLineNumber\n                    && useRange.startLineNumber > prevLineNumber\n                    && useRange.endLineNumber <= maxLineNumber\n                    && (!topStackedRange\n                        || topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n                    resultRanges.push(useRange);\n                    prevLineNumber = useRange.startLineNumber;\n                    if (topStackedRange) {\n                        stackedRanges.push(topStackedRange);\n                    }\n                    topStackedRange = useRange;\n                }\n            }\n        }\n        return resultRanges;\n    }\n}\nexport class FoldingRegion {\n    constructor(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    get startLineNumber() {\n        return this.ranges.getStartLineNumber(this.index);\n    }\n    get endLineNumber() {\n        return this.ranges.getEndLineNumber(this.index);\n    }\n    get regionIndex() {\n        return this.index;\n    }\n    get parentIndex() {\n        return this.ranges.getParentIndex(this.index);\n    }\n    get isCollapsed() {\n        return this.ranges.isCollapsed(this.index);\n    }\n    containedBy(range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n    containsLine(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}