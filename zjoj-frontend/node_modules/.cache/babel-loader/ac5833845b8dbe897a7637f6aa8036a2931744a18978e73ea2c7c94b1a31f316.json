{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n  constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n    this.languageConfigurationService = languageConfigurationService;\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n    this._ignoreEmptyLines = ignoreEmptyLines;\n    this._ignoreFirstLine = ignoreFirstLine || false;\n  }\n  /**\n   * Do an initial pass over the lines and gather info about the line comment string.\n   * Returns null if any of the lines doesn't support a line comment string.\n   */\n  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n    model.tokenization.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n    const commentStr = config ? config.lineCommentToken : null;\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n    const lines = [];\n    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n    return lines;\n  }\n  /**\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\n   */\n  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n    let onlyWhitespaceLines = true;\n    let shouldRemoveComments;\n    if (type === 0 /* Type.Toggle */) {\n      shouldRemoveComments = true;\n    } else if (type === 1 /* Type.ForceAdd */) {\n      shouldRemoveComments = false;\n    } else {\n      shouldRemoveComments = true;\n    }\n    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n      const lineData = lines[i];\n      const lineNumber = startLineNumber + i;\n      if (lineNumber === startLineNumber && ignoreFirstLine) {\n        // first line ignored\n        lineData.ignore = true;\n        continue;\n      }\n      const lineContent = model.getLineContent(lineNumber);\n      const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        lineData.ignore = ignoreEmptyLines;\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0 /* Type.Toggle */) {\n          // Every line so far has been a line comment, but this one is not\n          shouldRemoveComments = false;\n        } else if (type === 1 /* Type.ForceAdd */) {\n          // Will not happen\n        } else {\n          lineData.ignore = true;\n        }\n      }\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n          lineData.commentStrLength += 1;\n        }\n      }\n    }\n    if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false;\n      // Also, no longer ignore them\n      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  }\n  /**\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n   */\n  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n  }\n  /**\n   * Given a successful analysis, execute either insert line comments, either remove line comments\n   */\n  _executeLineComments(model, builder, data, s) {\n    let ops;\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n    for (let i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n        const lineContent = model.getLineContent(cursorPosition.lineNumber);\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  }\n  _attemptRemoveBlockComment(model, s, startToken, endToken) {\n    let startLineNumber = s.startLineNumber;\n    let endLineNumber = s.endLineNumber;\n    const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    }\n    // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n      startToken += ' ';\n    }\n    // For Space before endToken, add Space before endToken and shift index one left.\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n      endToken = ' ' + endToken;\n      endTokenIndex -= 1;\n    }\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n    return null;\n  }\n  /**\n   * Given an unsuccessful analysis, delegate to the block comment command\n   */\n  _executeBlockComment(model, builder, s) {\n    model.tokenization.tokenizeIfCheap(s.startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n    const startToken = config.blockCommentStartToken;\n    const endToken = config.blockCommentEndToken;\n    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n    if (!ops) {\n      if (s.isEmpty()) {\n        const lineContent = model.getLineContent(s.startLineNumber);\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n    for (const op of ops) {\n      builder.addEditOperation(op.range, op.text);\n    }\n  }\n  getEditOperations(model, builder) {\n    let s = this._selection;\n    this._moveEndPositionDown = false;\n    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n      this._selectionId = builder.trackSelection(s);\n      return;\n    }\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n    return this._executeBlockComment(model, builder, s);\n  }\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  }\n  /**\n   * Generate edit operations in the remove line comment case\n   */\n  static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n    const res = [];\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n    return res;\n  }\n  /**\n   * Generate edit operations in the add line comment case\n   */\n  _createAddLineCommentsOperations(lines, startLineNumber) {\n    const res = [];\n    const afterCommentStr = this._insertSpace ? ' ' : '';\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n    return res;\n  }\n  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n    return currentVisibleColumn + columnSize;\n  }\n  /**\n   * Adjust insertion points to have them vertically aligned in the add line comment case\n   */\n  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n    let minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    let j;\n    let lenJ;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n      for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n      }\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n      }\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  }\n}","map":{"version":3,"names":["strings","EditOperation","Position","Range","Selection","BlockCommentCommand","LineCommentCommand","constructor","languageConfigurationService","selection","tabSize","type","insertSpace","ignoreEmptyLines","ignoreFirstLine","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenization","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getLanguageConfiguration","comments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","op","getEditOperations","getLineCount","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","floor"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._tabSize = tabSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n        model.tokenization.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        const lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Type.Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* Type.ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Type.Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* Type.ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenization.tokenizeIfCheap(s.startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n        let minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}