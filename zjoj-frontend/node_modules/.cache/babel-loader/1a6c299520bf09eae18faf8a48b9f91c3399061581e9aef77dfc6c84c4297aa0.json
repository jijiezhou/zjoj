{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\n\nimport { find, normalize } from 'property-information';\nimport { parseSelector } from 'hast-util-parse-selector';\nimport { parse as spaces } from 'space-separated-tokens';\nimport { parse as commas } from 'comma-separated-tokens';\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button']);\nconst own = {}.hasOwnProperty;\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive);\n  const h =\n  /**\n   * @type {{\n   *   (): Root\n   *   (selector: null | undefined, ...children: Array<HChild>): Root\n   *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n   *   (selector: string, ...children: Array<HChild>): Element\n   * }}\n   */\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @param {string | null} [selector]\n   * @param {HProperties | HChild} [properties]\n   * @param {Array<HChild>} children\n   * @returns {HResult}\n   */\n  function (selector, properties, ...children) {\n    let index = -1;\n    /** @type {HResult} */\n    let node;\n    if (selector === undefined || selector === null) {\n      node = {\n        type: 'root',\n        children: []\n      };\n      // @ts-expect-error Properties are not supported for roots.\n      children.unshift(properties);\n    } else {\n      node = parseSelector(selector, defaultTagName);\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase();\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName];\n      }\n\n      // Handle props.\n      if (isProperties(properties, node.tagName)) {\n        /** @type {string} */\n        let key;\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            // @ts-expect-error `node.properties` is set.\n            addProperty(schema, node.properties, key, properties[key]);\n          }\n        }\n      } else {\n        children.unshift(properties);\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index]);\n    }\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n    return node;\n  };\n  return h;\n}\n\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (value === null || value === undefined || typeof value !== 'object' || Array.isArray(value)) {\n    return false;\n  }\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true;\n  }\n  if ('children' in value && Array.isArray(value.children)) {\n    return false;\n  }\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase());\n  }\n  return !('value' in value);\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  let index = -1;\n  /** @type {HPropertyValue} */\n  let result;\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return;\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value);\n    } else if (info.commaSeparated) {\n      result = commas(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat();\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = [];\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index]);\n    }\n    result = finalResult;\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result);\n  }\n  properties[info.property] = result;\n}\n\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1;\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index]);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n  return value;\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {string} */\n  let key;\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '));\n    }\n  }\n  return result.join('; ');\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {};\n  let index = -1;\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index];\n  }\n  return result;\n}","map":{"version":3,"names":["find","normalize","parseSelector","parse","spaces","commas","buttonTypes","Set","own","hasOwnProperty","core","schema","defaultTagName","caseSensitive","adjust","createAdjustMap","h","selector","properties","children","index","node","undefined","type","unshift","tagName","toLowerCase","call","isProperties","key","addProperty","length","addChild","content","value","name","Array","isArray","has","info","result","Number","isNaN","spaceSeparated","commaSeparated","commaOrSpaceSeparated","join","parsePrimitive","property","concat","style","String","finalResult","className","nodes","push","Error","number","boolean","overloadedBoolean","values"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/hastscript/lib/core.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null | undefined, ...children: Array<HChild>): Root\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n     *   (selector: string, ...children: Array<HChild>): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string | null} [selector]\n       * @param {HProperties | HChild} [properties]\n       * @param {Array<HChild>} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,IAAI,EAAEC,SAAS,QAAO,sBAAsB;AACpD,SAAQC,aAAa,QAAO,0BAA0B;AACtD,SAAQC,KAAK,IAAIC,MAAM,QAAO,wBAAwB;AACtD,SAAQD,KAAK,IAAIE,MAAM,QAAO,wBAAwB;AAEtD,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAElE,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAIA,CAACC,MAAM,EAAEC,cAAc,EAAEC,aAAa,EAAE;EAC1D,MAAMC,MAAM,GAAGD,aAAa,IAAIE,eAAe,CAACF,aAAa,CAAC;EAE9D,MAAMG,CAAC;EACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EAEM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;EACM,SAAAA,CAAUC,QAAQ,EAAEC,UAAU,EAAE,GAAGC,QAAQ,EAAE;IAC3C,IAAIC,KAAK,GAAG,CAAC,CAAC;IACd;IACA,IAAIC,IAAI;IAER,IAAIJ,QAAQ,KAAKK,SAAS,IAAIL,QAAQ,KAAK,IAAI,EAAE;MAC/CI,IAAI,GAAG;QAACE,IAAI,EAAE,MAAM;QAAEJ,QAAQ,EAAE;MAAE,CAAC;MACnC;MACAA,QAAQ,CAACK,OAAO,CAACN,UAAU,CAAC;IAC9B,CAAC,MAAM;MACLG,IAAI,GAAGnB,aAAa,CAACe,QAAQ,EAAEL,cAAc,CAAC;MAC9C;MACAS,IAAI,CAACI,OAAO,GAAGJ,IAAI,CAACI,OAAO,CAACC,WAAW,CAAC,CAAC;MACzC,IAAIZ,MAAM,IAAIN,GAAG,CAACmB,IAAI,CAACb,MAAM,EAAEO,IAAI,CAACI,OAAO,CAAC,EAAE;QAC5CJ,IAAI,CAACI,OAAO,GAAGX,MAAM,CAACO,IAAI,CAACI,OAAO,CAAC;MACrC;;MAEA;MACA,IAAIG,YAAY,CAACV,UAAU,EAAEG,IAAI,CAACI,OAAO,CAAC,EAAE;QAC1C;QACA,IAAII,GAAG;QAEP,KAAKA,GAAG,IAAIX,UAAU,EAAE;UACtB,IAAIV,GAAG,CAACmB,IAAI,CAACT,UAAU,EAAEW,GAAG,CAAC,EAAE;YAC7B;YACAC,WAAW,CAACnB,MAAM,EAAEU,IAAI,CAACH,UAAU,EAAEW,GAAG,EAAEX,UAAU,CAACW,GAAG,CAAC,CAAC;UAC5D;QACF;MACF,CAAC,MAAM;QACLV,QAAQ,CAACK,OAAO,CAACN,UAAU,CAAC;MAC9B;IACF;;IAEA;IACA,OAAO,EAAEE,KAAK,GAAGD,QAAQ,CAACY,MAAM,EAAE;MAChCC,QAAQ,CAACX,IAAI,CAACF,QAAQ,EAAEA,QAAQ,CAACC,KAAK,CAAC,CAAC;IAC1C;IAEA,IAAIC,IAAI,CAACE,IAAI,KAAK,SAAS,IAAIF,IAAI,CAACI,OAAO,KAAK,UAAU,EAAE;MAC1DJ,IAAI,CAACY,OAAO,GAAG;QAACV,IAAI,EAAE,MAAM;QAAEJ,QAAQ,EAAEE,IAAI,CAACF;MAAQ,CAAC;MACtDE,IAAI,CAACF,QAAQ,GAAG,EAAE;IACpB;IAEA,OAAOE,IAAI;EACb,CACD;EAEH,OAAOL,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASY,YAAYA,CAACM,KAAK,EAAEC,IAAI,EAAE;EACjC,IACED,KAAK,KAAK,IAAI,IACdA,KAAK,KAAKZ,SAAS,IACnB,OAAOY,KAAK,KAAK,QAAQ,IACzBE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EACpB;IACA,OAAO,KAAK;EACd;EAEA,IAAIC,IAAI,KAAK,OAAO,IAAI,CAACD,KAAK,CAACX,IAAI,IAAI,OAAOW,KAAK,CAACX,IAAI,KAAK,QAAQ,EAAE;IACrE,OAAO,IAAI;EACb;EAEA,IAAI,UAAU,IAAIW,KAAK,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAACf,QAAQ,CAAC,EAAE;IACxD,OAAO,KAAK;EACd;EAEA,IAAIgB,IAAI,KAAK,QAAQ,EAAE;IACrB,OAAO7B,WAAW,CAACgC,GAAG,CAACJ,KAAK,CAACX,IAAI,CAACG,WAAW,CAAC,CAAC,CAAC;EAClD;EAEA,OAAO,EAAE,OAAO,IAAIQ,KAAK,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,WAAWA,CAACnB,MAAM,EAAEO,UAAU,EAAEW,GAAG,EAAEK,KAAK,EAAE;EACnD,MAAMK,IAAI,GAAGvC,IAAI,CAACW,MAAM,EAAEkB,GAAG,CAAC;EAC9B,IAAIT,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIoB,MAAM;;EAEV;EACA,IAAIN,KAAK,KAAKZ,SAAS,IAAIY,KAAK,KAAK,IAAI,EAAE;EAE3C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACA,IAAIO,MAAM,CAACC,KAAK,CAACR,KAAK,CAAC,EAAE;IAEzBM,MAAM,GAAGN,KAAK;EAChB;EACA;EAAA,KACK,IAAI,OAAOA,KAAK,KAAK,SAAS,EAAE;IACnCM,MAAM,GAAGN,KAAK;EAChB;EACA;EAAA,KACK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAClC,IAAIK,IAAI,CAACI,cAAc,EAAE;MACvBH,MAAM,GAAGpC,MAAM,CAAC8B,KAAK,CAAC;IACxB,CAAC,MAAM,IAAIK,IAAI,CAACK,cAAc,EAAE;MAC9BJ,MAAM,GAAGnC,MAAM,CAAC6B,KAAK,CAAC;IACxB,CAAC,MAAM,IAAIK,IAAI,CAACM,qBAAqB,EAAE;MACrCL,MAAM,GAAGpC,MAAM,CAACC,MAAM,CAAC6B,KAAK,CAAC,CAACY,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1C,CAAC,MAAM;MACLN,MAAM,GAAGO,cAAc,CAACR,IAAI,EAAEA,IAAI,CAACS,QAAQ,EAAEd,KAAK,CAAC;IACrD;EACF,CAAC,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;IAC/BM,MAAM,GAAGN,KAAK,CAACe,MAAM,CAAC,CAAC;EACzB,CAAC,MAAM;IACLT,MAAM,GAAGD,IAAI,CAACS,QAAQ,KAAK,OAAO,GAAGE,KAAK,CAAChB,KAAK,CAAC,GAAGiB,MAAM,CAACjB,KAAK,CAAC;EACnE;EAEA,IAAIE,KAAK,CAACC,OAAO,CAACG,MAAM,CAAC,EAAE;IACzB;IACA,MAAMY,WAAW,GAAG,EAAE;IAEtB,OAAO,EAAEhC,KAAK,GAAGoB,MAAM,CAACT,MAAM,EAAE;MAC9B;MACAqB,WAAW,CAAChC,KAAK,CAAC,GAAG2B,cAAc,CAACR,IAAI,EAAEA,IAAI,CAACS,QAAQ,EAAER,MAAM,CAACpB,KAAK,CAAC,CAAC;IACzE;IAEAoB,MAAM,GAAGY,WAAW;EACtB;;EAEA;EACA,IAAIb,IAAI,CAACS,QAAQ,KAAK,WAAW,IAAIZ,KAAK,CAACC,OAAO,CAACnB,UAAU,CAACmC,SAAS,CAAC,EAAE;IACxE;IACAb,MAAM,GAAGtB,UAAU,CAACmC,SAAS,CAACJ,MAAM,CAACT,MAAM,CAAC;EAC9C;EAEAtB,UAAU,CAACqB,IAAI,CAACS,QAAQ,CAAC,GAAGR,MAAM;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASR,QAAQA,CAACsB,KAAK,EAAEpB,KAAK,EAAE;EAC9B,IAAId,KAAK,GAAG,CAAC,CAAC;EAEd,IAAIc,KAAK,KAAKZ,SAAS,IAAIY,KAAK,KAAK,IAAI,EAAE;IACzC;EAAA,CACD,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACjEoB,KAAK,CAACC,IAAI,CAAC;MAAChC,IAAI,EAAE,MAAM;MAAEW,KAAK,EAAEiB,MAAM,CAACjB,KAAK;IAAC,CAAC,CAAC;EAClD,CAAC,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;IAC/B,OAAO,EAAEd,KAAK,GAAGc,KAAK,CAACH,MAAM,EAAE;MAC7BC,QAAQ,CAACsB,KAAK,EAAEpB,KAAK,CAACd,KAAK,CAAC,CAAC;IAC/B;EACF,CAAC,MAAM,IAAI,OAAOc,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAIA,KAAK,EAAE;IACvD,IAAIA,KAAK,CAACX,IAAI,KAAK,MAAM,EAAE;MACzBS,QAAQ,CAACsB,KAAK,EAAEpB,KAAK,CAACf,QAAQ,CAAC;IACjC,CAAC,MAAM;MACLmC,KAAK,CAACC,IAAI,CAACrB,KAAK,CAAC;IACnB;EACF,CAAC,MAAM;IACL,MAAM,IAAIsB,KAAK,CAAC,wCAAwC,GAAGtB,KAAK,GAAG,GAAG,CAAC;EACzE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,cAAcA,CAACR,IAAI,EAAEJ,IAAI,EAAED,KAAK,EAAE;EACzC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIK,IAAI,CAACkB,MAAM,IAAIvB,KAAK,IAAI,CAACO,MAAM,CAACC,KAAK,CAACD,MAAM,CAACP,KAAK,CAAC,CAAC,EAAE;MACxD,OAAOO,MAAM,CAACP,KAAK,CAAC;IACtB;IAEA,IACE,CAACK,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACoB,iBAAiB,MACtCzB,KAAK,KAAK,EAAE,IAAIjC,SAAS,CAACiC,KAAK,CAAC,KAAKjC,SAAS,CAACkC,IAAI,CAAC,CAAC,EACtD;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAOD,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,KAAKA,CAAChB,KAAK,EAAE;EACpB;EACA,MAAMM,MAAM,GAAG,EAAE;EACjB;EACA,IAAIX,GAAG;EAEP,KAAKA,GAAG,IAAIK,KAAK,EAAE;IACjB,IAAI1B,GAAG,CAACmB,IAAI,CAACO,KAAK,EAAEL,GAAG,CAAC,EAAE;MACxBW,MAAM,CAACe,IAAI,CAAC,CAAC1B,GAAG,EAAEK,KAAK,CAACL,GAAG,CAAC,CAAC,CAACiB,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3C;EACF;EAEA,OAAON,MAAM,CAACM,IAAI,CAAC,IAAI,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/B,eAAeA,CAAC6C,MAAM,EAAE;EAC/B;EACA,MAAMpB,MAAM,GAAG,CAAC,CAAC;EACjB,IAAIpB,KAAK,GAAG,CAAC,CAAC;EAEd,OAAO,EAAEA,KAAK,GAAGwC,MAAM,CAAC7B,MAAM,EAAE;IAC9BS,MAAM,CAACoB,MAAM,CAACxC,KAAK,CAAC,CAACM,WAAW,CAAC,CAAC,CAAC,GAAGkC,MAAM,CAACxC,KAAK,CAAC;EACrD;EAEA,OAAOoB,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}