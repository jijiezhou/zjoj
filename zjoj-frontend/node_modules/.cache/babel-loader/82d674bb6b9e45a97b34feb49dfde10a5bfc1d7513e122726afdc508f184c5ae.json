{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\n\nimport { whitespace } from 'hast-util-whitespace';\nimport { siblingBefore, siblingAfter } from './util/siblings.js';\nimport { closing } from './closing.js';\nimport { omission } from './omission.js';\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n});\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1);\n  return !head || head.type !== 'comment';\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  const children = node.children;\n  /** @type {Array<string>} */\n  const seen = [];\n  let index = -1;\n  while (++index < children.length) {\n    const child = children[index];\n    if (child.type === 'element' && (child.tagName === 'title' || child.tagName === 'base')) {\n      if (seen.includes(child.tagName)) return false;\n      seen.push(child.tagName);\n    }\n  }\n  return children.length > 0;\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true);\n  return !head || head.type !== 'comment' && !(head.type === 'text' && whitespace(head.value.charAt(0))) && !(head.type === 'element' && (head.tagName === 'meta' || head.tagName === 'link' || head.tagName === 'script' || head.tagName === 'style' || head.tagName === 'template'));\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index);\n  const head = siblingAfter(node, -1, true);\n\n  // Previous colgroup was already omitted.\n  if (parent && previous && previous.type === 'element' && previous.tagName === 'colgroup' && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n  return head && head.type === 'element' && head.tagName === 'col';\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index);\n  const head = siblingAfter(node, -1);\n\n  // Previous table section was already omitted.\n  if (parent && previous && previous.type === 'element' && (previous.tagName === 'thead' || previous.tagName === 'tbody') && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n  return head && head.type === 'element' && head.tagName === 'tr';\n}","map":{"version":3,"names":["whitespace","siblingBefore","siblingAfter","closing","omission","opening","html","head","body","colgroup","tbody","node","type","children","seen","index","length","child","tagName","includes","push","value","charAt","parent","previous","indexOf"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/hast-util-to-html/lib/omission/opening.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingBefore, siblingAfter} from './util/siblings.js'\nimport {closing} from './closing.js'\nimport {omission} from './omission.js'\n\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1)\n  return !head || head.type !== 'comment'\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  const children = node.children\n  /** @type {Array<string>} */\n  const seen = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (\n      child.type === 'element' &&\n      (child.tagName === 'title' || child.tagName === 'base')\n    ) {\n      if (seen.includes(child.tagName)) return false\n      seen.push(child.tagName)\n    }\n  }\n\n  return children.length > 0\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true)\n\n  return (\n    !head ||\n    (head.type !== 'comment' &&\n      !(head.type === 'text' && whitespace(head.value.charAt(0))) &&\n      !(\n        head.type === 'element' &&\n        (head.tagName === 'meta' ||\n          head.tagName === 'link' ||\n          head.tagName === 'script' ||\n          head.tagName === 'style' ||\n          head.tagName === 'template')\n      ))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    previous.tagName === 'colgroup' &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'col'\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'tr'\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}