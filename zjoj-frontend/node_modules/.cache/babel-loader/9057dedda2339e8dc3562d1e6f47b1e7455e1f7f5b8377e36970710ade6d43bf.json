{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n  constructor(_legend, _themeService, _languageService, _logService) {\n    this._legend = _legend;\n    this._themeService = _themeService;\n    this._languageService = _languageService;\n    this._logService = _logService;\n    this._hasWarnedOverlappingTokens = false;\n    this._hasWarnedInvalidLengthTokens = false;\n    this._hasWarnedInvalidEditStart = false;\n    this._hashTable = new HashTable();\n  }\n  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n    const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n    let metadata;\n    if (entry) {\n      metadata = entry.metadata;\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n      }\n    } else {\n      let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n      const tokenModifiers = [];\n      if (tokenType) {\n        let modifierSet = tokenModifierSet;\n        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n          if (modifierSet & 1) {\n            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n          }\n          modifierSet = modifierSet >> 1;\n        }\n        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n          tokenModifiers.push('not-in-legend');\n        }\n        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n        if (typeof tokenStyle === 'undefined') {\n          metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n        } else {\n          metadata = 0;\n          if (typeof tokenStyle.italic !== 'undefined') {\n            const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n            metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n          }\n          if (typeof tokenStyle.bold !== 'undefined') {\n            const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n            metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n          }\n          if (typeof tokenStyle.underline !== 'undefined') {\n            const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n            metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n          }\n          if (typeof tokenStyle.strikethrough !== 'undefined') {\n            const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n            metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n          }\n          if (tokenStyle.foreground) {\n            const foregroundBits = tokenStyle.foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n            metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n          }\n          if (metadata === 0) {\n            // Nothing!\n            metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n          }\n        }\n      } else {\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n        }\n        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n        tokenType = 'not-in-legend';\n      }\n      this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n      }\n    }\n    return metadata;\n  }\n  warnOverlappingSemanticTokens(lineNumber, startColumn) {\n    if (!this._hasWarnedOverlappingTokens) {\n      this._hasWarnedOverlappingTokens = true;\n      console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n    }\n  }\n  warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n    if (!this._hasWarnedInvalidLengthTokens) {\n      this._hasWarnedInvalidLengthTokens = true;\n      console.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n    }\n  }\n  warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n    if (!this._hasWarnedInvalidEditStart) {\n      this._hasWarnedInvalidEditStart = true;\n      console.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n    }\n  }\n};\nSemanticTokensProviderStyling = __decorate([__param(1, IThemeService), __param(2, ILanguageService), __param(3, ILogService)], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n  const srcData = tokens.data;\n  const tokenCount = tokens.data.length / 5 | 0;\n  const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n  const result = [];\n  let tokenIndex = 0;\n  let lastLineNumber = 1;\n  let lastStartCharacter = 0;\n  while (tokenIndex < tokenCount) {\n    const tokenStartIndex = tokenIndex;\n    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n    // Keep tokens on the same line in the same area...\n    if (tokenEndIndex < tokenCount) {\n      let smallTokenEndIndex = tokenEndIndex;\n      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n        smallTokenEndIndex--;\n      }\n      if (smallTokenEndIndex - 1 === tokenStartIndex) {\n        // there are so many tokens on this line that our area would be empty, we must now go right\n        let bigTokenEndIndex = tokenEndIndex;\n        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n          bigTokenEndIndex++;\n        }\n        tokenEndIndex = bigTokenEndIndex;\n      } else {\n        tokenEndIndex = smallTokenEndIndex;\n      }\n    }\n    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n    let destOffset = 0;\n    let areaLine = 0;\n    let prevLineNumber = 0;\n    let prevEndCharacter = 0;\n    while (tokenIndex < tokenEndIndex) {\n      const srcOffset = 5 * tokenIndex;\n      const deltaLine = srcData[srcOffset];\n      const deltaCharacter = srcData[srcOffset + 1];\n      // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n      // to validate below with the actual values that will be inserted in the Uint32Array result\n      const lineNumber = lastLineNumber + deltaLine | 0;\n      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter | 0 : deltaCharacter;\n      const length = srcData[srcOffset + 2];\n      const endCharacter = startCharacter + length | 0;\n      const tokenTypeIndex = srcData[srcOffset + 3];\n      const tokenModifierSet = srcData[srcOffset + 4];\n      if (endCharacter <= startCharacter) {\n        // this token is invalid (most likely a negative length casted to uint32)\n        styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n      } else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n        // this token overlaps with the previous token\n        styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n      } else {\n        const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n        if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n          if (areaLine === 0) {\n            areaLine = lineNumber;\n          }\n          destData[destOffset] = lineNumber - areaLine;\n          destData[destOffset + 1] = startCharacter;\n          destData[destOffset + 2] = endCharacter;\n          destData[destOffset + 3] = metadata;\n          destOffset += 4;\n          prevLineNumber = lineNumber;\n          prevEndCharacter = endCharacter;\n        }\n      }\n      lastLineNumber = lineNumber;\n      lastStartCharacter = startCharacter;\n      tokenIndex++;\n    }\n    if (destOffset !== destData.length) {\n      destData = destData.subarray(0, destOffset);\n    }\n    const tokens = SparseMultilineTokens.create(areaLine, destData);\n    result.push(tokens);\n  }\n  return result;\n}\nclass HashTableEntry {\n  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this.tokenTypeIndex = tokenTypeIndex;\n    this.tokenModifierSet = tokenModifierSet;\n    this.languageId = languageId;\n    this.metadata = metadata;\n    this.next = null;\n  }\n}\nclass HashTable {\n  constructor() {\n    this._elementsCount = 0;\n    this._currentLengthIndex = 0;\n    this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n    this._elements = [];\n    HashTable._nullOutEntries(this._elements, this._currentLength);\n  }\n  static _nullOutEntries(entries, length) {\n    for (let i = 0; i < length; i++) {\n      entries[i] = null;\n    }\n  }\n  _hash2(n1, n2) {\n    return (n1 << 5) - n1 + n2 | 0; // n1 * 31 + n2, keep as int32\n  }\n  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n  }\n  get(tokenTypeIndex, tokenModifierSet, languageId) {\n    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n    let p = this._elements[hash];\n    while (p) {\n      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n        return p;\n      }\n      p = p.next;\n    }\n    return null;\n  }\n  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this._elementsCount++;\n    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n      // expand!\n      const oldElements = this._elements;\n      this._currentLengthIndex++;\n      this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n      this._elements = [];\n      HashTable._nullOutEntries(this._elements, this._currentLength);\n      for (const first of oldElements) {\n        let p = first;\n        while (p) {\n          const oldNext = p.next;\n          p.next = null;\n          this._add(p);\n          p = oldNext;\n        }\n      }\n    }\n    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n  }\n  _add(element) {\n    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n    element.next = this._elements[hash];\n    this._elements[hash] = element;\n  }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TokenMetadata","IThemeService","ILogService","LogLevel","SparseMultilineTokens","ILanguageService","SemanticTokensProviderStyling","constructor","_legend","_themeService","_languageService","_logService","_hasWarnedOverlappingTokens","_hasWarnedInvalidLengthTokens","_hasWarnedInvalidEditStart","_hashTable","HashTable","getMetadata","tokenTypeIndex","tokenModifierSet","languageId","encodedLanguageId","languageIdCodec","encodeLanguageId","entry","get","metadata","getLevel","Trace","trace","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","italic","italicBit","bold","boldBit","underline","underlineBit","strikethrough","strikethroughBit","foreground","foregroundBits","add","join","warnOverlappingSemanticTokens","lineNumber","startColumn","console","warn","warnInvalidLengthSemanticTokens","warnInvalidEditStart","previousResultId","resultId","editIndex","editStart","maxExpectedStart","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","prevLineNumber","prevEndCharacter","srcOffset","deltaLine","deltaCharacter","startCharacter","endCharacter","subarray","create","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","entries","_hash2","n1","n2","_hashFunc","hash","p","oldElements","first","oldNext","_add","element"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hasWarnedOverlappingTokens = false;\n        this._hasWarnedInvalidLengthTokens = false;\n        this._hasWarnedInvalidEditStart = false;\n        this._hashTable = new HashTable();\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedInvalidLengthTokens) {\n            this._hasWarnedInvalidLengthTokens = true;\n            console.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n        if (!this._hasWarnedInvalidEditStart) {\n            this._hasWarnedInvalidEditStart = true;\n            console.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n            // to validate below with the actual values that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const endCharacter = (startCharacter + length) | 0;\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            if (endCharacter <= startCharacter) {\n                // this token is invalid (most likely a negative length casted to uint32)\n                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                // this token overlaps with the previous token\n                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else {\n                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n                    if (areaLine === 0) {\n                        areaLine = lineNumber;\n                    }\n                    destData[destOffset] = lineNumber - areaLine;\n                    destData[destOffset + 1] = startCharacter;\n                    destData[destOffset + 2] = endCharacter;\n                    destData[destOffset + 3] = metadata;\n                    destOffset += 4;\n                    prevLineNumber = lineNumber;\n                    prevEndCharacter = endCharacter;\n                }\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}