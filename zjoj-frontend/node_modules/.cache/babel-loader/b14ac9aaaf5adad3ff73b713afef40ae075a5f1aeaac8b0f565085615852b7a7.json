{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n  constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n    this._editorId = editorId;\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    this.wordBreak = wordBreak;\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  dispose() {\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n  }\n  createCoordinatesConverter() {\n    return new CoordinatesConverter(this);\n  }\n  _constructLines(resetHiddenAreas, previousLineBreaks) {\n    this.modelLineProjections = [];\n    if (resetHiddenAreas) {\n      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    const linesContent = this.model.getLinesContent();\n    const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n    const lineCount = linesContent.length;\n    const lineBreaksComputer = this.createLineBreaksComputer();\n    const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n    for (let i = 0; i < lineCount; i++) {\n      const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n      lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n    }\n    const linesBreaks = lineBreaksComputer.finalize();\n    const values = [];\n    const hiddenAreas = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n    for (let i = 0; i < lineCount; i++) {\n      const lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n      const isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.modelLineProjections[i] = line;\n    }\n    this._validModelVersionId = this.model.getVersionId();\n    this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n  }\n  getHiddenAreas() {\n    return this.hiddenAreasDecorationIds.map(decId => this.model.getDecorationRange(decId));\n  }\n  setHiddenAreas(_ranges) {\n    const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n    const newRanges = normalizeLineRanges(validatedRanges);\n    // TODO@Martin: Please stop calling this method on each model change!\n    // This checks if there really was a change\n    const oldRanges = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    if (newRanges.length === oldRanges.length) {\n      let hasDifference = false;\n      for (let i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n      if (!hasDifference) {\n        return false;\n      }\n    }\n    const newDecorations = newRanges.map(r => ({\n      range: r,\n      options: ModelDecorationOptions.EMPTY\n    }));\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n    const hiddenAreas = newRanges;\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n    let hasVisibleLine = false;\n    for (let i = 0; i < this.modelLineProjections.length; i++) {\n      const lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n      }\n      let lineChanged = false;\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true;\n        // Line should be visible\n        if (!this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n      if (lineChanged) {\n        const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n        this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n      }\n    }\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n    return true;\n  }\n  modelPositionIsVisible(modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return false;\n    }\n    return this.modelLineProjections[modelLineNumber - 1].isVisible();\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return 1;\n    }\n    return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n  }\n  setTabSize(newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n    this.tabSize = newTabSize;\n    this._constructLines( /*resetHiddenAreas*/false, null);\n    return true;\n  }\n  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n    const equalFontInfo = this.fontInfo.equals(fontInfo);\n    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n    const equalWordBreak = this.wordBreak === wordBreak;\n    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n      return false;\n    }\n    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak;\n    this.fontInfo = fontInfo;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    this.wordBreak = wordBreak;\n    let previousLineBreaks = null;\n    if (onlyWrappingColumnChanged) {\n      previousLineBreaks = [];\n      for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n        previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n      }\n    }\n    this._constructLines( /*resetHiddenAreas*/false, previousLineBreaks);\n    return true;\n  }\n  createLineBreaksComputer() {\n    const lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n  }\n  onModelFlushed() {\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n    this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  }\n  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n    const isInHiddenArea = fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible();\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    let totalOutputLineCount = 0;\n    const insertLines = [];\n    const insertPrefixSumValues = [];\n    for (let i = 0, len = lineBreaks.length; i < len; i++) {\n      const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n      insertLines.push(line);\n      const outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    }\n    // TODO@Alex: use arrays.arrayInsert\n    this.modelLineProjections = this.modelLineProjections.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.modelLineProjections.slice(fromLineNumber - 1));\n    this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  }\n  onModelLineChanged(versionId, lineNumber, lineBreakData) {\n    if (versionId !== null && versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n    const lineIndex = lineNumber - 1;\n    const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    const isVisible = this.modelLineProjections[lineIndex].isVisible();\n    const line = createModelLineProjection(lineBreakData, isVisible);\n    this.modelLineProjections[lineIndex] = line;\n    const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    let lineMappingChanged = false;\n    let changeFrom = 0;\n    let changeTo = -1;\n    let insertFrom = 0;\n    let insertTo = -1;\n    let deleteFrom = 0;\n    let deleteTo = -1;\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n    this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n    const viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null;\n    const viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  }\n  acceptVersionId(versionId) {\n    this._validModelVersionId = versionId;\n    if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  }\n  getViewLineCount() {\n    return this.projectedModelLineLineCounts.getTotalSum();\n  }\n  _toValidViewLineNumber(viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n    const viewLineCount = this.getViewLineCount();\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n    return viewLineNumber | 0;\n  }\n  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  }\n  // #region ViewLineInfo\n  getViewLineInfo(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    return new ViewLineInfo(lineIndex + 1, remainder);\n  }\n  getMinColumnOfViewLine(viewLineInfo) {\n    return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n  getMaxColumnOfViewLine(viewLineInfo) {\n    return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n  getModelStartPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n  getModelEndPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n  getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n    const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n    const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n    const result = new Array();\n    let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n    let viewLines = new Array();\n    for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n      const line = this.modelLineProjections[curModelLine - 1];\n      if (line.isVisible()) {\n        const startOffset = curModelLine === startViewLine.modelLineNumber ? startViewLine.modelLineWrappedLineIdx : 0;\n        const endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();\n        for (let i = startOffset; i < endOffset; i++) {\n          viewLines.push(new ViewLineInfo(curModelLine, i));\n        }\n      }\n      if (!line.isVisible() && lastVisibleModelPos) {\n        const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n        const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n        result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        viewLines = [];\n        lastVisibleModelPos = null;\n      } else if (line.isVisible() && !lastVisibleModelPos) {\n        lastVisibleModelPos = new Position(curModelLine, 1);\n      }\n    }\n    if (lastVisibleModelPos) {\n      const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n      result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n    }\n    return result;\n  }\n  // #endregion\n  getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n    const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n    const resultPerViewLine = [];\n    for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n      const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n      const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n      for (const viewLineInfo of group.viewLines) {\n        const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n        // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n        // model-columns must be converted to view-model columns.\n        const result = bracketGuides.map(g => {\n          if (g.forWrappedLinesAfterColumn !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n            if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n            if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          if (!g.horizontalLine) {\n            return g;\n          }\n          let column = -1;\n          if (g.column !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n            if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n              column = p.column;\n            } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n              column = this.getMinColumnOfViewLine(viewLineInfo);\n            } else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n          const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n          if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n            return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n          } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n            return undefined;\n          } else {\n            if (g.visibleColumn !== -1) {\n              // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n              return undefined;\n            }\n            return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n          }\n        });\n        resultPerViewLine.push(result.filter(r => !!r));\n      }\n    }\n    return resultPerViewLine;\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    // TODO: Use the same code as in `getViewLinesBracketGuides`.\n    // Future TODO: Merge with `getViewLinesBracketGuides`.\n    // However, this requires more refactoring of indent guides.\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    let result = [];\n    const resultRepeatCount = [];\n    const resultRepeatOption = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (line.isVisible()) {\n        const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        const count = viewLineEndIndex - viewLineStartIndex + 1;\n        let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */;\n        }\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option);\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const viewIndents = new Array(viewLineCount);\n    let currIndex = 0;\n    for (let i = 0, len = result.length; i < len; i++) {\n      let value = result[i];\n      const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      const option = resultRepeatOption[i];\n      let blockAtIndex;\n      if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n        blockAtIndex = 0;\n      } else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n        blockAtIndex = 1;\n      } else {\n        blockAtIndex = count;\n      }\n      for (let j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n        viewIndents[currIndex++] = value;\n      }\n    }\n    return viewIndents;\n  }\n  getViewLineContent(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineLength(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineData(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n    let viewLineNumber = viewStartLineNumber;\n    const startModelLineIndex = start.index;\n    const startRemainder = start.remainder;\n    const result = [];\n    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (!line.isVisible()) {\n        continue;\n      }\n      const fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      let lastLine = false;\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n      if (lastLine) {\n        break;\n      }\n    }\n    return result;\n  }\n  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    const line = this.modelLineProjections[lineIndex];\n    const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n    const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }\n  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n    // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n    return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n  }\n  convertViewRangeToModelRange(viewRange) {\n    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    const inputLineNumber = validPosition.lineNumber;\n    const inputColumn = validPosition.column;\n    let lineIndex = inputLineNumber - 1,\n      lineIndexChanged = false;\n    if (belowHiddenRanges) {\n      while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n        lineIndex++;\n        lineIndexChanged = true;\n      }\n    } else {\n      while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n        lineIndex--;\n        lineIndexChanged = true;\n      }\n    }\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      // TODO@alexdima@hediet this isn't soo pretty\n      return new Position(allowZeroLineNumber ? 0 : 1, 1);\n    }\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    let r;\n    if (lineIndexChanged) {\n      if (belowHiddenRanges) {\n        r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n      } else {\n        r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n      }\n    } else {\n      r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n    }\n    // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n    return r;\n  }\n  /**\n   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n  */\n  convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n    if (modelRange.isEmpty()) {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n      return Range.fromPositions(start);\n    } else {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n      const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    let lineIndex = modelLineNumber - 1;\n    if (this.modelLineProjections[lineIndex].isVisible()) {\n      // this model line is visible\n      const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n      return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n    }\n    // this model line is not visible\n    while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n    const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    let result = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n      reqStart = null;\n    }\n    result.sort((a, b) => {\n      const res = Range.compareRangesUsingStarts(a.range, b.range);\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n        if (a.id > b.id) {\n          return 1;\n        }\n        return 0;\n      }\n      return res;\n    });\n    // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n    const finalResult = [];\n    let finalResultLen = 0;\n    let prevDecId = null;\n    for (const dec of result) {\n      const decId = dec.id;\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n    return finalResult;\n  }\n  getInjectedTextAt(position) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n  }\n  normalizePosition(position, affinity) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n  }\n  getLineIndentColumn(lineNumber) {\n    const info = this.getViewLineInfo(lineNumber);\n    if (info.modelLineWrappedLineIdx === 0) {\n      return this.model.getLineIndentColumn(info.modelLineNumber);\n    }\n    // wrapped lines have no indentation.\n    // We deliberately don't handle the case that indentation is wrapped\n    // to avoid two view lines reporting indentation for the very same model line.\n    return 0;\n  }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n  if (ranges.length === 0) {\n    return [];\n  }\n  const sortedRanges = ranges.slice();\n  sortedRanges.sort(Range.compareRangesUsingStarts);\n  const result = [];\n  let currentRangeStart = sortedRanges[0].startLineNumber;\n  let currentRangeEnd = sortedRanges[0].endLineNumber;\n  for (let i = 1, len = sortedRanges.length; i < len; i++) {\n    const range = sortedRanges[i];\n    if (range.startLineNumber > currentRangeEnd + 1) {\n      result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n      currentRangeStart = range.startLineNumber;\n      currentRangeEnd = range.endLineNumber;\n    } else if (range.endLineNumber > currentRangeEnd) {\n      currentRangeEnd = range.endLineNumber;\n    }\n  }\n  result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n  return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n  constructor(modelLineNumber, modelLineWrappedLineIdx) {\n    this.modelLineNumber = modelLineNumber;\n    this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n  }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n  constructor(modelRange, viewLines) {\n    this.modelRange = modelRange;\n    this.viewLines = viewLines;\n  }\n}\nclass CoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._lines.convertViewRangeToModelRange(viewRange);\n  }\n  validateViewPosition(viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    return this._lines.validateViewRange(viewRange, expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n  }\n  convertModelRangeToViewRange(modelRange, affinity) {\n    return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n  }\n  modelPositionIsVisible(modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return this._lines.getModelLineViewLineCount(modelLineNumber);\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n  }\n}\nexport class ViewModelLinesFromModelAsIs {\n  constructor(model) {\n    this.model = model;\n  }\n  dispose() {}\n  createCoordinatesConverter() {\n    return new IdentityCoordinatesConverter(this);\n  }\n  getHiddenAreas() {\n    return [];\n  }\n  setHiddenAreas(_ranges) {\n    return false;\n  }\n  setTabSize(_newTabSize) {\n    return false;\n  }\n  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n    return false;\n  }\n  createLineBreaksComputer() {\n    const result = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        result.push(null);\n      },\n      finalize: () => {\n        return result;\n      }\n    };\n  }\n  onModelFlushed() {}\n  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n  }\n  acceptVersionId(_versionId) {}\n  getViewLineCount() {\n    return this.model.getLineCount();\n  }\n  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  }\n  getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n    return new Array(endLineNumber - startLineNumber + 1).fill([]);\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const result = new Array(viewLineCount);\n    for (let i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n    return result;\n  }\n  getViewLineContent(viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  }\n  getViewLineLength(viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  }\n  getViewLineData(viewLineNumber) {\n    const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n    const lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    const lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    const result = [];\n    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      const idx = lineNumber - viewStartLineNumber;\n      result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n    }\n    return result;\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n  }\n  normalizePosition(position, affinity) {\n    return this.model.normalizePosition(position, affinity);\n  }\n  getLineIndentColumn(lineNumber) {\n    return this.model.getLineIndentColumn(lineNumber);\n  }\n  getInjectedTextAt(position) {\n    // Identity lines collection does not support injected text.\n    return null;\n  }\n}\nclass IdentityCoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  _validPosition(pos) {\n    return this._lines.model.validatePosition(pos);\n  }\n  _validRange(range) {\n    return this._lines.model.validateRange(range);\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._validPosition(viewPosition);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._validRange(viewRange);\n  }\n  validateViewPosition(_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  }\n  validateViewRange(_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._validPosition(modelPosition);\n  }\n  convertModelRangeToViewRange(modelRange) {\n    return this._validRange(modelRange);\n  }\n  modelPositionIsVisible(modelPosition) {\n    const lineCount = this._lines.model.getLineCount();\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n    return true;\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return 1;\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return modelLineNumber;\n  }\n}","map":{"version":3,"names":["arrays","Position","Range","IndentGuide","IndentGuideHorizontalLine","ModelDecorationOptions","LineInjectedText","viewEvents","createModelLineProjection","ConstantTimePrefixSumComputer","ViewLineData","ViewModelLinesFromProjectedModel","constructor","editorId","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","wordBreak","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","dispose","hiddenAreasDecorationIds","deltaDecorations","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineCount","length","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","ArrayQueue","fromDecorations","i","lineInjectedText","takeWhile","t","lineNumber","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","getViewLineCount","getVersionId","projectedModelLineLineCounts","getHiddenAreas","decId","setHiddenAreas","_ranges","validatedRanges","r","validateRange","newRanges","normalizeLineRanges","oldRanges","hasDifference","equalsRange","newDecorations","range","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","setValue","modelPositionIsVisible","modelLineNumber","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","equalWordBreak","onlyWrappingColumnChanged","len","getProjectionData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","getPrefixSum","outputToLineNumber","splice","removeValues","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","push","outputLineCount","slice","concat","insertValues","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","getTotalSum","_toValidViewLineNumber","viewLineNumber","viewLineCount","getActiveIndentGuide","minLineNumber","maxLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","result","guides","viewStartPosition","convertModelPositionToViewPosition","viewEndPosition","getLineMaxColumn","indent","getViewLineInfo","getIndexOf","index","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getMaxColumnOfViewLine","getViewLineMaxColumn","getModelStartPositionOfViewLine","minViewColumn","column","getModelColumnOfViewPosition","getModelEndPositionOfViewLine","maxViewColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","Array","lastVisibleModelPos","viewLines","curModelLine","startOffset","endOffset","lastVisibleModelPos2","modelRange","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","bracketGuides","g","forWrappedLinesAfterColumn","p","getViewPositionOfModelPosition","undefined","forWrappedLinesBeforeOrAtColumn","horizontalLine","viewPosition","endColumn","visibleColumn","className","top","filter","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","currIndex","value","Math","min","blockAtIndex","j","getViewLineContent","info","getViewLineLength","getViewLineData","getViewLinesData","needed","start","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","validateViewPosition","viewColumn","expectedModelPosition","minColumn","maxColumn","computedModelColumn","computedModelPosition","validatePosition","validateViewRange","viewRange","expectedModelRange","validViewStart","startColumn","getStartPosition","validViewEnd","getEndPosition","inputColumn","convertViewRangeToModelRange","end","_modelLineNumber","affinity","allowZeroLineNumber","belowHiddenRanges","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","convertModelRangeToViewRange","isEmpty","modelColumn","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","onlyMarginDecorations","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","getInjectedTextAt","position","normalizePosition","getLineIndentColumn","ranges","sortedRanges","currentRangeStart","currentRangeEnd","lines","_lines","allowZero","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","injectedText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","getLineContent","getLineLength","getLineMinColumn","lineTokens","tokenization","getLineTokens","lineContent","inflate","max","idx","_validPosition","pos","_validRange","_viewPosition","_viewRange"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}