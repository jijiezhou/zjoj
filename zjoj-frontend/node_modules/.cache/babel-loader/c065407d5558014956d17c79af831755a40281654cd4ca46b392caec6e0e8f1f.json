{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n  isEmpty() {\n    return Range.isEmpty(this);\n  }\n  /**\n   * Test if `range` is empty.\n   */\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n  }\n  /**\n   * Test if position is in this range. If the position is at the edges, will return true.\n   */\n  containsPosition(position) {\n    return Range.containsPosition(this, position);\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\n   */\n  static containsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return false.\n   * @internal\n   */\n  static strictContainsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if range is in this range. If the range is equal to this range, will return true.\n   */\n  containsRange(range) {\n    return Range.containsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n   */\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n   */\n  strictContainsRange(range) {\n    return Range.strictContainsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n   */\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  plusRange(range) {\n    return Range.plusRange(this, range);\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  static plusRange(a, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n    if (b.startLineNumber < a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a.startColumn);\n    } else {\n      startLineNumber = a.startLineNumber;\n      startColumn = a.startColumn;\n    }\n    if (b.endLineNumber > a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a.endColumn);\n    } else {\n      endLineNumber = a.endLineNumber;\n      endColumn = a.endColumn;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  intersectRanges(range) {\n    return Range.intersectRanges(this, range);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  static intersectRanges(a, b) {\n    let resultStartLineNumber = a.startLineNumber;\n    let resultStartColumn = a.startColumn;\n    let resultEndLineNumber = a.endLineNumber;\n    let resultEndColumn = a.endColumn;\n    const otherStartLineNumber = b.startLineNumber;\n    const otherStartColumn = b.startColumn;\n    const otherEndLineNumber = b.endLineNumber;\n    const otherEndColumn = b.endColumn;\n    if (resultStartLineNumber < otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n    if (resultEndLineNumber > otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    }\n    // Check if selection is now empty\n    if (resultStartLineNumber > resultEndLineNumber) {\n      return null;\n    }\n    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n      return null;\n    }\n    return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\n   * Test if this range equals other.\n   */\n  equalsRange(other) {\n    return Range.equalsRange(this, other);\n  }\n  /**\n   * Test if range `a` equals `b`.\n   */\n  static equalsRange(a, b) {\n    if (!a && !b) {\n      return true;\n    }\n    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  getEndPosition() {\n    return Range.getEndPosition(this);\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  getStartPosition() {\n    return Range.getStartPosition(this);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Transform to a user presentable string representation.\n   */\n  toString() {\n    return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n  }\n  /**\n   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  collapseToStart() {\n    return Range.collapseToStart(this);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  static collapseToStart(range) {\n    return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  collapseToEnd() {\n    return Range.collapseToEnd(this);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  static collapseToEnd(range) {\n    return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Moves the range by the given amount of lines.\n   */\n  delta(lineCount) {\n    return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n  }\n  // ---\n  static fromPositions(start, end = start) {\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  static lift(range) {\n    if (!range) {\n      return null;\n    }\n    return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Test if `obj` is an `IRange`.\n   */\n  static isIRange(obj) {\n    return obj && typeof obj.startLineNumber === 'number' && typeof obj.startColumn === 'number' && typeof obj.endLineNumber === 'number' && typeof obj.endColumn === 'number';\n  }\n  /**\n   * Test if the two ranges are touching in any way.\n   */\n  static areIntersectingOrTouching(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {\n      return false;\n    }\n    // Check if `b` is before `a`\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {\n      return false;\n    }\n    // These ranges must intersect\n    return true;\n  }\n  /**\n   * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n   */\n  static areIntersecting(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {\n      return false;\n    }\n    // Check if `b` is before `a`\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {\n      return false;\n    }\n    // These ranges must intersect\n    return true;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the startPosition and then on the endPosition\n   */\n  static compareRangesUsingStarts(a, b) {\n    if (a && b) {\n      const aStartLineNumber = a.startLineNumber | 0;\n      const bStartLineNumber = b.startLineNumber | 0;\n      if (aStartLineNumber === bStartLineNumber) {\n        const aStartColumn = a.startColumn | 0;\n        const bStartColumn = b.startColumn | 0;\n        if (aStartColumn === bStartColumn) {\n          const aEndLineNumber = a.endLineNumber | 0;\n          const bEndLineNumber = b.endLineNumber | 0;\n          if (aEndLineNumber === bEndLineNumber) {\n            const aEndColumn = a.endColumn | 0;\n            const bEndColumn = b.endColumn | 0;\n            return aEndColumn - bEndColumn;\n          }\n          return aEndLineNumber - bEndLineNumber;\n        }\n        return aStartColumn - bStartColumn;\n      }\n      return aStartLineNumber - bStartLineNumber;\n    }\n    const aExists = a ? 1 : 0;\n    const bExists = b ? 1 : 0;\n    return aExists - bExists;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the endPosition and then on the startPosition\n   */\n  static compareRangesUsingEnds(a, b) {\n    if (a.endLineNumber === b.endLineNumber) {\n      if (a.endColumn === b.endColumn) {\n        if (a.startLineNumber === b.startLineNumber) {\n          return a.startColumn - b.startColumn;\n        }\n        return a.startLineNumber - b.startLineNumber;\n      }\n      return a.endColumn - b.endColumn;\n    }\n    return a.endLineNumber - b.endLineNumber;\n  }\n  /**\n   * Test if the range spans multiple lines.\n   */\n  static spansMultipleLines(range) {\n    return range.endLineNumber > range.startLineNumber;\n  }\n  toJSON() {\n    return this;\n  }\n}","map":{"version":3,"names":["Position","Range","constructor","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","range","containsPosition","position","lineNumber","column","strictContainsPosition","containsRange","otherRange","strictContainsRange","plusRange","a","b","Math","min","max","intersectRanges","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","equalsRange","other","getEndPosition","getStartPosition","toString","setEndPosition","setStartPosition","collapseToStart","collapseToEnd","delta","lineCount","fromPositions","start","end","lift","isIRange","obj","areIntersectingOrTouching","areIntersecting","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists","compareRangesUsingEnds","spansMultipleLines","toJSON"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,eAAe;AACxC;AACA;AACA;AACA,OAAO,MAAMC,KAAK,CAAC;EACfC,WAAWA,CAACC,eAAe,EAAEC,WAAW,EAAEC,aAAa,EAAEC,SAAS,EAAE;IAChE,IAAKH,eAAe,GAAGE,aAAa,IAAMF,eAAe,KAAKE,aAAa,IAAID,WAAW,GAAGE,SAAU,EAAE;MACrG,IAAI,CAACH,eAAe,GAAGE,aAAa;MACpC,IAAI,CAACD,WAAW,GAAGE,SAAS;MAC5B,IAAI,CAACD,aAAa,GAAGF,eAAe;MACpC,IAAI,CAACG,SAAS,GAAGF,WAAW;IAChC,CAAC,MACI;MACD,IAAI,CAACD,eAAe,GAAGA,eAAe;MACtC,IAAI,CAACC,WAAW,GAAGA,WAAW;MAC9B,IAAI,CAACC,aAAa,GAAGA,aAAa;MAClC,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC9B;EACJ;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAON,KAAK,CAACM,OAAO,CAAC,IAAI,CAAC;EAC9B;EACA;AACJ;AACA;EACI,OAAOA,OAAOA,CAACC,KAAK,EAAE;IAClB,OAAQA,KAAK,CAACL,eAAe,KAAKK,KAAK,CAACH,aAAa,IAAIG,KAAK,CAACJ,WAAW,KAAKI,KAAK,CAACF,SAAS;EAClG;EACA;AACJ;AACA;EACIG,gBAAgBA,CAACC,QAAQ,EAAE;IACvB,OAAOT,KAAK,CAACQ,gBAAgB,CAAC,IAAI,EAAEC,QAAQ,CAAC;EACjD;EACA;AACJ;AACA;EACI,OAAOD,gBAAgBA,CAACD,KAAK,EAAEE,QAAQ,EAAE;IACrC,IAAIA,QAAQ,CAACC,UAAU,GAAGH,KAAK,CAACL,eAAe,IAAIO,QAAQ,CAACC,UAAU,GAAGH,KAAK,CAACH,aAAa,EAAE;MAC1F,OAAO,KAAK;IAChB;IACA,IAAIK,QAAQ,CAACC,UAAU,KAAKH,KAAK,CAACL,eAAe,IAAIO,QAAQ,CAACE,MAAM,GAAGJ,KAAK,CAACJ,WAAW,EAAE;MACtF,OAAO,KAAK;IAChB;IACA,IAAIM,QAAQ,CAACC,UAAU,KAAKH,KAAK,CAACH,aAAa,IAAIK,QAAQ,CAACE,MAAM,GAAGJ,KAAK,CAACF,SAAS,EAAE;MAClF,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,OAAOO,sBAAsBA,CAACL,KAAK,EAAEE,QAAQ,EAAE;IAC3C,IAAIA,QAAQ,CAACC,UAAU,GAAGH,KAAK,CAACL,eAAe,IAAIO,QAAQ,CAACC,UAAU,GAAGH,KAAK,CAACH,aAAa,EAAE;MAC1F,OAAO,KAAK;IAChB;IACA,IAAIK,QAAQ,CAACC,UAAU,KAAKH,KAAK,CAACL,eAAe,IAAIO,QAAQ,CAACE,MAAM,IAAIJ,KAAK,CAACJ,WAAW,EAAE;MACvF,OAAO,KAAK;IAChB;IACA,IAAIM,QAAQ,CAACC,UAAU,KAAKH,KAAK,CAACH,aAAa,IAAIK,QAAQ,CAACE,MAAM,IAAIJ,KAAK,CAACF,SAAS,EAAE;MACnF,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIQ,aAAaA,CAACN,KAAK,EAAE;IACjB,OAAOP,KAAK,CAACa,aAAa,CAAC,IAAI,EAAEN,KAAK,CAAC;EAC3C;EACA;AACJ;AACA;EACI,OAAOM,aAAaA,CAACN,KAAK,EAAEO,UAAU,EAAE;IACpC,IAAIA,UAAU,CAACZ,eAAe,GAAGK,KAAK,CAACL,eAAe,IAAIY,UAAU,CAACV,aAAa,GAAGG,KAAK,CAACL,eAAe,EAAE;MACxG,OAAO,KAAK;IAChB;IACA,IAAIY,UAAU,CAACZ,eAAe,GAAGK,KAAK,CAACH,aAAa,IAAIU,UAAU,CAACV,aAAa,GAAGG,KAAK,CAACH,aAAa,EAAE;MACpG,OAAO,KAAK;IAChB;IACA,IAAIU,UAAU,CAACZ,eAAe,KAAKK,KAAK,CAACL,eAAe,IAAIY,UAAU,CAACX,WAAW,GAAGI,KAAK,CAACJ,WAAW,EAAE;MACpG,OAAO,KAAK;IAChB;IACA,IAAIW,UAAU,CAACV,aAAa,KAAKG,KAAK,CAACH,aAAa,IAAIU,UAAU,CAACT,SAAS,GAAGE,KAAK,CAACF,SAAS,EAAE;MAC5F,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIU,mBAAmBA,CAACR,KAAK,EAAE;IACvB,OAAOP,KAAK,CAACe,mBAAmB,CAAC,IAAI,EAAER,KAAK,CAAC;EACjD;EACA;AACJ;AACA;EACI,OAAOQ,mBAAmBA,CAACR,KAAK,EAAEO,UAAU,EAAE;IAC1C,IAAIA,UAAU,CAACZ,eAAe,GAAGK,KAAK,CAACL,eAAe,IAAIY,UAAU,CAACV,aAAa,GAAGG,KAAK,CAACL,eAAe,EAAE;MACxG,OAAO,KAAK;IAChB;IACA,IAAIY,UAAU,CAACZ,eAAe,GAAGK,KAAK,CAACH,aAAa,IAAIU,UAAU,CAACV,aAAa,GAAGG,KAAK,CAACH,aAAa,EAAE;MACpG,OAAO,KAAK;IAChB;IACA,IAAIU,UAAU,CAACZ,eAAe,KAAKK,KAAK,CAACL,eAAe,IAAIY,UAAU,CAACX,WAAW,IAAII,KAAK,CAACJ,WAAW,EAAE;MACrG,OAAO,KAAK;IAChB;IACA,IAAIW,UAAU,CAACV,aAAa,KAAKG,KAAK,CAACH,aAAa,IAAIU,UAAU,CAACT,SAAS,IAAIE,KAAK,CAACF,SAAS,EAAE;MAC7F,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACIW,SAASA,CAACT,KAAK,EAAE;IACb,OAAOP,KAAK,CAACgB,SAAS,CAAC,IAAI,EAAET,KAAK,CAAC;EACvC;EACA;AACJ;AACA;AACA;EACI,OAAOS,SAASA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACnB,IAAIhB,eAAe;IACnB,IAAIC,WAAW;IACf,IAAIC,aAAa;IACjB,IAAIC,SAAS;IACb,IAAIa,CAAC,CAAChB,eAAe,GAAGe,CAAC,CAACf,eAAe,EAAE;MACvCA,eAAe,GAAGgB,CAAC,CAAChB,eAAe;MACnCC,WAAW,GAAGe,CAAC,CAACf,WAAW;IAC/B,CAAC,MACI,IAAIe,CAAC,CAAChB,eAAe,KAAKe,CAAC,CAACf,eAAe,EAAE;MAC9CA,eAAe,GAAGgB,CAAC,CAAChB,eAAe;MACnCC,WAAW,GAAGgB,IAAI,CAACC,GAAG,CAACF,CAAC,CAACf,WAAW,EAAEc,CAAC,CAACd,WAAW,CAAC;IACxD,CAAC,MACI;MACDD,eAAe,GAAGe,CAAC,CAACf,eAAe;MACnCC,WAAW,GAAGc,CAAC,CAACd,WAAW;IAC/B;IACA,IAAIe,CAAC,CAACd,aAAa,GAAGa,CAAC,CAACb,aAAa,EAAE;MACnCA,aAAa,GAAGc,CAAC,CAACd,aAAa;MAC/BC,SAAS,GAAGa,CAAC,CAACb,SAAS;IAC3B,CAAC,MACI,IAAIa,CAAC,CAACd,aAAa,KAAKa,CAAC,CAACb,aAAa,EAAE;MAC1CA,aAAa,GAAGc,CAAC,CAACd,aAAa;MAC/BC,SAAS,GAAGc,IAAI,CAACE,GAAG,CAACH,CAAC,CAACb,SAAS,EAAEY,CAAC,CAACZ,SAAS,CAAC;IAClD,CAAC,MACI;MACDD,aAAa,GAAGa,CAAC,CAACb,aAAa;MAC/BC,SAAS,GAAGY,CAAC,CAACZ,SAAS;IAC3B;IACA,OAAO,IAAIL,KAAK,CAACE,eAAe,EAAEC,WAAW,EAAEC,aAAa,EAAEC,SAAS,CAAC;EAC5E;EACA;AACJ;AACA;EACIiB,eAAeA,CAACf,KAAK,EAAE;IACnB,OAAOP,KAAK,CAACsB,eAAe,CAAC,IAAI,EAAEf,KAAK,CAAC;EAC7C;EACA;AACJ;AACA;EACI,OAAOe,eAAeA,CAACL,CAAC,EAAEC,CAAC,EAAE;IACzB,IAAIK,qBAAqB,GAAGN,CAAC,CAACf,eAAe;IAC7C,IAAIsB,iBAAiB,GAAGP,CAAC,CAACd,WAAW;IACrC,IAAIsB,mBAAmB,GAAGR,CAAC,CAACb,aAAa;IACzC,IAAIsB,eAAe,GAAGT,CAAC,CAACZ,SAAS;IACjC,MAAMsB,oBAAoB,GAAGT,CAAC,CAAChB,eAAe;IAC9C,MAAM0B,gBAAgB,GAAGV,CAAC,CAACf,WAAW;IACtC,MAAM0B,kBAAkB,GAAGX,CAAC,CAACd,aAAa;IAC1C,MAAM0B,cAAc,GAAGZ,CAAC,CAACb,SAAS;IAClC,IAAIkB,qBAAqB,GAAGI,oBAAoB,EAAE;MAC9CJ,qBAAqB,GAAGI,oBAAoB;MAC5CH,iBAAiB,GAAGI,gBAAgB;IACxC,CAAC,MACI,IAAIL,qBAAqB,KAAKI,oBAAoB,EAAE;MACrDH,iBAAiB,GAAGL,IAAI,CAACE,GAAG,CAACG,iBAAiB,EAAEI,gBAAgB,CAAC;IACrE;IACA,IAAIH,mBAAmB,GAAGI,kBAAkB,EAAE;MAC1CJ,mBAAmB,GAAGI,kBAAkB;MACxCH,eAAe,GAAGI,cAAc;IACpC,CAAC,MACI,IAAIL,mBAAmB,KAAKI,kBAAkB,EAAE;MACjDH,eAAe,GAAGP,IAAI,CAACC,GAAG,CAACM,eAAe,EAAEI,cAAc,CAAC;IAC/D;IACA;IACA,IAAIP,qBAAqB,GAAGE,mBAAmB,EAAE;MAC7C,OAAO,IAAI;IACf;IACA,IAAIF,qBAAqB,KAAKE,mBAAmB,IAAID,iBAAiB,GAAGE,eAAe,EAAE;MACtF,OAAO,IAAI;IACf;IACA,OAAO,IAAI1B,KAAK,CAACuB,qBAAqB,EAAEC,iBAAiB,EAAEC,mBAAmB,EAAEC,eAAe,CAAC;EACpG;EACA;AACJ;AACA;EACIK,WAAWA,CAACC,KAAK,EAAE;IACf,OAAOhC,KAAK,CAAC+B,WAAW,CAAC,IAAI,EAAEC,KAAK,CAAC;EACzC;EACA;AACJ;AACA;EACI,OAAOD,WAAWA,CAACd,CAAC,EAAEC,CAAC,EAAE;IACrB,IAAI,CAACD,CAAC,IAAI,CAACC,CAAC,EAAE;MACV,OAAO,IAAI;IACf;IACA,OAAQ,CAAC,CAACD,CAAC,IACP,CAAC,CAACC,CAAC,IACHD,CAAC,CAACf,eAAe,KAAKgB,CAAC,CAAChB,eAAe,IACvCe,CAAC,CAACd,WAAW,KAAKe,CAAC,CAACf,WAAW,IAC/Bc,CAAC,CAACb,aAAa,KAAKc,CAAC,CAACd,aAAa,IACnCa,CAAC,CAACZ,SAAS,KAAKa,CAAC,CAACb,SAAS;EACnC;EACA;AACJ;AACA;EACI4B,cAAcA,CAAA,EAAG;IACb,OAAOjC,KAAK,CAACiC,cAAc,CAAC,IAAI,CAAC;EACrC;EACA;AACJ;AACA;EACI,OAAOA,cAAcA,CAAC1B,KAAK,EAAE;IACzB,OAAO,IAAIR,QAAQ,CAACQ,KAAK,CAACH,aAAa,EAAEG,KAAK,CAACF,SAAS,CAAC;EAC7D;EACA;AACJ;AACA;EACI6B,gBAAgBA,CAAA,EAAG;IACf,OAAOlC,KAAK,CAACkC,gBAAgB,CAAC,IAAI,CAAC;EACvC;EACA;AACJ;AACA;EACI,OAAOA,gBAAgBA,CAAC3B,KAAK,EAAE;IAC3B,OAAO,IAAIR,QAAQ,CAACQ,KAAK,CAACL,eAAe,EAAEK,KAAK,CAACJ,WAAW,CAAC;EACjE;EACA;AACJ;AACA;EACIgC,QAAQA,CAAA,EAAG;IACP,OAAO,GAAG,GAAG,IAAI,CAACjC,eAAe,GAAG,GAAG,GAAG,IAAI,CAACC,WAAW,GAAG,MAAM,GAAG,IAAI,CAACC,aAAa,GAAG,GAAG,GAAG,IAAI,CAACC,SAAS,GAAG,GAAG;EACzH;EACA;AACJ;AACA;EACI+B,cAAcA,CAAChC,aAAa,EAAEC,SAAS,EAAE;IACrC,OAAO,IAAIL,KAAK,CAAC,IAAI,CAACE,eAAe,EAAE,IAAI,CAACC,WAAW,EAAEC,aAAa,EAAEC,SAAS,CAAC;EACtF;EACA;AACJ;AACA;EACIgC,gBAAgBA,CAACnC,eAAe,EAAEC,WAAW,EAAE;IAC3C,OAAO,IAAIH,KAAK,CAACE,eAAe,EAAEC,WAAW,EAAE,IAAI,CAACC,aAAa,EAAE,IAAI,CAACC,SAAS,CAAC;EACtF;EACA;AACJ;AACA;EACIiC,eAAeA,CAAA,EAAG;IACd,OAAOtC,KAAK,CAACsC,eAAe,CAAC,IAAI,CAAC;EACtC;EACA;AACJ;AACA;EACI,OAAOA,eAAeA,CAAC/B,KAAK,EAAE;IAC1B,OAAO,IAAIP,KAAK,CAACO,KAAK,CAACL,eAAe,EAAEK,KAAK,CAACJ,WAAW,EAAEI,KAAK,CAACL,eAAe,EAAEK,KAAK,CAACJ,WAAW,CAAC;EACxG;EACA;AACJ;AACA;EACIoC,aAAaA,CAAA,EAAG;IACZ,OAAOvC,KAAK,CAACuC,aAAa,CAAC,IAAI,CAAC;EACpC;EACA;AACJ;AACA;EACI,OAAOA,aAAaA,CAAChC,KAAK,EAAE;IACxB,OAAO,IAAIP,KAAK,CAACO,KAAK,CAACH,aAAa,EAAEG,KAAK,CAACF,SAAS,EAAEE,KAAK,CAACH,aAAa,EAAEG,KAAK,CAACF,SAAS,CAAC;EAChG;EACA;AACJ;AACA;EACImC,KAAKA,CAACC,SAAS,EAAE;IACb,OAAO,IAAIzC,KAAK,CAAC,IAAI,CAACE,eAAe,GAAGuC,SAAS,EAAE,IAAI,CAACtC,WAAW,EAAE,IAAI,CAACC,aAAa,GAAGqC,SAAS,EAAE,IAAI,CAACpC,SAAS,CAAC;EACxH;EACA;EACA,OAAOqC,aAAaA,CAACC,KAAK,EAAEC,GAAG,GAAGD,KAAK,EAAE;IACrC,OAAO,IAAI3C,KAAK,CAAC2C,KAAK,CAACjC,UAAU,EAAEiC,KAAK,CAAChC,MAAM,EAAEiC,GAAG,CAAClC,UAAU,EAAEkC,GAAG,CAACjC,MAAM,CAAC;EAChF;EACA,OAAOkC,IAAIA,CAACtC,KAAK,EAAE;IACf,IAAI,CAACA,KAAK,EAAE;MACR,OAAO,IAAI;IACf;IACA,OAAO,IAAIP,KAAK,CAACO,KAAK,CAACL,eAAe,EAAEK,KAAK,CAACJ,WAAW,EAAEI,KAAK,CAACH,aAAa,EAAEG,KAAK,CAACF,SAAS,CAAC;EACpG;EACA;AACJ;AACA;EACI,OAAOyC,QAAQA,CAACC,GAAG,EAAE;IACjB,OAAQA,GAAG,IACH,OAAOA,GAAG,CAAC7C,eAAe,KAAK,QAAS,IACxC,OAAO6C,GAAG,CAAC5C,WAAW,KAAK,QAAS,IACpC,OAAO4C,GAAG,CAAC3C,aAAa,KAAK,QAAS,IACtC,OAAO2C,GAAG,CAAC1C,SAAS,KAAK,QAAS;EAC9C;EACA;AACJ;AACA;EACI,OAAO2C,yBAAyBA,CAAC/B,CAAC,EAAEC,CAAC,EAAE;IACnC;IACA,IAAID,CAAC,CAACb,aAAa,GAAGc,CAAC,CAAChB,eAAe,IAAKe,CAAC,CAACb,aAAa,KAAKc,CAAC,CAAChB,eAAe,IAAIe,CAAC,CAACZ,SAAS,GAAGa,CAAC,CAACf,WAAY,EAAE;MAC/G,OAAO,KAAK;IAChB;IACA;IACA,IAAIe,CAAC,CAACd,aAAa,GAAGa,CAAC,CAACf,eAAe,IAAKgB,CAAC,CAACd,aAAa,KAAKa,CAAC,CAACf,eAAe,IAAIgB,CAAC,CAACb,SAAS,GAAGY,CAAC,CAACd,WAAY,EAAE;MAC/G,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACI,OAAO8C,eAAeA,CAAChC,CAAC,EAAEC,CAAC,EAAE;IACzB;IACA,IAAID,CAAC,CAACb,aAAa,GAAGc,CAAC,CAAChB,eAAe,IAAKe,CAAC,CAACb,aAAa,KAAKc,CAAC,CAAChB,eAAe,IAAIe,CAAC,CAACZ,SAAS,IAAIa,CAAC,CAACf,WAAY,EAAE;MAChH,OAAO,KAAK;IAChB;IACA;IACA,IAAIe,CAAC,CAACd,aAAa,GAAGa,CAAC,CAACf,eAAe,IAAKgB,CAAC,CAACd,aAAa,KAAKa,CAAC,CAACf,eAAe,IAAIgB,CAAC,CAACb,SAAS,IAAIY,CAAC,CAACd,WAAY,EAAE;MAChH,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,OAAO+C,wBAAwBA,CAACjC,CAAC,EAAEC,CAAC,EAAE;IAClC,IAAID,CAAC,IAAIC,CAAC,EAAE;MACR,MAAMiC,gBAAgB,GAAGlC,CAAC,CAACf,eAAe,GAAG,CAAC;MAC9C,MAAMkD,gBAAgB,GAAGlC,CAAC,CAAChB,eAAe,GAAG,CAAC;MAC9C,IAAIiD,gBAAgB,KAAKC,gBAAgB,EAAE;QACvC,MAAMC,YAAY,GAAGpC,CAAC,CAACd,WAAW,GAAG,CAAC;QACtC,MAAMmD,YAAY,GAAGpC,CAAC,CAACf,WAAW,GAAG,CAAC;QACtC,IAAIkD,YAAY,KAAKC,YAAY,EAAE;UAC/B,MAAMC,cAAc,GAAGtC,CAAC,CAACb,aAAa,GAAG,CAAC;UAC1C,MAAMoD,cAAc,GAAGtC,CAAC,CAACd,aAAa,GAAG,CAAC;UAC1C,IAAImD,cAAc,KAAKC,cAAc,EAAE;YACnC,MAAMC,UAAU,GAAGxC,CAAC,CAACZ,SAAS,GAAG,CAAC;YAClC,MAAMqD,UAAU,GAAGxC,CAAC,CAACb,SAAS,GAAG,CAAC;YAClC,OAAOoD,UAAU,GAAGC,UAAU;UAClC;UACA,OAAOH,cAAc,GAAGC,cAAc;QAC1C;QACA,OAAOH,YAAY,GAAGC,YAAY;MACtC;MACA,OAAOH,gBAAgB,GAAGC,gBAAgB;IAC9C;IACA,MAAMO,OAAO,GAAI1C,CAAC,GAAG,CAAC,GAAG,CAAE;IAC3B,MAAM2C,OAAO,GAAI1C,CAAC,GAAG,CAAC,GAAG,CAAE;IAC3B,OAAOyC,OAAO,GAAGC,OAAO;EAC5B;EACA;AACJ;AACA;AACA;EACI,OAAOC,sBAAsBA,CAAC5C,CAAC,EAAEC,CAAC,EAAE;IAChC,IAAID,CAAC,CAACb,aAAa,KAAKc,CAAC,CAACd,aAAa,EAAE;MACrC,IAAIa,CAAC,CAACZ,SAAS,KAAKa,CAAC,CAACb,SAAS,EAAE;QAC7B,IAAIY,CAAC,CAACf,eAAe,KAAKgB,CAAC,CAAChB,eAAe,EAAE;UACzC,OAAOe,CAAC,CAACd,WAAW,GAAGe,CAAC,CAACf,WAAW;QACxC;QACA,OAAOc,CAAC,CAACf,eAAe,GAAGgB,CAAC,CAAChB,eAAe;MAChD;MACA,OAAOe,CAAC,CAACZ,SAAS,GAAGa,CAAC,CAACb,SAAS;IACpC;IACA,OAAOY,CAAC,CAACb,aAAa,GAAGc,CAAC,CAACd,aAAa;EAC5C;EACA;AACJ;AACA;EACI,OAAO0D,kBAAkBA,CAACvD,KAAK,EAAE;IAC7B,OAAOA,KAAK,CAACH,aAAa,GAAGG,KAAK,CAACL,eAAe;EACtD;EACA6D,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI;EACf;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}