{"ast":null,"code":"import \"core-js/modules/es.array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n  compare(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return 0;\n    }\n    return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n  isEqual(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return true;\n    }\n    if (!uri1 || !uri2) {\n      return false;\n    }\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n  getComparisonKey(uri, ignoreFragment = false) {\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  }\n  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n    if (base.scheme === parentCandidate.scheme) {\n      if (base.scheme === Schemas.file) {\n        return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n      if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n        return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n    }\n    return false;\n  }\n  // --- path math\n  joinPath(resource, ...pathFragment) {\n    return URI.joinPath(resource, ...pathFragment);\n  }\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n  basename(resource) {\n    return paths.posix.basename(resource.path);\n  }\n  extname(resource) {\n    return paths.posix.extname(resource.path);\n  }\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n    let dirname;\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n    } else {\n      dirname = paths.posix.dirname(resource.path);\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n        console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n      }\n    }\n    return resource.with({\n      path: dirname\n    });\n  }\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n    let normalizedPath;\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = paths.posix.normalize(resource.path);\n    }\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n  relativePath(from, to) {\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n      return undefined;\n    }\n    if (from.scheme === Schemas.file) {\n      const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n      return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n    }\n    let fromPath = from.path || '/';\n    const toPath = to.path || '/';\n    if (this._ignorePathCasing(from)) {\n      // make casing of fromPath match toPath\n      let i = 0;\n      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n            break;\n          }\n        }\n      }\n      fromPath = toPath.substr(0, i) + fromPath.substr(i);\n    }\n    return paths.posix.relative(fromPath, toPath);\n  }\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n    path = extpath.toPosixPath(path); // we allow path to be a windows path\n    return base.with({\n      path: paths.posix.resolve(base.path, path)\n    });\n  }\n  // --- misc\n  isAbsolutePath(resource) {\n    return !!resource.path && resource.path[0] === '/';\n  }\n  isEqualAuthority(a1, a2) {\n    return a1 === a2 || a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2);\n  }\n  hasTrailingPathSeparator(resource, sep = paths.sep) {\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      const p = resource.path;\n      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */ && !/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath); // ignore the slash at offset 0\n    }\n  }\n  removeTrailingPathSeparator(resource, sep = paths.sep) {\n    // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n    if (hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path.substr(0, resource.path.length - 1)\n      });\n    }\n    return resource;\n  }\n  addTrailingPathSeparator(resource, sep = paths.sep) {\n    let isRootSep = false;\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      isRootSep = fsp !== undefined && fsp.length === extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      sep = '/';\n      const p = resource.path;\n      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n    }\n    if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path + '/'\n      });\n    }\n    return resource;\n  }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n  function parseMetaData(dataUri) {\n    const metadata = new Map();\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    });\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n    return metadata;\n  }\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"names":["extpath","Schemas","paths","isLinux","isWindows","compare","strCompare","equalsIgnoreCase","URI","uriToFsPath","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","with","path","toLowerCase","undefined","fragment","toString","isEqualOrParent","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","pathFragment","basenameOrAuthority","basename","posix","extname","dirname","length","charCodeAt","console","error","normalizePath","normalizedPath","normalize","relativePath","from","to","relative","toSlashes","fromPath","toPath","i","len","Math","min","charAt","substr","resolvePath","newURI","resolve","toPosixPath","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep","fsp","getRoot","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","_","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/';\n        const toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            // make casing of fromPath match toPath\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return paths.posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    // --- misc\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep = paths.sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n        }\n        else {\n            const p = resource.path;\n            return (p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n        }\n    }\n    removeTrailingPathSeparator(resource, sep = paths.sep) {\n        // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n        if (hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep = paths.sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n        }\n        else {\n            sep = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}