{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/browser/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n    this._languageConfigurationService = _languageConfigurationService;\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n  getEditOperations(model, builder) {\n    const modelLineCount = model.getLineCount();\n    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    this._moveEndPositionDown = false;\n    let s = this._selection;\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n    const virtualModel = {\n      tokenization: {\n        getLineTokens: lineNumber => {\n          return model.tokenization.getLineTokens(lineNumber);\n        },\n        getLanguageId: () => {\n          return model.getLanguageId();\n        },\n        getLanguageIdAtPosition: (lineNumber, column) => {\n          return model.getLanguageIdAtPosition(lineNumber, column);\n        }\n      },\n      getLineContent: null\n    };\n    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n      // Current line is empty\n      const lineNumber = s.startLineNumber;\n      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n      if (model.getLineMaxColumn(otherLineNumber) === 1) {\n        // Other line number is empty too, so no editing is needed\n        // Add a no-op to force running by the model\n        builder.addEditOperation(new Range(1, 1, 1, 1), null);\n      } else {\n        // Type content from other line number on line number\n        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n        // Remove content from other line number\n        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n      }\n      // Track selection at the other line number\n      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n    } else {\n      let movingLineNumber;\n      let movingLineText;\n      if (this._isMovingDown) {\n        movingLineNumber = s.endLineNumber + 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n        let insertingText = movingLineText;\n        if (this.shouldAutoIndent(model, s)) {\n          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n          // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n          if (movingLineMatchResult !== null) {\n            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n            const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n            const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n            insertingText = newIndentation + this.trimStart(movingLineText);\n          } else {\n            // no enter rule matches, let's check indentatin rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return model.getLineContent(movingLineNumber);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n            if (indentOfMovingLine !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                insertingText = newIndentation + this.trimStart(movingLineText);\n              }\n            }\n          }\n          // add edit operations for moving line first to make sure it's executed after we make indentation change\n          // to s.startLineNumber\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n          // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match onEnter rules, let's check indentation rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return insertingText;\n              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                return model.getLineContent(lineNumber - 1);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n            if (newIndentatOfMovingBlock !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        } else {\n          // Insert line that needs to be moved before\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n        }\n      } else {\n        movingLineNumber = s.startLineNumber - 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n        // Insert line that needs to be moved after\n        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n        if (this.shouldAutoIndent(model, s)) {\n          virtualModel.getLineContent = lineNumber => {\n            if (lineNumber === movingLineNumber) {\n              return model.getLineContent(s.startLineNumber);\n            } else {\n              return model.getLineContent(lineNumber);\n            }\n          };\n          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n          // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match any onEnter rule, let's check indentation rules then.\n            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n            if (indentOfFirstLine !== null) {\n              // adjust the indentation of the moving block\n              const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  }\n  buildIndentConverter(tabSize, indentSize, insertSpaces) {\n    return {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n  }\n  parseEnterResult(model, indentConverter, tabSize, line, enter) {\n    if (enter) {\n      let enterPrefix = enter.indentation;\n      if (enter.indentAction === IndentAction.None) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.Indent) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.IndentOutdent) {\n        enterPrefix = enter.indentation;\n      } else if (enter.indentAction === IndentAction.Outdent) {\n        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n      }\n      const movingLineText = model.getLineContent(line);\n      if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n        let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n          newIndentation = indentConverter.unshiftIndent(newIndentation);\n        }\n        const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n        const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        return newSpaceCnt - oldSpaceCnt;\n      }\n    }\n    return null;\n  }\n  /**\n   *\n   * @param model\n   * @param indentConverter\n   * @param tabSize\n   * @param line the line moving down\n   * @param futureAboveLineNumber the line which will be at the `line` position\n   * @param futureAboveLineText\n   */\n  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n    if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n      // break\n      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n      const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    } else {\n      // go upwards, starting from `line - 1`\n      let validPrecedingLine = line - 1;\n      while (validPrecedingLine >= 1) {\n        const lineContent = model.getLineContent(validPrecedingLine);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n        validPrecedingLine--;\n      }\n      if (validPrecedingLine < 1 || line > model.getLineCount()) {\n        return null;\n      }\n      const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n      const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n  }\n  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n    let validPrecedingLine = oneLineAbove;\n    while (validPrecedingLine >= 1) {\n      // ship empty lines as empty lines just inherit indentation\n      let lineContent;\n      if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n        lineContent = previousLineText;\n      } else {\n        lineContent = model.getLineContent(validPrecedingLine);\n      }\n      const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n      if (nonWhitespaceIdx >= 0) {\n        break;\n      }\n      validPrecedingLine--;\n    }\n    if (validPrecedingLine < 1 || line > model.getLineCount()) {\n      return null;\n    }\n    const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n    const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n  }\n  trimStart(str) {\n    return str.replace(/^\\s+/, '');\n  }\n  shouldAutoIndent(model, selection) {\n    if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n      return false;\n    }\n    // if it's not easy to tokenize, we stop auto indent.\n    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n      return false;\n    }\n    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n    if (languageAtSelectionStart !== languageAtSelectionEnd) {\n      return false;\n    }\n    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n      return false;\n    }\n    return true;\n  }\n  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n      const lineContent = model.getLineContent(i);\n      const originalIndent = strings.getLeadingWhitespace(lineContent);\n      const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n      const newSpacesCnt = originalSpacesCnt + offset;\n      const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n      if (newIndent !== originalIndent) {\n        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n          // as users select part of the original indent white spaces\n          // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n          this._moveEndLineSelectionShrink = true;\n        }\n      }\n    }\n  }\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n      result = result.setEndPosition(result.endLineNumber, 2);\n    }\n    return result;\n  }\n};\nMoveLinesCommand = __decorate([__param(3, ILanguageConfigurationService)], MoveLinesCommand);\nexport { MoveLinesCommand };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","strings","ShiftCommand","Range","Selection","IndentAction","ILanguageConfigurationService","indentUtils","getGoodIndentForLine","getIndentMetadata","getEnterAction","MoveLinesCommand","constructor","selection","isMovingDown","autoIndent","_languageConfigurationService","_selection","_isMovingDown","_autoIndent","_selectionId","_moveEndLineSelectionShrink","getEditOperations","model","builder","modelLineCount","getLineCount","endLineNumber","trackSelection","startLineNumber","_moveEndPositionDown","s","endColumn","setEndPosition","getLineMaxColumn","tabSize","indentSize","insertSpaces","getOptions","indentConverter","buildIndentConverter","virtualModel","tokenization","getLineTokens","lineNumber","getLanguageId","getLanguageIdAtPosition","column","getLineContent","otherLineNumber","addEditOperation","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","oldIndentation","getLeadingWhitespace","newSpaceCnt","getSpaceCnt","newIndentation","generateIndent","trimStart","indentOfMovingLine","oldSpaceCnt","ret","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","spaceCntOffset","indentOfFirstLine","oldIndent","shiftIndent","indentation","unshiftIndent","parseEnterResult","line","enter","enterPrefix","indentAction","None","appendText","Indent","IndentOutdent","Outdent","indexOf","indentMetadataOfMovelingLine","futureAboveLineNumber","futureAboveLineText","lastNonWhitespaceIndex","maxColumn","validPrecedingLine","lineContent","nonWhitespaceIdx","oneLineAbove","previousLineText","undefined","str","replace","isCheapToTokenize","languageAtSelectionStart","languageAtSelectionEnd","getLanguageConfiguration","indentRulesSupport","offset","originalIndent","originalSpacesCnt","newSpacesCnt","newIndent","computeCursorState","helper","result","getTrackedSelection"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/browser/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        const modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        const virtualModel = {\n            tokenization: {\n                getLineTokens: (lineNumber) => {\n                    return model.tokenization.getLineTokens(lineNumber);\n                },\n                getLanguageId: () => {\n                    return model.getLanguageId();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n            },\n            getLineContent: null,\n        };\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            const lineNumber = s.startLineNumber;\n            const otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimStart(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return model.getLineContent(movingLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfMovingLine !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimStart(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return insertingText;\n                            }\n                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                return model.getLineContent(lineNumber - 1);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    virtualModel.getLineContent = (lineNumber) => {\n                        if (lineNumber === movingLineNumber) {\n                            return model.getLineContent(s.startLineNumber);\n                        }\n                        else {\n                            return model.getLineContent(lineNumber);\n                        }\n                    };\n                    const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            const movingLineText = model.getLineContent(line);\n            if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                const lineContent = model.getLineContent(validPrecedingLine);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimStart(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            const lineContent = model.getLineContent(i);\n            const originalIndent = strings.getLeadingWhitespace(lineContent);\n            const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            const newSpacesCnt = originalSpacesCnt + offset;\n            const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n};\nMoveLinesCommand = __decorate([\n    __param(3, ILanguageConfigurationService)\n], MoveLinesCommand);\nexport { MoveLinesCommand };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}