{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n  if (!_utf16LE_TextDecoder) {\n    _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n  }\n  return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n  if (!_utf16BE_TextDecoder) {\n    _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n  }\n  return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n  if (!_platformTextDecoder) {\n    _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n  }\n  return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n  const view = new Uint16Array(source.buffer, offset, len);\n  if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n    // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n    // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n    // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n    // So we use the manual decoder\n    return compatDecodeUTF16LE(source, offset, len);\n  }\n  return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n  const result = [];\n  let resultLen = 0;\n  for (let i = 0; i < len; i++) {\n    const charCode = buffer.readUInt16LE(source, offset);\n    offset += 2;\n    result[resultLen++] = String.fromCharCode(charCode);\n  }\n  return result.join('');\n}\nexport class StringBuilder {\n  constructor(capacity) {\n    this._capacity = capacity | 0;\n    this._buffer = new Uint16Array(this._capacity);\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n  reset() {\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n  build() {\n    if (this._completedStrings !== null) {\n      this._flushBuffer();\n      return this._completedStrings.join('');\n    }\n    return this._buildBuffer();\n  }\n  _buildBuffer() {\n    if (this._bufferLength === 0) {\n      return '';\n    }\n    const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n    return getPlatformTextDecoder().decode(view);\n  }\n  _flushBuffer() {\n    const bufferString = this._buildBuffer();\n    this._bufferLength = 0;\n    if (this._completedStrings === null) {\n      this._completedStrings = [bufferString];\n    } else {\n      this._completedStrings[this._completedStrings.length] = bufferString;\n    }\n  }\n  /**\n   * Append a char code (<2^16)\n   */\n  appendCharCode(charCode) {\n    const remainingSpace = this._capacity - this._bufferLength;\n    if (remainingSpace <= 1) {\n      if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n        this._flushBuffer();\n      }\n    }\n    this._buffer[this._bufferLength++] = charCode;\n  }\n  /**\n   * Append an ASCII char code (<2^8)\n   */\n  appendASCIICharCode(charCode) {\n    if (this._bufferLength === this._capacity) {\n      // buffer is full\n      this._flushBuffer();\n    }\n    this._buffer[this._bufferLength++] = charCode;\n  }\n  appendString(str) {\n    const strLen = str.length;\n    if (this._bufferLength + strLen >= this._capacity) {\n      // This string does not fit in the remaining buffer space\n      this._flushBuffer();\n      this._completedStrings[this._completedStrings.length] = str;\n      return;\n    }\n    for (let i = 0; i < strLen; i++) {\n      this._buffer[this._bufferLength++] = str.charCodeAt(i);\n    }\n  }\n}","map":{"version":3,"names":["strings","platform","buffer","_utf16LE_TextDecoder","getUTF16LE_TextDecoder","TextDecoder","_utf16BE_TextDecoder","getUTF16BE_TextDecoder","_platformTextDecoder","getPlatformTextDecoder","isLittleEndian","decodeUTF16LE","source","offset","len","view","Uint16Array","compatDecodeUTF16LE","decode","result","resultLen","i","charCode","readUInt16LE","String","fromCharCode","join","StringBuilder","constructor","capacity","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","length","appendCharCode","remainingSpace","isHighSurrogate","appendASCIICharCode","appendString","str","strLen","charCodeAt"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}