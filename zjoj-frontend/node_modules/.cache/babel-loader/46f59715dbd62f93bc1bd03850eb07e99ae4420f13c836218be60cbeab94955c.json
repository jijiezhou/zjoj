{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel {\n  get uri() {\n    return this._uri;\n  }\n  get eol() {\n    return this._eol;\n  }\n  getValue() {\n    return this.getText();\n  }\n  findMatches(regex) {\n    const matches = [];\n    for (let i = 0; i < this._lines.length; i++) {\n      const line = this._lines[i];\n      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n      const iteratorOverMatches = line.matchAll(regex);\n      for (const match of iteratorOverMatches) {\n        if (match.index || match.index === 0) {\n          match.index = match.index + offsetToAdd;\n        }\n        matches.push(match);\n      }\n    }\n    return matches;\n  }\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n  getLineCount() {\n    return this._lines.length;\n  }\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n  getWordAtPosition(position, wordDefinition) {\n    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n    return null;\n  }\n  words(wordDefinition) {\n    const lines = this._lines;\n    const wordenize = this._wordenize.bind(this);\n    let lineNumber = 0;\n    let lineText = '';\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx < wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber < lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n  }\n  getLineWords(lineNumber, wordDefinition) {\n    const content = this._lines[lineNumber - 1];\n    const ranges = this._wordenize(content, wordDefinition);\n    const words = [];\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n    return words;\n  }\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        // it did match the empty string\n        break;\n      }\n      result.push({\n        start: match.index,\n        end: match.index + match[0].length\n      });\n    }\n    return result;\n  }\n  getValueInRange(range) {\n    range = this._validateRange(range);\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    const lineEnding = this._eol;\n    const startLineIndex = range.startLineNumber - 1;\n    const endLineIndex = range.endLineNumber - 1;\n    const resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n    for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n  offsetAt(position) {\n    position = this._validatePosition(position);\n    this._ensureLineStarts();\n    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n  }\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    this._ensureLineStarts();\n    const out = this._lineStarts.getIndexOf(offset);\n    const lineLength = this._lines[out.index].length;\n    // Ensure we return a valid position\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n  _validateRange(range) {\n    const start = this._validatePosition({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const end = this._validatePosition({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n    return range;\n  }\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error('bad position');\n    }\n    let {\n      lineNumber,\n      column\n    } = position;\n    let hasChanged = false;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber > this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      const maxCharacter = this._lines[lineNumber - 1].length + 1;\n      if (column < 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column > maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n    if (!hasChanged) {\n      return position;\n    } else {\n      return {\n        lineNumber,\n        column\n      };\n    }\n  }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n  constructor(host, foreignModuleFactory) {\n    this._host = host;\n    this._models = Object.create(null);\n    this._foreignModuleFactory = foreignModuleFactory;\n    this._foreignModule = null;\n  }\n  dispose() {\n    this._models = Object.create(null);\n  }\n  _getModel(uri) {\n    return this._models[uri];\n  }\n  _getModels() {\n    const all = [];\n    Object.keys(this._models).forEach(key => all.push(this._models[key]));\n    return all;\n  }\n  acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n  acceptModelChanged(strURL, e) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    const model = this._models[strURL];\n    model.onEvents(e);\n  }\n  acceptRemovedModel(strURL) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    delete this._models[strURL];\n  }\n  async computeUnicodeHighlights(url, options, range) {\n    const model = this._getModel(url);\n    if (!model) {\n      return {\n        ranges: [],\n        hasMore: false,\n        ambiguousCharacterCount: 0,\n        invisibleCharacterCount: 0,\n        nonBasicAsciiCharacterCount: 0\n      };\n    }\n    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n  }\n  // ---- BEGIN diff --------------------------------------------------------------------------\n  async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n    const original = this._getModel(originalUrl);\n    const modified = this._getModel(modifiedUrl);\n    if (!original || !modified) {\n      return null;\n    }\n    return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n  }\n  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n    const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n    const originalLines = originalTextModel.getLinesContent();\n    const modifiedLines = modifiedTextModel.getLinesContent();\n    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n    const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);\n    function getLineChanges(changes) {\n      return changes.map(m => {\n        var _a;\n        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [m.originalRange.startLineNumber, m.originalRange.startColumn, m.originalRange.endLineNumber, m.originalRange.endColumn, m.modifiedRange.startLineNumber, m.modifiedRange.startColumn, m.modifiedRange.endLineNumber, m.modifiedRange.endColumn])];\n      });\n    }\n    return {\n      identical,\n      quitEarly: result.hitTimeout,\n      changes: getLineChanges(result.changes),\n      moves: result.moves.map(m => [m.lineRangeMapping.original.startLineNumber, m.lineRangeMapping.original.endLineNumberExclusive, m.lineRangeMapping.modified.startLineNumber, m.lineRangeMapping.modified.endLineNumberExclusive, getLineChanges(m.changes)])\n    };\n  }\n  static _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n    for (let line = 1; line <= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n    return true;\n  }\n  async computeMoreMinimalEdits(modelUrl, edits, pretty) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return edits;\n    }\n    const result = [];\n    let lastEol = undefined;\n    edits = edits.slice(0).sort((a, b) => {\n      if (a.range && b.range) {\n        return Range.compareRangesUsingStarts(a.range, b.range);\n      }\n      // eol only changes should go to the end\n      const aRng = a.range ? 0 : 1;\n      const bRng = b.range ? 0 : 1;\n      return aRng - bRng;\n    });\n    // merge adjacent edits\n    let writeIndex = 0;\n    for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n      if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n        edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n        edits[writeIndex].text += edits[readIndex].text;\n      } else {\n        writeIndex++;\n        edits[writeIndex] = edits[readIndex];\n      }\n    }\n    edits.length = writeIndex + 1;\n    for (let {\n      range,\n      text,\n      eol\n    } of edits) {\n      if (typeof eol === 'number') {\n        lastEol = eol;\n      }\n      if (Range.isEmpty(range) && !text) {\n        // empty change\n        continue;\n      }\n      const original = model.getValueInRange(range);\n      text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n      if (original === text) {\n        // noop\n        continue;\n      }\n      // make sure diff won't take too long\n      if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n        result.push({\n          range,\n          text\n        });\n        continue;\n      }\n      // compute diff between original and edit.text\n      const changes = stringDiff(original, text, pretty);\n      const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n      for (const change of changes) {\n        const start = model.positionAt(editOffset + change.originalStart);\n        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n        const newEdit = {\n          text: text.substr(change.modifiedStart, change.modifiedLength),\n          range: {\n            startLineNumber: start.lineNumber,\n            startColumn: start.column,\n            endLineNumber: end.lineNumber,\n            endColumn: end.column\n          }\n        };\n        if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n          result.push(newEdit);\n        }\n      }\n    }\n    if (typeof lastEol === 'number') {\n      result.push({\n        eol: lastEol,\n        text: '',\n        range: {\n          startLineNumber: 0,\n          startColumn: 0,\n          endLineNumber: 0,\n          endColumn: 0\n        }\n      });\n    }\n    return result;\n  }\n  // ---- END minimal edits ---------------------------------------------------------------\n  async computeLinks(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeLinks(model);\n  }\n  // --- BEGIN default document colors -----------------------------------------------------------\n  async computeDefaultDocumentColors(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeDefaultDocumentColors(model);\n  }\n  async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    const sw = new StopWatch();\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const seen = new Set();\n    outer: for (const url of modelUrls) {\n      const model = this._getModel(url);\n      if (!model) {\n        continue;\n      }\n      for (const word of model.words(wordDefRegExp)) {\n        if (word === leadingWord || !isNaN(Number(word))) {\n          continue;\n        }\n        seen.add(word);\n        if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n          break outer;\n        }\n      }\n    }\n    return {\n      words: Array.from(seen),\n      duration: sw.elapsed()\n    };\n  }\n  // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n  async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return Object.create(null);\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const result = Object.create(null);\n    for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n      const words = model.getLineWords(line, wordDefRegExp);\n      for (const word of words) {\n        if (!isNaN(Number(word.word))) {\n          continue;\n        }\n        let array = result[word.word];\n        if (!array) {\n          array = [];\n          result[word.word] = array;\n        }\n        array.push({\n          startLineNumber: line,\n          startColumn: word.startColumn,\n          endLineNumber: line,\n          endColumn: word.endColumn\n        });\n      }\n    }\n    return result;\n  }\n  //#endregion\n  async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    if (range.startColumn === range.endColumn) {\n      range = {\n        startLineNumber: range.startLineNumber,\n        startColumn: range.startColumn,\n        endLineNumber: range.endLineNumber,\n        endColumn: range.endColumn + 1\n      };\n    }\n    const selectionText = model.getValueInRange(range);\n    const wordRange = model.getWordAtPosition({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    }, wordDefRegExp);\n    if (!wordRange) {\n      return null;\n    }\n    const word = model.getValueInRange(wordRange);\n    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n    return result;\n  }\n  // ---- BEGIN foreign module support --------------------------------------------------------------------------\n  loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) => {\n      return this._host.fhr(method, args);\n    };\n    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n    const ctx = {\n      host: foreignHost,\n      getMirrorModels: () => {\n        return this._getModels();\n      }\n    };\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData);\n      // static foreing module\n      return Promise.resolve(getAllMethodNames(this._foreignModule));\n    }\n    // ESM-comment-begin\n    // \t\treturn new Promise<any>((resolve, reject) => {\n    // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n    // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n    // \n    // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n    // \n    // \t\t\t}, reject);\n    // \t\t});\n    // ESM-comment-end\n    // ESM-uncomment-begin\n    return Promise.reject(new Error(`Unexpected usage`));\n    // ESM-uncomment-end\n  }\n  // foreign method request\n  fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n      return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n    }\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n  return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n  // Running in a web worker\n  globalThis.monaco = createMonacoBaseAPI();\n}","map":{"version":3,"names":["stringDiff","URI","Position","Range","MirrorTextModel","BaseMirrorModel","ensureValidWordDefinition","getWordAtText","computeLinks","BasicInplaceReplace","createMonacoBaseAPI","StopWatch","UnicodeTextModelHighlighter","linesDiffComputers","createProxyObject","getAllMethodNames","computeDefaultDocumentColors","MirrorModel","uri","_uri","eol","_eol","getValue","getText","findMatches","regex","matches","i","_lines","length","line","offsetToAdd","offsetAt","iteratorOverMatches","matchAll","match","index","push","getLinesContent","slice","getLineCount","getLineContent","lineNumber","getWordAtPosition","position","wordDefinition","wordAtText","column","startColumn","endColumn","words","lines","wordenize","_wordenize","bind","lineText","wordRangesIdx","wordRanges","Symbol","iterator","value","substring","start","end","getLineWords","content","ranges","range","word","result","lastIndex","exec","getValueInRange","_validateRange","startLineNumber","endLineNumber","lineEnding","startLineIndex","endLineIndex","resultLines","join","_validatePosition","_ensureLineStarts","_lineStarts","getPrefixSum","positionAt","offset","Math","floor","max","out","getIndexOf","lineLength","min","remainder","isIPosition","Error","hasChanged","maxCharacter","EditorSimpleWorker","constructor","host","foreignModuleFactory","_host","_models","Object","create","_foreignModuleFactory","_foreignModule","dispose","_getModel","_getModels","all","keys","forEach","key","acceptNewModel","data","url","parse","EOL","versionId","acceptModelChanged","strURL","e","model","onEvents","acceptRemovedModel","computeUnicodeHighlights","options","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","computeDiff","originalUrl","modifiedUrl","algorithm","original","modified","originalTextModel","modifiedTextModel","diffAlgorithm","getDefault","getLegacy","originalLines","modifiedLines","identical","changes","_modelsAreIdentical","getLineChanges","map","m","_a","endLineNumberExclusive","innerChanges","originalRange","modifiedRange","quitEarly","hitTimeout","moves","lineRangeMapping","originalLineCount","modifiedLineCount","originalLine","modifiedLine","computeMoreMinimalEdits","modelUrl","edits","pretty","lastEol","undefined","sort","a","b","compareRangesUsingStarts","aRng","bRng","writeIndex","readIndex","getEndPosition","equals","getStartPosition","fromPositions","text","isEmpty","replace","_diffLimit","editOffset","lift","change","originalStart","originalLength","newEdit","substr","modifiedStart","modifiedLength","textualSuggest","modelUrls","leadingWord","wordDef","wordDefFlags","sw","wordDefRegExp","RegExp","seen","Set","outer","isNaN","Number","add","size","_suggestionsLimit","Array","from","duration","elapsed","computeWordRanges","array","navigateValueSet","up","selectionText","wordRange","INSTANCE","loadForeignModule","moduleId","createData","foreignHostMethods","proxyMethodRequest","method","args","fhr","foreignHost","ctx","getMirrorModels","Promise","resolve","reject","fmr","apply","importScripts","globalThis","monaco"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    findMatches(regex) {\n        const matches = [];\n        for (let i = 0; i < this._lines.length; i++) {\n            const line = this._lines[i];\n            const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n            const iteratorOverMatches = line.matchAll(regex);\n            for (const match of iteratorOverMatches) {\n                if (match.index || match.index === 0) {\n                    match.index = match.index + offsetToAdd;\n                }\n                matches.push(match);\n            }\n        }\n        return matches;\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        const all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        const model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    async computeUnicodeHighlights(url, options, range) {\n        const model = this._getModel(url);\n        if (!model) {\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n        }\n        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return changes.map(m => {\n                var _a;\n                return ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [\n                        m.originalRange.startLineNumber,\n                        m.originalRange.startColumn,\n                        m.originalRange.endLineNumber,\n                        m.originalRange.endColumn,\n                        m.modifiedRange.startLineNumber,\n                        m.modifiedRange.startColumn,\n                        m.modifiedRange.endLineNumber,\n                        m.modifiedRange.endColumn,\n                    ])]);\n            });\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ])),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            // eol only changes should go to the end\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        // merge adjacent edits\n        let writeIndex = 0;\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n            if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n                edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n                edits[writeIndex].text += edits[readIndex].text;\n            }\n            else {\n                writeIndex++;\n                edits[writeIndex] = edits[readIndex];\n            }\n        }\n        edits.length = writeIndex + 1;\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (Range.isEmpty(range) && !text) {\n                // empty change\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                // noop\n                continue;\n            }\n            // make sure diff won't take too long\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            // compute diff between original and edit.text\n            const changes = stringDiff(original, text, pretty);\n            const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n            for (const change of changes) {\n                const start = model.positionAt(editOffset + change.originalStart);\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                const newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    async computeLinks(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeLinks(model);\n    }\n    // --- BEGIN default document colors -----------------------------------------------------------\n    async computeDefaultDocumentColors(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeDefaultDocumentColors(model);\n    }\n    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        const sw = new StopWatch();\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const seen = new Set();\n        outer: for (const url of modelUrls) {\n            const model = this._getModel(url);\n            if (!model) {\n                continue;\n            }\n            for (const word of model.words(wordDefRegExp)) {\n                if (word === leadingWord || !isNaN(Number(word))) {\n                    continue;\n                }\n                seen.add(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break outer;\n                }\n            }\n        }\n        return { words: Array.from(seen), duration: sw.elapsed() };\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return Object.create(null);\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const result = Object.create(null);\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n            const words = model.getLineWords(line, wordDefRegExp);\n            for (const word of words) {\n                if (!isNaN(Number(word.word))) {\n                    continue;\n                }\n                let array = result[word.word];\n                if (!array) {\n                    array = [];\n                    result[word.word] = array;\n                }\n                array.push({\n                    startLineNumber: line,\n                    startColumn: word.startColumn,\n                    endLineNumber: line,\n                    endColumn: word.endColumn\n                });\n            }\n        }\n        return result;\n    }\n    //#endregion\n    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        const selectionText = model.getValueInRange(range);\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        if (!wordRange) {\n            return null;\n        }\n        const word = model.getValueInRange(wordRange);\n        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return result;\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globalThis.monaco = createMonacoBaseAPI();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}