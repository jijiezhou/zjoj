{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n  static indent(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: false,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      }, config.languageConfigurationService);\n    }\n    return commands;\n  }\n  static outdent(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: true,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      }, config.languageConfigurationService);\n    }\n    return commands;\n  }\n  static shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n  static unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n  static _distributedPaste(config, model, selections, text) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      if (pasteOnNewLine && !selection.isEmpty()) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n    if (selections.length === 1) {\n      return null;\n    }\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    }\n    if (config.multiCursorPaste === 'spread') {\n      // Try to spread the pasted text in case the line count matches the cursor count\n      // Remove trailing \\n if present\n      if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n        text = text.substr(0, text.length - 1);\n      }\n      // Remove trailing \\r if present\n      if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n        text = text.substr(0, text.length - 1);\n      }\n      const lines = strings.splitLines(text);\n      if (lines.length === selections.length) {\n        return lines;\n      }\n    }\n    return null;\n  }\n  static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  }\n  static _goodIndentForLine(config, model, lineNumber) {\n    let action = null;\n    let indentation = '';\n    const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      let lastLineNumber;\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        const lineText = model.getLineContent(lastLineNumber);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n      const maxColumn = model.getLineMaxColumn(lastLineNumber);\n      const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n      }\n    }\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = TypeOperations.shiftIndent(config, indentation);\n      }\n      if (action === IndentAction.Outdent) {\n        indentation = TypeOperations.unshiftIndent(config, indentation);\n      }\n      indentation = config.normalizeIndentation(indentation);\n    }\n    if (!indentation) {\n      return null;\n    }\n    return indentation;\n  }\n  static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n    let typeText = '';\n    const position = selection.getStartPosition();\n    if (config.insertSpaces) {\n      const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n      const indentSize = config.indentSize;\n      const spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n      for (let i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  }\n  static tab(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (selection.isEmpty()) {\n        const lineText = model.getLineContent(selection.startLineNumber);\n        if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n          let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n          goodIndent = goodIndent || '\\t';\n          const possibleTypeText = config.normalizeIndentation(goodIndent);\n          if (!lineText.startsWith(possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        }, config.languageConfigurationService);\n      }\n    }\n    return commands;\n  }\n  static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    if (!selection.isEmpty()) {\n      // looks like https://github.com/microsoft/vscode/issues/2773\n      // where a cursor operation occurred before a canceled composition\n      // => ignore composition\n      return null;\n    }\n    const pos = selection.getPosition();\n    const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n    const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n    const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n    const oldText = model.getValueInRange(range);\n    if (oldText === text && positionDelta === 0) {\n      // => ignore composition that doesn't do anything\n      return null;\n    }\n    return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n  }\n  static _typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n      return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    } else {\n      return new ReplaceCommand(range, text, true);\n    }\n  }\n  static _enter(config, model, keepPosition, range) {\n    if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n      return TypeOperations._typeCommand(range, '\\n', keepPosition);\n    }\n    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n      const lineText = model.getLineContent(range.startLineNumber);\n      const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n    if (r) {\n      if (r.indentAction === IndentAction.None) {\n        // Nothing special\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.Indent) {\n        // Indent once\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        const normalIndent = config.normalizeIndentation(r.indentation);\n        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n        const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (r.indentAction === IndentAction.Outdent) {\n        const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n      }\n    }\n    const lineText = model.getLineContent(range.startLineNumber);\n    const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n    if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n      const ir = getIndentForEnter(config.autoIndent, model, range, {\n        unshiftIndent: indent => {\n          return TypeOperations.unshiftIndent(config, indent);\n        },\n        shiftIndent: indent => {\n          return TypeOperations.shiftIndent(config, indent);\n        },\n        normalizeIndentation: indent => {\n          return config.normalizeIndentation(indent);\n        }\n      }, config.languageConfigurationService);\n      if (ir) {\n        let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n        const oldEndColumn = range.endColumn;\n        const newLineContent = model.getLineContent(range.endLineNumber);\n        const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n        if (firstNonWhitespace >= 0) {\n          range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n        } else {\n          range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n        }\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n        } else {\n          let offset = 0;\n          if (oldEndColumn <= firstNonWhitespace + 1) {\n            if (!config.insertSpaces) {\n              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n            }\n            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n          }\n          return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n        }\n      }\n    }\n    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n  }\n  static _isAutoIndentType(config, model, selections) {\n    if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _runAutoIndentType(config, model, range, ch) {\n    const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n      shiftIndent: indentation => {\n        return TypeOperations.shiftIndent(config, indentation);\n      },\n      unshiftIndent: indentation => {\n        return TypeOperations.unshiftIndent(config, indentation);\n      }\n    }, config.languageConfigurationService);\n    if (actualIndentation === null) {\n      return null;\n    }\n    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n      const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n      if (firstNonWhitespace === 0) {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n      } else {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n      }\n    }\n    return null;\n  }\n  static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n      return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (!selection.isEmpty()) {\n        return false;\n      }\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const afterCharacter = lineText.charAt(position.column - 1);\n      if (afterCharacter !== ch) {\n        return false;\n      }\n      // Do not over-type quotes after a backslash\n      const chIsQuote = isQuote(ch);\n      const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n      if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n        return false;\n      }\n      // Must over-type a closing character typed by the editor\n      if (config.autoClosingOvertype === 'auto') {\n        let found = false;\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _isBeforeClosingBrace(config, lineAfter) {\n    // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n    const nextChar = lineAfter.charAt(0);\n    const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n    const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n    const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n    const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n    return !isBeforeStartingBrace && isBeforeClosingBrace;\n  }\n  /**\n   * Determine if typing `ch` at all `positions` in the `model` results in an\n   * auto closing open sequence being typed.\n   *\n   * Auto closing open sequences can consist of multiple characters, which\n   * can lead to ambiguities. In such a case, the longest auto-closing open\n   * sequence is returned.\n   */\n  static _findAutoClosingPairOpen(config, model, positions, ch) {\n    const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n    if (!candidates) {\n      return null;\n    }\n    // Determine which auto-closing pair it is\n    let result = null;\n    for (const candidate of candidates) {\n      if (result === null || candidate.open.length > result.open.length) {\n        let candidateIsMatch = true;\n        for (const position of positions) {\n          const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n          if (relevantText + ch !== candidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n        if (candidateIsMatch) {\n          result = candidate;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Find another auto-closing pair that is contained by the one passed in.\n   *\n   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n   * this method will find [(,)] as a containment pair for [(*,*)]\n   */\n  static _findContainedAutoClosingPair(config, pair) {\n    if (pair.open.length <= 1) {\n      return null;\n    }\n    const lastChar = pair.close.charAt(pair.close.length - 1);\n    // get candidates with the same last character as close\n    const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n    let result = null;\n    for (const candidate of candidates) {\n      if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n        if (!result || candidate.open.length > result.open.length) {\n          result = candidate;\n        }\n      }\n    }\n    return result;\n  }\n  static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n    }\n    // This method is called both when typing (regularly) and when composition ends\n    // This means that we need to work with a text buffer where sometimes `ch` is not\n    // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n    //\n    // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n    // with two conceptual positions, the position before `ch` and the position after `ch`\n    //\n    const positions = selections.map(s => {\n      const position = s.getPosition();\n      if (chIsAlreadyTyped) {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column - ch.length,\n          afterColumn: position.column\n        };\n      } else {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column,\n          afterColumn: position.column\n        };\n      }\n    });\n    // Find the longest auto-closing open pair in case of multiple ending in `ch`\n    // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n    const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n    if (!pair) {\n      return null;\n    }\n    let autoCloseConfig;\n    let shouldAutoCloseBefore;\n    const chIsQuote = isQuote(ch);\n    if (chIsQuote) {\n      autoCloseConfig = config.autoClosingQuotes;\n      shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n    } else {\n      const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n      if (pairIsForComments) {\n        autoCloseConfig = config.autoClosingComments;\n        shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n      } else {\n        autoCloseConfig = config.autoClosingBrackets;\n        shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n      }\n    }\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n    // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n    // e.g. when having [(,)] and [(*,*)]\n    // - when typing (, the resulting state is (|)\n    // - when typing *, the desired resulting state is (*|*), not (*|*))\n    const containedPair = this._findContainedAutoClosingPair(config, pair);\n    const containedPairClose = containedPair ? containedPair.close : '';\n    let isContainedPairPresent = true;\n    for (const position of positions) {\n      const {\n        lineNumber,\n        beforeColumn,\n        afterColumn\n      } = position;\n      const lineText = model.getLineContent(lineNumber);\n      const lineBefore = lineText.substring(0, beforeColumn - 1);\n      const lineAfter = lineText.substring(afterColumn - 1);\n      if (!lineAfter.startsWith(containedPairClose)) {\n        isContainedPairPresent = false;\n      }\n      // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n      if (lineAfter.length > 0) {\n        const characterAfter = lineAfter.charAt(0);\n        const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      }\n      // Do not auto-close ' or \" after a word character\n      if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        if (lineBefore.length > 0) {\n          const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n          if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n            return null;\n          }\n        }\n      }\n      if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        // Do not force tokenization\n        return null;\n      }\n      model.tokenization.forceTokenization(lineNumber);\n      const lineTokens = model.tokenization.getLineTokens(lineNumber);\n      const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n      if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n        return null;\n      }\n      // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n      // or it could end a previously started string, in which case auto-closing is not desirable\n      //\n      // In certain cases, it is really not possible to look at the previous token to determine\n      // what would happen. That's why we do something really unusual, we pretend to type a different\n      // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n      // character, are we in a string (i.e. the quote would most likely end a string) or not?\n      //\n      const neutralCharacter = pair.findNeutralCharacter();\n      if (neutralCharacter) {\n        const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n        if (!pair.isOK(tokenType)) {\n          return null;\n        }\n      }\n    }\n    if (isContainedPairPresent) {\n      return pair.close.substring(0, pair.close.length - containedPairClose.length);\n    } else {\n      return pair.close;\n    }\n  }\n  static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n    }\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n      return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n    } else {\n      // Character is a bracket\n      return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n    }\n  }\n  static _isSurroundSelectionType(config, model, selections, ch) {\n    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n    const isTypingAQuoteCharacter = isQuote(ch);\n    for (const selection of selections) {\n      if (selection.isEmpty()) {\n        return false;\n      }\n      let selectionContainsOnlyWhitespace = true;\n      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        const selectedText = lineText.substring(startIndex, endIndex);\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        const selectionText = model.getValueInRange(selection);\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _isTypeInterceptorElectricChar(config, model, selections) {\n    if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n    return false;\n  }\n  static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n    const position = selection.getPosition();\n    model.tokenization.forceTokenization(position.lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n    let electricAction;\n    try {\n      electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n    if (!electricAction) {\n      return null;\n    }\n    if (electricAction.matchOpenBracket) {\n      const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      }, 500 /* give at most 500ms to compute */);\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n        const matchLine = model.getLineContent(match.startLineNumber);\n        const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        const newIndentation = config.normalizeIndentation(matchLineIndentation);\n        const lineText = model.getLineContent(position.lineNumber);\n        const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        const typeText = newIndentation + prefix + ch;\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        const command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n    return null;\n  }\n  /**\n   * This is very similar with typing, but the character is already in the text buffer!\n   */\n  static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n    if (!compositions) {\n      // could not deduce what the composition did\n      return null;\n    }\n    let insertedText = null;\n    for (const composition of compositions) {\n      if (insertedText === null) {\n        insertedText = composition.insertedText;\n      } else if (insertedText !== composition.insertedText) {\n        // not all selections agree on what was typed\n        return null;\n      }\n    }\n    if (!insertedText || insertedText.length !== 1) {\n      // we're only interested in the case where a single character was inserted\n      return null;\n    }\n    const ch = insertedText;\n    let hasDeletion = false;\n    for (const composition of compositions) {\n      if (composition.deletedText.length !== 0) {\n        hasDeletion = true;\n        break;\n      }\n    }\n    if (hasDeletion) {\n      // Check if this could have been a surround selection\n      if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n        return null;\n      }\n      const isTypingAQuoteCharacter = isQuote(ch);\n      for (const composition of compositions) {\n        if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n          // more text was deleted than was selected, so this could not have been a surround selection\n          return null;\n        }\n        if (/^[ \\t]+$/.test(composition.deletedText)) {\n          // deleted text was only whitespace\n          return null;\n        }\n        if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n          // deleted text was a quote\n          return null;\n        }\n      }\n      const positions = [];\n      for (const selection of selections) {\n        if (!selection.isEmpty()) {\n          return null;\n        }\n        positions.push(selection.getPosition());\n      }\n      if (positions.length !== compositions.length) {\n        return null;\n      }\n      const commands = [];\n      for (let i = 0, len = positions.length; i < len; i++) {\n        commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n      }\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n    if (autoClosingPairClose !== null) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n    }\n    return null;\n  }\n  static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (!isDoingComposition && ch === '\\n') {\n      const commands = [];\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n      }\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n      const commands = [];\n      let autoIndentFails = false;\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n        if (!commands[i]) {\n          autoIndentFails = true;\n          break;\n        }\n      }\n      if (!autoIndentFails) {\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n    }\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n    }\n    if (!isDoingComposition) {\n      const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n      if (autoClosingPairClose) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n      }\n    }\n    if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n    }\n    // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n      if (r) {\n        return r;\n      }\n    }\n    // A simple character type\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n    const opType = getTypingOperation(ch, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n  static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n    const opType = getTypingOperation(str, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n  static lineInsertBefore(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let lineNumber = selections[i].positionLineNumber;\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        const column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n    return commands;\n  }\n  static lineInsertAfter(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const lineNumber = selections[i].positionLineNumber;\n      const column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n    return commands;\n  }\n  static lineBreakInsert(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n    return commands;\n  }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n    this._openCharacter = openCharacter;\n    this._closeCharacter = closeCharacter;\n    this.closeCharacterRange = null;\n    this.enclosingRange = null;\n  }\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n    const range = inverseEditOperations[0].range;\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return super.computeCursorState(model, helper);\n  }\n}\nexport class CompositionOutcome {\n  constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n    this.deletedText = deletedText;\n    this.deletedSelectionStart = deletedSelectionStart;\n    this.deletedSelectionEnd = deletedSelectionEnd;\n    this.insertedText = insertedText;\n    this.insertedSelectionStart = insertedSelectionStart;\n    this.insertedSelectionEnd = insertedSelectionEnd;\n  }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n  if (typedText === ' ') {\n    return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */ || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */ ? 6 /* EditOperationType.TypingConsecutiveSpace */ : 5 /* EditOperationType.TypingFirstSpace */;\n  }\n  return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n  if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n    // Always set an undo stop before non-type operations\n    return true;\n  }\n  if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n    // `abc |d`: No undo stop\n    // `abc  |d`: Undo stop\n    return false;\n  }\n  // Insert undo stop between different operation types\n  return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n  return type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */ ? 'space' : type;\n}\nfunction isTypingOperation(type) {\n  return type === 4 /* EditOperationType.TypingOther */ || type === 5 /* EditOperationType.TypingFirstSpace */ || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}","map":{"version":3,"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","CompositionSurroundSelectionCommand","SurroundSelectionCommand","EditOperationResult","isQuote","getMapForWordSeparators","Range","Position","IndentAction","getIndentationAtPosition","createScopedLineTokens","getIndentActionForType","getIndentForEnter","getInheritIndentForLine","getEnterAction","TypeOperations","indent","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","languageConfigurationService","outdent","shiftIndent","indentation","count","unshiftIndent","_distributedPaste","text","shouldPushStackElementBefore","shouldPushStackElementAfter","_simplePaste","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","_distributePasteToCursors","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","paste","distributedPaste","sort","compareRangesUsingStarts","_goodIndentForLine","action","expectedIndentAction","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","appendText","Indent","Outdent","normalizeIndentation","_replaceJumpToNextIndent","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","spacesCnt","tab","startLineNumber","test","tokenization","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","endLineNumber","lineMaxColumn","startColumn","endColumn","compositionType","prevEditOperationType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","map","_compositionType","shouldPushStackElementBetween","pos","Math","max","column","min","range","oldText","getValueInRange","_typeCommand","keepPosition","_enter","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getLineFirstNonWhitespaceColumn","_isAutoClosingOvertype","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","_findAutoClosingPairOpen","positions","candidates","autoClosingPairsOpenByEnd","result","candidate","candidateIsMatch","relevantText","_findContainedAutoClosingPair","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","_getAutoClosingPairClose","chIsAlreadyTyped","s","beforeColumn","afterColumn","p","autoCloseConfig","shouldAutoCloseBefore","autoClosingQuotes","quote","pairIsForComments","blockCommentStartToken","autoClosingComments","comment","autoClosingBrackets","bracket","containedPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","isBeforeCloseBrace","wordSeparators","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","_runAutoClosingOpenCharType","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","e","matchOpenBracket","lastIndexOf","match","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","getTypingOperation","compositionEndWithInterceptors","compositions","insertedText","composition","hasDeletion","deletedText","deletedSelectionStart","deletedSelectionEnd","push","positionLineNumber","positionColumn","typeWithInterceptors","isDoingComposition","autoIndentFails","opType","typeWithoutInterceptors","str","lineInsertBefore","lineInsertAfter","lineBreakInsert","constructor","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","CompositionOutcome","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","type"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}