{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar ShiftCommand_1;\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n  if (count <= 0) {\n    return '';\n  }\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n  const cache = repeatCache[str];\n  for (let i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n  return cache[count];\n}\nlet ShiftCommand = ShiftCommand_1 = class ShiftCommand {\n  static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n  static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n  constructor(range, opts, _languageConfigurationService) {\n    this._languageConfigurationService = _languageConfigurationService;\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n  _addEditOperation(builder, range, text) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      builder.addTrackedEditOperation(range, text);\n    } else {\n      builder.addEditOperation(range, text);\n    }\n  }\n  getEditOperations(model, builder) {\n    const startLine = this._selection.startLineNumber;\n    let endLine = this._selection.endLineNumber;\n    if (this._selection.endColumn === 1 && startLine !== endLine) {\n      endLine = endLine - 1;\n    }\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = this._opts;\n    const shouldIndentEmptyLines = startLine === endLine;\n    if (this._opts.useTabStops) {\n      // if indenting or outdenting on a whitespace only line\n      if (this._selection.isEmpty()) {\n        if (/^\\s*$/.test(model.getLineContent(startLine))) {\n          this._useLastEditRangeForCursorEndPosition = true;\n        }\n      }\n      // keep track of previous line's \"miss-alignment\"\n      let previousLineExtraSpaces = 0,\n        extraSpaces = 0;\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n        extraSpaces = 0;\n        const lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n        if (lineNumber > 1) {\n          const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n          if (contentStartVisibleColumn % indentSize !== 0) {\n            // The current line is \"miss-aligned\", so let's see if this is expected...\n            // This can only happen when it has trailing commas in the indent\n            if (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n              const enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n              if (enterAction) {\n                extraSpaces = previousLineExtraSpaces;\n                if (enterAction.appendText) {\n                  for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                    if (enterAction.appendText.charCodeAt(j) === 32 /* CharCode.Space */) {\n                      extraSpaces++;\n                    } else {\n                      break;\n                    }\n                  }\n                }\n                if (enterAction.removeText) {\n                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                }\n                // Act as if `prefixSpaces` is not part of the indentation\n                for (let j = 0; j < extraSpaces; j++) {\n                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* CharCode.Space */) {\n                    break;\n                  }\n                  indentationEndIndex--;\n                }\n              }\n            }\n          }\n        }\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n        let desiredIndent;\n        if (this._opts.isUnshift) {\n          desiredIndent = ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        } else {\n          desiredIndent = ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        }\n        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n        if (lineNumber === startLine && !this._selection.isEmpty()) {\n          // Force the startColumn to stay put because we're inserting after it\n          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n        }\n      }\n    } else {\n      // if indenting or outdenting on a whitespace only line\n      if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n        this._useLastEditRangeForCursorEndPosition = true;\n      }\n      const oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (this._opts.isUnshift) {\n          indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n          for (let i = 0; i < indentationEndIndex; i++) {\n            const chr = lineText.charCodeAt(i);\n            if (chr === 9 /* CharCode.Tab */) {\n              indentationEndIndex = i + 1;\n              break;\n            }\n          }\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n        } else {\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n          }\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(this._selection);\n  }\n  computeCursorState(model, helper) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      const lastOp = helper.getInverseEditOperations()[0];\n      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n    }\n    const result = helper.getTrackedSelection(this._selectionId);\n    if (this._selectionStartColumnStaysPut) {\n      // The selection start should not move\n      const initialStartColumn = this._selection.startColumn;\n      const resultStartColumn = result.startColumn;\n      if (resultStartColumn <= initialStartColumn) {\n        return result;\n      }\n      if (result.getDirection() === 0 /* SelectionDirection.LTR */) {\n        return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n      }\n      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n    }\n    return result;\n  }\n};\nShiftCommand = ShiftCommand_1 = __decorate([__param(2, ILanguageConfigurationService)], ShiftCommand);\nexport { ShiftCommand };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ShiftCommand_1","strings","CursorColumns","Range","Selection","getEnterAction","ILanguageConfigurationService","repeatCache","create","cachedStringRepeat","str","count","cache","ShiftCommand","unshiftIndent","line","column","tabSize","indentSize","insertSpaces","contentStartVisibleColumn","visibleColumnFromColumn","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","shiftIndent","nextIndentTabStop","nextRenderTabStop","constructor","range","opts","_languageConfigurationService","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","_addEditOperation","builder","text","addTrackedEditOperation","addEditOperation","getEditOperations","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","shouldIndentEmptyLines","useTabStops","isEmpty","test","getLineContent","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","tokenization","isCheapToTokenize","enterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","startColumn","getLineLength","oneIndent","min","chr","trackSelection","computeCursorState","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ShiftCommand_1;\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nlet ShiftCommand = ShiftCommand_1 = class ShiftCommand {\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    constructor(range, opts, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n                            const enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* CharCode.Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* CharCode.Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* CharCode.Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            const lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            const initialStartColumn = this._selection.startColumn;\n            const resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* SelectionDirection.LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n};\nShiftCommand = ShiftCommand_1 = __decorate([\n    __param(2, ILanguageConfigurationService)\n], ShiftCommand);\nexport { ShiftCommand };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}