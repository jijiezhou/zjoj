{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n  constructor() {\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n  }\n  insert(x) {\n    this._hasPending = true;\n    this._inserts.push(x);\n  }\n  change(x) {\n    this._hasPending = true;\n    this._changes.push(x);\n  }\n  remove(x) {\n    this._hasPending = true;\n    this._removes.push(x);\n  }\n  mustCommit() {\n    return this._hasPending;\n  }\n  commit(linesLayout) {\n    if (!this._hasPending) {\n      return;\n    }\n    const inserts = this._inserts;\n    const changes = this._changes;\n    const removes = this._removes;\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n    linesLayout._commitPendingChanges(inserts, changes, removes);\n  }\n}\nexport class EditorWhitespace {\n  constructor(id, afterLineNumber, ordinal, height, minWidth) {\n    this.id = id;\n    this.afterLineNumber = afterLineNumber;\n    this.ordinal = ordinal;\n    this.height = height;\n    this.minWidth = minWidth;\n    this.prefixSum = 0;\n  }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n  constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n    this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n    this._pendingChanges = new PendingChanges();\n    this._lastWhitespaceId = 0;\n    this._arr = [];\n    this._prefixSumValidIndex = -1;\n    this._minWidth = -1; /* marker for not being computed */\n    this._lineCount = lineCount;\n    this._lineHeight = lineHeight;\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\n   * Find the insertion index for a new value inside a sorted array of values.\n   * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n   */\n  static findInsertionIndex(arr, afterLineNumber, ordinal) {\n    let low = 0;\n    let high = arr.length;\n    while (low < high) {\n      const mid = low + high >>> 1;\n      if (afterLineNumber === arr[mid].afterLineNumber) {\n        if (ordinal < arr[mid].ordinal) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      } else if (afterLineNumber < arr[mid].afterLineNumber) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Change the height of a line in pixels.\n   */\n  setLineHeight(lineHeight) {\n    this._checkPendingChanges();\n    this._lineHeight = lineHeight;\n  }\n  /**\n   * Changes the padding used to calculate vertical offsets.\n   */\n  setPadding(paddingTop, paddingBottom) {\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\n   * Set the number of lines.\n   *\n   * @param lineCount New number of lines.\n   */\n  onFlushed(lineCount) {\n    this._checkPendingChanges();\n    this._lineCount = lineCount;\n  }\n  changeWhitespace(callback) {\n    let hadAChange = false;\n    try {\n      const accessor = {\n        insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n          hadAChange = true;\n          afterLineNumber = afterLineNumber | 0;\n          ordinal = ordinal | 0;\n          heightInPx = heightInPx | 0;\n          minWidth = minWidth | 0;\n          const id = this._instanceId + ++this._lastWhitespaceId;\n          this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n          return id;\n        },\n        changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n          hadAChange = true;\n          newAfterLineNumber = newAfterLineNumber | 0;\n          newHeight = newHeight | 0;\n          this._pendingChanges.change({\n            id,\n            newAfterLineNumber,\n            newHeight\n          });\n        },\n        removeWhitespace: id => {\n          hadAChange = true;\n          this._pendingChanges.remove({\n            id\n          });\n        }\n      };\n      callback(accessor);\n    } finally {\n      this._pendingChanges.commit(this);\n    }\n    return hadAChange;\n  }\n  _commitPendingChanges(inserts, changes, removes) {\n    if (inserts.length > 0 || removes.length > 0) {\n      this._minWidth = -1; /* marker for not being computed */\n    }\n    if (inserts.length + changes.length + removes.length <= 1) {\n      // when only one thing happened, handle it \"delicately\"\n      for (const insert of inserts) {\n        this._insertWhitespace(insert);\n      }\n      for (const change of changes) {\n        this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n      }\n      for (const remove of removes) {\n        const index = this._findWhitespaceIndex(remove.id);\n        if (index === -1) {\n          continue;\n        }\n        this._removeWhitespace(index);\n      }\n      return;\n    }\n    // simply rebuild the entire datastructure\n    const toRemove = new Set();\n    for (const remove of removes) {\n      toRemove.add(remove.id);\n    }\n    const toChange = new Map();\n    for (const change of changes) {\n      toChange.set(change.id, change);\n    }\n    const applyRemoveAndChange = whitespaces => {\n      const result = [];\n      for (const whitespace of whitespaces) {\n        if (toRemove.has(whitespace.id)) {\n          continue;\n        }\n        if (toChange.has(whitespace.id)) {\n          const change = toChange.get(whitespace.id);\n          whitespace.afterLineNumber = change.newAfterLineNumber;\n          whitespace.height = change.newHeight;\n        }\n        result.push(whitespace);\n      }\n      return result;\n    };\n    const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n    result.sort((a, b) => {\n      if (a.afterLineNumber === b.afterLineNumber) {\n        return a.ordinal - b.ordinal;\n      }\n      return a.afterLineNumber - b.afterLineNumber;\n    });\n    this._arr = result;\n    this._prefixSumValidIndex = -1;\n  }\n  _checkPendingChanges() {\n    if (this._pendingChanges.mustCommit()) {\n      this._pendingChanges.commit(this);\n    }\n  }\n  _insertWhitespace(whitespace) {\n    const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n    this._arr.splice(insertIndex, 0, whitespace);\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n  }\n  _findWhitespaceIndex(id) {\n    const arr = this._arr;\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i].id === id) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n    const index = this._findWhitespaceIndex(id);\n    if (index === -1) {\n      return;\n    }\n    if (this._arr[index].height !== newHeight) {\n      this._arr[index].height = newHeight;\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n    }\n    if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n      // `afterLineNumber` changed for this whitespace\n      // Record old whitespace\n      const whitespace = this._arr[index];\n      // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n      this._removeWhitespace(index);\n      whitespace.afterLineNumber = newAfterLineNumber;\n      // And add it again\n      this._insertWhitespace(whitespace);\n    }\n  }\n  _removeWhitespace(removeIndex) {\n    this._arr.splice(removeIndex, 1);\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n  }\n  /**\n   * Notify the layouter that lines have been deleted (a continuous zone of lines).\n   *\n   * @param fromLineNumber The line number at which the deletion started, inclusive\n   * @param toLineNumber The line number at which the deletion ended, inclusive\n   */\n  onLinesDeleted(fromLineNumber, toLineNumber) {\n    this._checkPendingChanges();\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n    this._lineCount -= toLineNumber - fromLineNumber + 1;\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      const afterLineNumber = this._arr[i].afterLineNumber;\n      if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n        // The line this whitespace was after has been deleted\n        //  => move whitespace to before first deleted line\n        this._arr[i].afterLineNumber = fromLineNumber - 1;\n      } else if (afterLineNumber > toLineNumber) {\n        // The line this whitespace was after has been moved up\n        //  => move whitespace up\n        this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1;\n      }\n    }\n  }\n  /**\n   * Notify the layouter that lines have been inserted (a continuous zone of lines).\n   *\n   * @param fromLineNumber The line number at which the insertion started, inclusive\n   * @param toLineNumber The line number at which the insertion ended, inclusive.\n   */\n  onLinesInserted(fromLineNumber, toLineNumber) {\n    this._checkPendingChanges();\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n    this._lineCount += toLineNumber - fromLineNumber + 1;\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      const afterLineNumber = this._arr[i].afterLineNumber;\n      if (fromLineNumber <= afterLineNumber) {\n        this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1;\n      }\n    }\n  }\n  /**\n   * Get the sum of all the whitespaces.\n   */\n  getWhitespacesTotalHeight() {\n    this._checkPendingChanges();\n    if (this._arr.length === 0) {\n      return 0;\n    }\n    return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n  }\n  /**\n   * Return the sum of the heights of the whitespaces at [0..index].\n   * This includes the whitespace at `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n   */\n  getWhitespacesAccumulatedHeight(index) {\n    this._checkPendingChanges();\n    index = index | 0;\n    let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n    if (startIndex === 0) {\n      this._arr[0].prefixSum = this._arr[0].height;\n      startIndex++;\n    }\n    for (let i = startIndex; i <= index; i++) {\n      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n    }\n    this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n    return this._arr[index].prefixSum;\n  }\n  /**\n   * Get the sum of heights for all objects.\n   *\n   * @return The sum of heights for all objects.\n   */\n  getLinesTotalHeight() {\n    this._checkPendingChanges();\n    const linesHeight = this._lineHeight * this._lineCount;\n    const whitespacesHeight = this.getWhitespacesTotalHeight();\n    return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n  }\n  /**\n   * Returns the accumulated height of whitespaces before the given line number.\n   *\n   * @param lineNumber The line number\n   */\n  getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n    this._checkPendingChanges();\n    lineNumber = lineNumber | 0;\n    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n    if (lastWhitespaceBeforeLineNumber === -1) {\n      return 0;\n    }\n    return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n  }\n  _findLastWhitespaceBeforeLineNumber(lineNumber) {\n    lineNumber = lineNumber | 0;\n    // Find the whitespace before line number\n    const arr = this._arr;\n    let low = 0;\n    let high = arr.length - 1;\n    while (low <= high) {\n      const delta = high - low | 0;\n      const halfDelta = delta / 2 | 0;\n      const mid = low + halfDelta | 0;\n      if (arr[mid].afterLineNumber < lineNumber) {\n        if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n          return mid;\n        } else {\n          low = mid + 1 | 0;\n        }\n      } else {\n        high = mid - 1 | 0;\n      }\n    }\n    return -1;\n  }\n  _findFirstWhitespaceAfterLineNumber(lineNumber) {\n    lineNumber = lineNumber | 0;\n    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n    const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n    if (firstWhitespaceAfterLineNumber < this._arr.length) {\n      return firstWhitespaceAfterLineNumber;\n    }\n    return -1;\n  }\n  /**\n   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n   */\n  getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n    this._checkPendingChanges();\n    lineNumber = lineNumber | 0;\n    return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n  }\n  /**\n   * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n   *\n   * @param lineNumber The line number\n   * @return The sum of heights for all objects above `lineNumber`.\n   */\n  getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n    this._checkPendingChanges();\n    lineNumber = lineNumber | 0;\n    let previousLinesHeight;\n    if (lineNumber > 1) {\n      previousLinesHeight = this._lineHeight * (lineNumber - 1);\n    } else {\n      previousLinesHeight = 0;\n    }\n    const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n  }\n  /**\n   * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n   *\n   * @param lineNumber The line number\n   * @return The sum of heights for all objects above `lineNumber`.\n   */\n  getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n    this._checkPendingChanges();\n    lineNumber = lineNumber | 0;\n    const previousLinesHeight = this._lineHeight * lineNumber;\n    const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n  }\n  /**\n   * The maximum min width for all whitespaces.\n   */\n  getWhitespaceMinWidth() {\n    this._checkPendingChanges();\n    if (this._minWidth === -1) {\n      let minWidth = 0;\n      for (let i = 0, len = this._arr.length; i < len; i++) {\n        minWidth = Math.max(minWidth, this._arr[i].minWidth);\n      }\n      this._minWidth = minWidth;\n    }\n    return this._minWidth;\n  }\n  /**\n   * Check if `verticalOffset` is below all lines.\n   */\n  isAfterLines(verticalOffset) {\n    this._checkPendingChanges();\n    const totalHeight = this.getLinesTotalHeight();\n    return verticalOffset > totalHeight;\n  }\n  isInTopPadding(verticalOffset) {\n    if (this._paddingTop === 0) {\n      return false;\n    }\n    this._checkPendingChanges();\n    return verticalOffset < this._paddingTop;\n  }\n  isInBottomPadding(verticalOffset) {\n    if (this._paddingBottom === 0) {\n      return false;\n    }\n    this._checkPendingChanges();\n    const totalHeight = this.getLinesTotalHeight();\n    return verticalOffset >= totalHeight - this._paddingBottom;\n  }\n  /**\n   * Find the first line number that is at or after vertical offset `verticalOffset`.\n   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n   *\n   * @param verticalOffset The vertical offset to search at.\n   * @return The line number at or after vertical offset `verticalOffset`.\n   */\n  getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n    this._checkPendingChanges();\n    verticalOffset = verticalOffset | 0;\n    if (verticalOffset < 0) {\n      return 1;\n    }\n    const linesCount = this._lineCount | 0;\n    const lineHeight = this._lineHeight;\n    let minLineNumber = 1;\n    let maxLineNumber = linesCount;\n    while (minLineNumber < maxLineNumber) {\n      const midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0;\n      const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n      if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n        // vertical offset is after mid line number\n        minLineNumber = midLineNumber + 1;\n      } else if (verticalOffset >= midLineNumberVerticalOffset) {\n        // Hit\n        return midLineNumber;\n      } else {\n        // vertical offset is before mid line number, but mid line number could still be what we're searching for\n        maxLineNumber = midLineNumber;\n      }\n    }\n    if (minLineNumber > linesCount) {\n      return linesCount;\n    }\n    return minLineNumber;\n  }\n  /**\n   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n   *\n   * @param verticalOffset1 The beginning of the viewport.\n   * @param verticalOffset2 The end of the viewport.\n   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n   */\n  getLinesViewportData(verticalOffset1, verticalOffset2) {\n    this._checkPendingChanges();\n    verticalOffset1 = verticalOffset1 | 0;\n    verticalOffset2 = verticalOffset2 | 0;\n    const lineHeight = this._lineHeight;\n    // Find first line number\n    // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n    const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n    const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n    let endLineNumber = this._lineCount | 0;\n    // Also keep track of what whitespace we've got\n    let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n    const whitespaceCount = this.getWhitespacesCount() | 0;\n    let currentWhitespaceHeight;\n    let currentWhitespaceAfterLineNumber;\n    if (whitespaceIndex === -1) {\n      whitespaceIndex = whitespaceCount;\n      currentWhitespaceAfterLineNumber = endLineNumber + 1;\n      currentWhitespaceHeight = 0;\n    } else {\n      currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n      currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n    }\n    let currentVerticalOffset = startLineNumberVerticalOffset;\n    let currentLineRelativeOffset = currentVerticalOffset;\n    // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n    const STEP_SIZE = 500000;\n    let bigNumbersDelta = 0;\n    if (startLineNumberVerticalOffset >= STEP_SIZE) {\n      // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n      bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n      bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n      currentLineRelativeOffset -= bigNumbersDelta;\n    }\n    const linesOffsets = [];\n    const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n    let centeredLineNumber = -1;\n    // Figure out how far the lines go\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      if (centeredLineNumber === -1) {\n        const currentLineTop = currentVerticalOffset;\n        const currentLineBottom = currentVerticalOffset + lineHeight;\n        if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {\n          centeredLineNumber = lineNumber;\n        }\n      }\n      // Count current line height in the vertical offsets\n      currentVerticalOffset += lineHeight;\n      linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n      // Next line starts immediately after this one\n      currentLineRelativeOffset += lineHeight;\n      while (currentWhitespaceAfterLineNumber === lineNumber) {\n        // Push down next line with the height of the current whitespace\n        currentLineRelativeOffset += currentWhitespaceHeight;\n        // Count current whitespace in the vertical offsets\n        currentVerticalOffset += currentWhitespaceHeight;\n        whitespaceIndex++;\n        if (whitespaceIndex >= whitespaceCount) {\n          currentWhitespaceAfterLineNumber = endLineNumber + 1;\n        } else {\n          currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n          currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n      }\n      if (currentVerticalOffset >= verticalOffset2) {\n        // We have covered the entire viewport area, time to stop\n        endLineNumber = lineNumber;\n        break;\n      }\n    }\n    if (centeredLineNumber === -1) {\n      centeredLineNumber = endLineNumber;\n    }\n    const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n    let completelyVisibleStartLineNumber = startLineNumber;\n    let completelyVisibleEndLineNumber = endLineNumber;\n    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n      if (startLineNumberVerticalOffset < verticalOffset1) {\n        completelyVisibleStartLineNumber++;\n      }\n    }\n    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n      if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n        completelyVisibleEndLineNumber--;\n      }\n    }\n    return {\n      bigNumbersDelta: bigNumbersDelta,\n      startLineNumber: startLineNumber,\n      endLineNumber: endLineNumber,\n      relativeVerticalOffset: linesOffsets,\n      centeredLineNumber: centeredLineNumber,\n      completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n      completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n    };\n  }\n  getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n    this._checkPendingChanges();\n    whitespaceIndex = whitespaceIndex | 0;\n    const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n    let previousLinesHeight;\n    if (afterLineNumber >= 1) {\n      previousLinesHeight = this._lineHeight * afterLineNumber;\n    } else {\n      previousLinesHeight = 0;\n    }\n    let previousWhitespacesHeight;\n    if (whitespaceIndex > 0) {\n      previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n    } else {\n      previousWhitespacesHeight = 0;\n    }\n    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n  }\n  getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n    this._checkPendingChanges();\n    verticalOffset = verticalOffset | 0;\n    let minWhitespaceIndex = 0;\n    let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n    if (maxWhitespaceIndex < 0) {\n      return -1;\n    }\n    // Special case: nothing to be found\n    const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n    const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n    if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n      return -1;\n    }\n    while (minWhitespaceIndex < maxWhitespaceIndex) {\n      const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n      const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n      const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n      if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n        // vertical offset is after whitespace\n        minWhitespaceIndex = midWhitespaceIndex + 1;\n      } else if (verticalOffset >= midWhitespaceVerticalOffset) {\n        // Hit\n        return midWhitespaceIndex;\n      } else {\n        // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n        maxWhitespaceIndex = midWhitespaceIndex;\n      }\n    }\n    return minWhitespaceIndex;\n  }\n  /**\n   * Get exactly the whitespace that is layouted at `verticalOffset`.\n   *\n   * @param verticalOffset The vertical offset.\n   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n   */\n  getWhitespaceAtVerticalOffset(verticalOffset) {\n    this._checkPendingChanges();\n    verticalOffset = verticalOffset | 0;\n    const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n    if (candidateIndex < 0) {\n      return null;\n    }\n    if (candidateIndex >= this.getWhitespacesCount()) {\n      return null;\n    }\n    const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n    if (candidateTop > verticalOffset) {\n      return null;\n    }\n    const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n    const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n    const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n    return {\n      id: candidateId,\n      afterLineNumber: candidateAfterLineNumber,\n      verticalOffset: candidateTop,\n      height: candidateHeight\n    };\n  }\n  /**\n   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n   *\n   * @param verticalOffset1 The beginning of the viewport.\n   * @param verticalOffset2 The end of the viewport.\n   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n   */\n  getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n    this._checkPendingChanges();\n    verticalOffset1 = verticalOffset1 | 0;\n    verticalOffset2 = verticalOffset2 | 0;\n    const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n    const endIndex = this.getWhitespacesCount() - 1;\n    if (startIndex < 0) {\n      return [];\n    }\n    const result = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      const top = this.getVerticalOffsetForWhitespaceIndex(i);\n      const height = this.getHeightForWhitespaceIndex(i);\n      if (top >= verticalOffset2) {\n        break;\n      }\n      result.push({\n        id: this.getIdForWhitespaceIndex(i),\n        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n        verticalOffset: top,\n        height: height\n      });\n    }\n    return result;\n  }\n  /**\n   * Get all whitespaces.\n   */\n  getWhitespaces() {\n    this._checkPendingChanges();\n    return this._arr.slice(0);\n  }\n  /**\n   * The number of whitespaces.\n   */\n  getWhitespacesCount() {\n    this._checkPendingChanges();\n    return this._arr.length;\n  }\n  /**\n   * Get the `id` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `id` of whitespace at `index`.\n   */\n  getIdForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n    index = index | 0;\n    return this._arr[index].id;\n  }\n  /**\n   * Get the `afterLineNumber` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `afterLineNumber` of whitespace at `index`.\n   */\n  getAfterLineNumberForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n    index = index | 0;\n    return this._arr[index].afterLineNumber;\n  }\n  /**\n   * Get the `height` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `height` of whitespace at `index`.\n   */\n  getHeightForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n    index = index | 0;\n    return this._arr[index].height;\n  }\n}\nLinesLayout.INSTANCE_COUNT = 0;","map":{"version":3,"names":["strings","PendingChanges","constructor","_hasPending","_inserts","_changes","_removes","insert","x","push","change","remove","mustCommit","commit","linesLayout","inserts","changes","removes","_commitPendingChanges","EditorWhitespace","id","afterLineNumber","ordinal","height","minWidth","prefixSum","LinesLayout","lineCount","lineHeight","paddingTop","paddingBottom","_instanceId","singleLetterHash","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_lineHeight","_paddingTop","_paddingBottom","findInsertionIndex","arr","low","high","length","mid","setLineHeight","_checkPendingChanges","setPadding","onFlushed","changeWhitespace","callback","hadAChange","accessor","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","removeWhitespace","_insertWhitespace","_changeOneWhitespace","index","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","Map","set","applyRemoveAndChange","whitespaces","result","whitespace","has","get","concat","sort","a","b","insertIndex","splice","Math","min","i","len","removeIndex","onLinesDeleted","fromLineNumber","toLineNumber","onLinesInserted","getWhitespacesTotalHeight","getWhitespacesAccumulatedHeight","startIndex","max","getLinesTotalHeight","linesHeight","whitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","lineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","delta","halfDelta","_findFirstWhitespaceAfterLineNumber","firstWhitespaceAfterLineNumber","getFirstWhitespaceIndexAfterLineNumber","getVerticalOffsetForLineNumber","includeViewZones","previousLinesHeight","previousWhitespacesHeight","getVerticalOffsetAfterLineNumber","getWhitespaceMinWidth","isAfterLines","verticalOffset","totalHeight","isInTopPadding","isInBottomPadding","getLineNumberAtOrAfterVerticalOffset","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getLinesViewportData","verticalOffset1","verticalOffset2","startLineNumber","startLineNumberVerticalOffset","endLineNumber","whitespaceIndex","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","bigNumbersDelta","floor","linesOffsets","verticalCenter","centeredLineNumber","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","relativeVerticalOffset","getVerticalOffsetForWhitespaceIndex","getWhitespaceIndexAtOrAfterVerticallOffset","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","getWhitespaceAtVerticalOffset","candidateIndex","candidateTop","candidateHeight","candidateId","getIdForWhitespaceIndex","candidateAfterLineNumber","getWhitespaceViewportData","endIndex","top","getWhitespaces","slice"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}