{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './selections.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nclass HorizontalRangeWithStyle {\n  constructor(other) {\n    this.left = other.left;\n    this.width = other.width;\n    this.startStyle = null;\n    this.endStyle = null;\n  }\n}\nclass LineVisibleRangesWithStyle {\n  constructor(lineNumber, ranges) {\n    this.lineNumber = lineNumber;\n    this.ranges = ranges;\n  }\n}\nfunction toStyledRange(item) {\n  return new HorizontalRangeWithStyle(item);\n}\nfunction toStyled(item) {\n  return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n}\nexport class SelectionsOverlay extends DynamicViewOverlay {\n  constructor(context) {\n    super();\n    this._previousFrameVisibleRangesWithStyle = [];\n    this._context = context;\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n    this._roundedSelection = options.get(100 /* EditorOption.roundedSelection */);\n    this._typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n    this._selections = [];\n    this._renderResult = null;\n    this._context.addEventHandler(this);\n  }\n  dispose() {\n    this._context.removeEventHandler(this);\n    this._renderResult = null;\n    super.dispose();\n  }\n  // --- begin event handlers\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n    this._roundedSelection = options.get(100 /* EditorOption.roundedSelection */);\n    this._typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n    return true;\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections.slice(0);\n    return true;\n  }\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true; //e.inlineDecorationsChanged;\n  }\n  onFlushed(e) {\n    return true;\n  }\n  onLinesChanged(e) {\n    return true;\n  }\n  onLinesDeleted(e) {\n    return true;\n  }\n  onLinesInserted(e) {\n    return true;\n  }\n  onScrollChanged(e) {\n    return e.scrollTopChanged;\n  }\n  onZonesChanged(e) {\n    return true;\n  }\n  // --- end event handlers\n  _visibleRangesHaveGaps(linesVisibleRanges) {\n    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      const lineVisibleRanges = linesVisibleRanges[i];\n      if (lineVisibleRanges.ranges.length > 1) {\n        // There are two ranges on the same line\n        return true;\n      }\n    }\n    return false;\n  }\n  _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {\n    const epsilon = this._typicalHalfwidthCharacterWidth / 4;\n    let previousFrameTop = null;\n    let previousFrameBottom = null;\n    if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n      const topLineNumber = linesVisibleRanges[0].lineNumber;\n      if (topLineNumber === viewport.startLineNumber) {\n        for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n          if (previousFrame[i].lineNumber === topLineNumber) {\n            previousFrameTop = previousFrame[i].ranges[0];\n          }\n        }\n      }\n      const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n      if (bottomLineNumber === viewport.endLineNumber) {\n        for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n          if (previousFrame[i].lineNumber === bottomLineNumber) {\n            previousFrameBottom = previousFrame[i].ranges[0];\n          }\n        }\n      }\n      if (previousFrameTop && !previousFrameTop.startStyle) {\n        previousFrameTop = null;\n      }\n      if (previousFrameBottom && !previousFrameBottom.startStyle) {\n        previousFrameBottom = null;\n      }\n    }\n    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      // We know for a fact that there is precisely one range on each line\n      const curLineRange = linesVisibleRanges[i].ranges[0];\n      const curLeft = curLineRange.left;\n      const curRight = curLineRange.left + curLineRange.width;\n      const startStyle = {\n        top: 0 /* CornerStyle.EXTERN */,\n        bottom: 0 /* CornerStyle.EXTERN */\n      };\n      const endStyle = {\n        top: 0 /* CornerStyle.EXTERN */,\n        bottom: 0 /* CornerStyle.EXTERN */\n      };\n      if (i > 0) {\n        // Look above\n        const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n        const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n        if (abs(curLeft - prevLeft) < epsilon) {\n          startStyle.top = 2 /* CornerStyle.FLAT */;\n        } else if (curLeft > prevLeft) {\n          startStyle.top = 1 /* CornerStyle.INTERN */;\n        }\n        if (abs(curRight - prevRight) < epsilon) {\n          endStyle.top = 2 /* CornerStyle.FLAT */;\n        } else if (prevLeft < curRight && curRight < prevRight) {\n          endStyle.top = 1 /* CornerStyle.INTERN */;\n        }\n      } else if (previousFrameTop) {\n        // Accept some hiccups near the viewport edges to save on repaints\n        startStyle.top = previousFrameTop.startStyle.top;\n        endStyle.top = previousFrameTop.endStyle.top;\n      }\n      if (i + 1 < len) {\n        // Look below\n        const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n        const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n        if (abs(curLeft - nextLeft) < epsilon) {\n          startStyle.bottom = 2 /* CornerStyle.FLAT */;\n        } else if (nextLeft < curLeft && curLeft < nextRight) {\n          startStyle.bottom = 1 /* CornerStyle.INTERN */;\n        }\n        if (abs(curRight - nextRight) < epsilon) {\n          endStyle.bottom = 2 /* CornerStyle.FLAT */;\n        } else if (curRight < nextRight) {\n          endStyle.bottom = 1 /* CornerStyle.INTERN */;\n        }\n      } else if (previousFrameBottom) {\n        // Accept some hiccups near the viewport edges to save on repaints\n        startStyle.bottom = previousFrameBottom.startStyle.bottom;\n        endStyle.bottom = previousFrameBottom.endStyle.bottom;\n      }\n      curLineRange.startStyle = startStyle;\n      curLineRange.endStyle = endStyle;\n    }\n  }\n  _getVisibleRangesWithStyle(selection, ctx, previousFrame) {\n    const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n    const linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n    const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n    if (!visibleRangesHaveGaps && this._roundedSelection) {\n      this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n    }\n    // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n    return linesVisibleRanges;\n  }\n  _createSelectionPiece(top, height, className, left, width) {\n    return '<div class=\"cslr ' + className + '\" style=\"top:' + top.toString() + 'px;left:' + left.toString() + 'px;width:' + width.toString() + 'px;height:' + height + 'px;\"></div>';\n  }\n  _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n    if (visibleRanges.length === 0) {\n      return;\n    }\n    const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;\n    const fullLineHeight = this._lineHeight.toString();\n    const reducedLineHeight = (this._lineHeight - 1).toString();\n    const firstLineNumber = visibleRanges[0].lineNumber;\n    const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;\n    for (let i = 0, len = visibleRanges.length; i < len; i++) {\n      const lineVisibleRanges = visibleRanges[i];\n      const lineNumber = lineVisibleRanges.lineNumber;\n      const lineIndex = lineNumber - visibleStartLineNumber;\n      const lineHeight = hasMultipleSelections ? lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight : fullLineHeight;\n      const top = hasMultipleSelections ? lineNumber === firstLineNumber ? 1 : 0 : 0;\n      let innerCornerOutput = '';\n      let restOfSelectionOutput = '';\n      for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n        const visibleRange = lineVisibleRanges.ranges[j];\n        if (visibleRangesHaveStyle) {\n          const startStyle = visibleRange.startStyle;\n          const endStyle = visibleRange.endStyle;\n          if (startStyle.top === 1 /* CornerStyle.INTERN */ || startStyle.bottom === 1 /* CornerStyle.INTERN */) {\n            // Reverse rounded corner to the left\n            // First comes the selection (blue layer)\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n            // Second comes the background (white layer) with inverse border radius\n            let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n            if (startStyle.top === 1 /* CornerStyle.INTERN */) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n            }\n            if (startStyle.bottom === 1 /* CornerStyle.INTERN */) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n            }\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n          }\n          if (endStyle.top === 1 /* CornerStyle.INTERN */ || endStyle.bottom === 1 /* CornerStyle.INTERN */) {\n            // Reverse rounded corner to the right\n            // First comes the selection (blue layer)\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n            // Second comes the background (white layer) with inverse border radius\n            let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n            if (endStyle.top === 1 /* CornerStyle.INTERN */) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n            }\n            if (endStyle.bottom === 1 /* CornerStyle.INTERN */) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n            }\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n          }\n        }\n        let className = SelectionsOverlay.SELECTION_CLASS_NAME;\n        if (visibleRangesHaveStyle) {\n          const startStyle = visibleRange.startStyle;\n          const endStyle = visibleRange.endStyle;\n          if (startStyle.top === 0 /* CornerStyle.EXTERN */) {\n            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n          }\n          if (startStyle.bottom === 0 /* CornerStyle.EXTERN */) {\n            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n          }\n          if (endStyle.top === 0 /* CornerStyle.EXTERN */) {\n            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n          }\n          if (endStyle.bottom === 0 /* CornerStyle.EXTERN */) {\n            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n          }\n        }\n        restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);\n      }\n      output2[lineIndex][0] += innerCornerOutput;\n      output2[lineIndex][1] += restOfSelectionOutput;\n    }\n  }\n  prepareRender(ctx) {\n    // Build HTML for inner corners separate from HTML for the rest of selections,\n    // as the inner corner HTML can interfere with that of other selections.\n    // In final render, make sure to place the inner corner HTML before the rest of selection HTML. See issue #77777.\n    const output = [];\n    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - visibleStartLineNumber;\n      output[lineIndex] = ['', ''];\n    }\n    const thisFrameVisibleRangesWithStyle = [];\n    for (let i = 0, len = this._selections.length; i < len; i++) {\n      const selection = this._selections[i];\n      if (selection.isEmpty()) {\n        thisFrameVisibleRangesWithStyle[i] = null;\n        continue;\n      }\n      const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n      thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n      this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n    }\n    this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n    this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);\n  }\n  render(startLineNumber, lineNumber) {\n    if (!this._renderResult) {\n      return '';\n    }\n    const lineIndex = lineNumber - startLineNumber;\n    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n      return '';\n    }\n    return this._renderResult[lineIndex];\n  }\n}\nSelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\nSelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\nSelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\nSelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\nSelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\nSelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\nSelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\nregisterThemingParticipant((theme, collector) => {\n  const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n  if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {\n    collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);\n  }\n});\nfunction abs(n) {\n  return n < 0 ? -n : n;\n}","map":{"version":3,"names":["DynamicViewOverlay","editorSelectionForeground","registerThemingParticipant","HorizontalRangeWithStyle","constructor","other","left","width","startStyle","endStyle","LineVisibleRangesWithStyle","lineNumber","ranges","toStyledRange","item","toStyled","map","SelectionsOverlay","context","_previousFrameVisibleRangesWithStyle","_context","options","configuration","_lineHeight","get","_roundedSelection","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_selections","_renderResult","addEventHandler","dispose","removeEventHandler","onConfigurationChanged","e","onCursorStateChanged","selections","slice","onDecorationsChanged","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","scrollTopChanged","onZonesChanged","_visibleRangesHaveGaps","linesVisibleRanges","i","len","length","lineVisibleRanges","_enrichVisibleRangesWithStyle","viewport","previousFrame","epsilon","previousFrameTop","previousFrameBottom","topLineNumber","startLineNumber","bottomLineNumber","endLineNumber","curLineRange","curLeft","curRight","top","bottom","prevLeft","prevRight","abs","nextLeft","nextRight","_getVisibleRangesWithStyle","selection","ctx","_linesVisibleRanges","linesVisibleRangesForRange","visibleRangesHaveGaps","visibleRange","_createSelectionPiece","height","className","toString","_actualRenderOneSelection","output2","visibleStartLineNumber","hasMultipleSelections","visibleRanges","visibleRangesHaveStyle","fullLineHeight","reducedLineHeight","firstLineNumber","lastLineNumber","lineIndex","lineHeight","innerCornerOutput","restOfSelectionOutput","j","lenJ","SELECTION_CLASS_NAME","ROUNDED_PIECE_WIDTH","EDITOR_BACKGROUND_CLASS_NAME","SELECTION_TOP_RIGHT","SELECTION_BOTTOM_RIGHT","SELECTION_TOP_LEFT","SELECTION_BOTTOM_LEFT","prepareRender","output","visibleEndLineNumber","thisFrameVisibleRangesWithStyle","isEmpty","visibleRangesWithStyle","internalCorners","restOfSelection","render","theme","collector","editorSelectionForegroundColor","getColor","isTransparent","addRule","n"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './selections.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nclass HorizontalRangeWithStyle {\n    constructor(other) {\n        this.left = other.left;\n        this.width = other.width;\n        this.startStyle = null;\n        this.endStyle = null;\n    }\n}\nclass LineVisibleRangesWithStyle {\n    constructor(lineNumber, ranges) {\n        this.lineNumber = lineNumber;\n        this.ranges = ranges;\n    }\n}\nfunction toStyledRange(item) {\n    return new HorizontalRangeWithStyle(item);\n}\nfunction toStyled(item) {\n    return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n}\nexport class SelectionsOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._previousFrameVisibleRangesWithStyle = [];\n        this._context = context;\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n        this._roundedSelection = options.get(100 /* EditorOption.roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        this._selections = [];\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n        this._roundedSelection = options.get(100 /* EditorOption.roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true; //e.inlineDecorationsChanged;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _visibleRangesHaveGaps(linesVisibleRanges) {\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = linesVisibleRanges[i];\n            if (lineVisibleRanges.ranges.length > 1) {\n                // There are two ranges on the same line\n                return true;\n            }\n        }\n        return false;\n    }\n    _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {\n        const epsilon = this._typicalHalfwidthCharacterWidth / 4;\n        let previousFrameTop = null;\n        let previousFrameBottom = null;\n        if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n            const topLineNumber = linesVisibleRanges[0].lineNumber;\n            if (topLineNumber === viewport.startLineNumber) {\n                for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n                    if (previousFrame[i].lineNumber === topLineNumber) {\n                        previousFrameTop = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n            if (bottomLineNumber === viewport.endLineNumber) {\n                for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n                    if (previousFrame[i].lineNumber === bottomLineNumber) {\n                        previousFrameBottom = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            if (previousFrameTop && !previousFrameTop.startStyle) {\n                previousFrameTop = null;\n            }\n            if (previousFrameBottom && !previousFrameBottom.startStyle) {\n                previousFrameBottom = null;\n            }\n        }\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            // We know for a fact that there is precisely one range on each line\n            const curLineRange = linesVisibleRanges[i].ranges[0];\n            const curLeft = curLineRange.left;\n            const curRight = curLineRange.left + curLineRange.width;\n            const startStyle = {\n                top: 0 /* CornerStyle.EXTERN */,\n                bottom: 0 /* CornerStyle.EXTERN */\n            };\n            const endStyle = {\n                top: 0 /* CornerStyle.EXTERN */,\n                bottom: 0 /* CornerStyle.EXTERN */\n            };\n            if (i > 0) {\n                // Look above\n                const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n                const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n                if (abs(curLeft - prevLeft) < epsilon) {\n                    startStyle.top = 2 /* CornerStyle.FLAT */;\n                }\n                else if (curLeft > prevLeft) {\n                    startStyle.top = 1 /* CornerStyle.INTERN */;\n                }\n                if (abs(curRight - prevRight) < epsilon) {\n                    endStyle.top = 2 /* CornerStyle.FLAT */;\n                }\n                else if (prevLeft < curRight && curRight < prevRight) {\n                    endStyle.top = 1 /* CornerStyle.INTERN */;\n                }\n            }\n            else if (previousFrameTop) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.top = previousFrameTop.startStyle.top;\n                endStyle.top = previousFrameTop.endStyle.top;\n            }\n            if (i + 1 < len) {\n                // Look below\n                const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n                const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n                if (abs(curLeft - nextLeft) < epsilon) {\n                    startStyle.bottom = 2 /* CornerStyle.FLAT */;\n                }\n                else if (nextLeft < curLeft && curLeft < nextRight) {\n                    startStyle.bottom = 1 /* CornerStyle.INTERN */;\n                }\n                if (abs(curRight - nextRight) < epsilon) {\n                    endStyle.bottom = 2 /* CornerStyle.FLAT */;\n                }\n                else if (curRight < nextRight) {\n                    endStyle.bottom = 1 /* CornerStyle.INTERN */;\n                }\n            }\n            else if (previousFrameBottom) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.bottom = previousFrameBottom.startStyle.bottom;\n                endStyle.bottom = previousFrameBottom.endStyle.bottom;\n            }\n            curLineRange.startStyle = startStyle;\n            curLineRange.endStyle = endStyle;\n        }\n    }\n    _getVisibleRangesWithStyle(selection, ctx, previousFrame) {\n        const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n        const linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n        const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n        if (!visibleRangesHaveGaps && this._roundedSelection) {\n            this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n        }\n        // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n        return linesVisibleRanges;\n    }\n    _createSelectionPiece(top, height, className, left, width) {\n        return ('<div class=\"cslr '\n            + className\n            + '\" style=\"top:'\n            + top.toString()\n            + 'px;left:'\n            + left.toString()\n            + 'px;width:'\n            + width.toString()\n            + 'px;height:'\n            + height\n            + 'px;\"></div>');\n    }\n    _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n        if (visibleRanges.length === 0) {\n            return;\n        }\n        const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;\n        const fullLineHeight = (this._lineHeight).toString();\n        const reducedLineHeight = (this._lineHeight - 1).toString();\n        const firstLineNumber = visibleRanges[0].lineNumber;\n        const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;\n        for (let i = 0, len = visibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = visibleRanges[i];\n            const lineNumber = lineVisibleRanges.lineNumber;\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;\n            const top = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;\n            let innerCornerOutput = '';\n            let restOfSelectionOutput = '';\n            for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n                const visibleRange = lineVisibleRanges.ranges[j];\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 1 /* CornerStyle.INTERN */ || startStyle.bottom === 1 /* CornerStyle.INTERN */) {\n                        // Reverse rounded corner to the left\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (startStyle.top === 1 /* CornerStyle.INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                        }\n                        if (startStyle.bottom === 1 /* CornerStyle.INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                    if (endStyle.top === 1 /* CornerStyle.INTERN */ || endStyle.bottom === 1 /* CornerStyle.INTERN */) {\n                        // Reverse rounded corner to the right\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (endStyle.top === 1 /* CornerStyle.INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                        }\n                        if (endStyle.bottom === 1 /* CornerStyle.INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                }\n                let className = SelectionsOverlay.SELECTION_CLASS_NAME;\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 0 /* CornerStyle.EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                    }\n                    if (startStyle.bottom === 0 /* CornerStyle.EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                    }\n                    if (endStyle.top === 0 /* CornerStyle.EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                    }\n                    if (endStyle.bottom === 0 /* CornerStyle.EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                    }\n                }\n                restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);\n            }\n            output2[lineIndex][0] += innerCornerOutput;\n            output2[lineIndex][1] += restOfSelectionOutput;\n        }\n    }\n    prepareRender(ctx) {\n        // Build HTML for inner corners separate from HTML for the rest of selections,\n        // as the inner corner HTML can interfere with that of other selections.\n        // In final render, make sure to place the inner corner HTML before the rest of selection HTML. See issue #77777.\n        const output = [];\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = ['', ''];\n        }\n        const thisFrameVisibleRangesWithStyle = [];\n        for (let i = 0, len = this._selections.length; i < len; i++) {\n            const selection = this._selections[i];\n            if (selection.isEmpty()) {\n                thisFrameVisibleRangesWithStyle[i] = null;\n                continue;\n            }\n            const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n            thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n            this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n        }\n        this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n        this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\nSelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\nSelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\nSelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\nSelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\nSelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\nSelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\nSelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\nregisterThemingParticipant((theme, collector) => {\n    const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n    if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {\n        collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);\n    }\n});\nfunction abs(n) {\n    return n < 0 ? -n : n;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}