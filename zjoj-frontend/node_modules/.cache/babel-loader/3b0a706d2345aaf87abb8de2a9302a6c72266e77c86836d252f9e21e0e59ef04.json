{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n  static createEmpty(lineContent, decoder) {\n    const defaultMetadata = LineTokens.defaultTokenMetadata;\n    const tokens = new Uint32Array(2);\n    tokens[0] = lineContent.length;\n    tokens[1] = defaultMetadata;\n    return new LineTokens(tokens, lineContent, decoder);\n  }\n  constructor(tokens, text, decoder) {\n    this._lineTokensBrand = undefined;\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n    this._languageIdCodec = decoder;\n  }\n  equals(other) {\n    if (other instanceof LineTokens) {\n      return this.slicedEquals(other, 0, this._tokensCount);\n    }\n    return false;\n  }\n  slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n    if (this._text !== other._text) {\n      return false;\n    }\n    if (this._tokensCount !== other._tokensCount) {\n      return false;\n    }\n    const from = sliceFromTokenIndex << 1;\n    const to = from + (sliceTokenCount << 1);\n    for (let i = from; i < to; i++) {\n      if (this._tokens[i] !== other._tokens[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  getLineContent() {\n    return this._text;\n  }\n  getCount() {\n    return this._tokensCount;\n  }\n  getStartOffset(tokenIndex) {\n    if (tokenIndex > 0) {\n      return this._tokens[tokenIndex - 1 << 1];\n    }\n    return 0;\n  }\n  getMetadata(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return metadata;\n  }\n  getLanguageId(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    const languageId = TokenMetadata.getLanguageId(metadata);\n    return this._languageIdCodec.decodeLanguageId(languageId);\n  }\n  getStandardTokenType(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getTokenType(metadata);\n  }\n  getForeground(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getForeground(metadata);\n  }\n  getClassName(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getClassNameFromMetadata(metadata);\n  }\n  getInlineStyle(tokenIndex, colorMap) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n  }\n  getPresentation(tokenIndex) {\n    const metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getPresentationFromMetadata(metadata);\n  }\n  getEndOffset(tokenIndex) {\n    return this._tokens[tokenIndex << 1];\n  }\n  /**\n   * Find the token containing offset `offset`.\n   * @param offset The search offset\n   * @return The index of the token containing the offset.\n   */\n  findTokenIndexAtOffset(offset) {\n    return LineTokens.findIndexInTokensArray(this._tokens, offset);\n  }\n  inflate() {\n    return this;\n  }\n  sliceAndInflate(startOffset, endOffset, deltaOffset) {\n    return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n  }\n  static convertToEndOffset(tokens, lineTextLength) {\n    const tokenCount = tokens.length >>> 1;\n    const lastTokenIndex = tokenCount - 1;\n    for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n    }\n    tokens[lastTokenIndex << 1] = lineTextLength;\n  }\n  static findIndexInTokensArray(tokens, desiredIndex) {\n    if (tokens.length <= 2) {\n      return 0;\n    }\n    let low = 0;\n    let high = (tokens.length >>> 1) - 1;\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2);\n      const endOffset = tokens[mid << 1];\n      if (endOffset === desiredIndex) {\n        return mid + 1;\n      } else if (endOffset < desiredIndex) {\n        low = mid + 1;\n      } else if (endOffset > desiredIndex) {\n        high = mid;\n      }\n    }\n    return low;\n  }\n  /**\n   * @pure\n   * @param insertTokens Must be sorted by offset.\n  */\n  withInserted(insertTokens) {\n    if (insertTokens.length === 0) {\n      return this;\n    }\n    let nextOriginalTokenIdx = 0;\n    let nextInsertTokenIdx = 0;\n    let text = '';\n    const newTokens = new Array();\n    let originalEndOffset = 0;\n    while (true) {\n      const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n      const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n      if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n        // original token ends before next insert token\n        text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n        const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n        newTokens.push(text.length, metadata);\n        nextOriginalTokenIdx++;\n        originalEndOffset = nextOriginalTokenEndOffset;\n      } else if (nextInsertToken) {\n        if (nextInsertToken.offset > originalEndOffset) {\n          // insert token is in the middle of the next token.\n          text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n          const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n          newTokens.push(text.length, metadata);\n          originalEndOffset = nextInsertToken.offset;\n        }\n        text += nextInsertToken.text;\n        newTokens.push(text.length, nextInsertToken.tokenMetadata);\n        nextInsertTokenIdx++;\n      } else {\n        break;\n      }\n    }\n    return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n  }\n}\nLineTokens.defaultTokenMetadata = (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | 1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | 2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */) >>> 0;\nclass SliceLineTokens {\n  constructor(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n    for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      const tokenStartOffset = source.getStartOffset(i);\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n      this._tokensCount++;\n    }\n  }\n  getMetadata(tokenIndex) {\n    return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n  }\n  getLanguageId(tokenIndex) {\n    return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n  }\n  getLineContent() {\n    return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n  }\n  equals(other) {\n    if (other instanceof SliceLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n    return false;\n  }\n  getCount() {\n    return this._tokensCount;\n  }\n  getForeground(tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  }\n  getEndOffset(tokenIndex) {\n    const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  }\n  getClassName(tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  }\n  getInlineStyle(tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  }\n  getPresentation(tokenIndex) {\n    return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n  }\n  findTokenIndexAtOffset(offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  }\n}","map":{"version":3,"names":["TokenMetadata","LineTokens","createEmpty","lineContent","decoder","defaultMetadata","defaultTokenMetadata","tokens","Uint32Array","length","constructor","text","_lineTokensBrand","undefined","_tokens","_tokensCount","_text","_languageIdCodec","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","metadata","getLanguageId","languageId","decodeLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SliceLineTokens","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","Array","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","substring","push","tokenMetadata","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n    | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n    | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}