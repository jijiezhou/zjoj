{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n  function is(thing) {\n    return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n  }\n  Iterable.is = is;\n  const _empty = Object.freeze([]);\n  function empty() {\n    return _empty;\n  }\n  Iterable.empty = empty;\n  function* single(element) {\n    yield element;\n  }\n  Iterable.single = single;\n  function wrap(iterableOrElement) {\n    if (is(iterableOrElement)) {\n      return iterableOrElement;\n    } else {\n      return single(iterableOrElement);\n    }\n  }\n  Iterable.wrap = wrap;\n  function from(iterable) {\n    return iterable || _empty;\n  }\n  Iterable.from = from;\n  function* reverse(array) {\n    for (let i = array.length - 1; i >= 0; i--) {\n      yield array[i];\n    }\n  }\n  Iterable.reverse = reverse;\n  function isEmpty(iterable) {\n    return !iterable || iterable[Symbol.iterator]().next().done === true;\n  }\n  Iterable.isEmpty = isEmpty;\n  function first(iterable) {\n    return iterable[Symbol.iterator]().next().value;\n  }\n  Iterable.first = first;\n  function some(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  Iterable.some = some;\n  function find(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return element;\n      }\n    }\n    return undefined;\n  }\n  Iterable.find = find;\n  function* filter(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        yield element;\n      }\n    }\n  }\n  Iterable.filter = filter;\n  function* map(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield fn(element, index++);\n    }\n  }\n  Iterable.map = map;\n  function* concat(...iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n  Iterable.concat = concat;\n  function reduce(iterable, reducer, initialValue) {\n    let value = initialValue;\n    for (const element of iterable) {\n      value = reducer(value, element);\n    }\n    return value;\n  }\n  Iterable.reduce = reduce;\n  /**\n   * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n   */\n  function* slice(arr, from, to = arr.length) {\n    if (from < 0) {\n      from += arr.length;\n    }\n    if (to < 0) {\n      to += arr.length;\n    } else if (to > arr.length) {\n      to = arr.length;\n    }\n    for (; from < to; from++) {\n      yield arr[from];\n    }\n  }\n  Iterable.slice = slice;\n  /**\n   * Consumes `atMost` elements from iterable and returns the consumed elements,\n   * and an iterable for the rest of the elements.\n   */\n  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n    const consumed = [];\n    if (atMost === 0) {\n      return [consumed, iterable];\n    }\n    const iterator = iterable[Symbol.iterator]();\n    for (let i = 0; i < atMost; i++) {\n      const next = iterator.next();\n      if (next.done) {\n        return [consumed, Iterable.empty()];\n      }\n      consumed.push(next.value);\n    }\n    return [consumed, {\n      [Symbol.iterator]() {\n        return iterator;\n      }\n    }];\n  }\n  Iterable.consume = consume;\n})(Iterable || (Iterable = {}));","map":{"version":3,"names":["Iterable","is","thing","Symbol","iterator","_empty","Object","freeze","empty","single","element","wrap","iterableOrElement","from","iterable","reverse","array","i","length","isEmpty","next","done","first","value","some","predicate","find","undefined","filter","map","fn","index","concat","iterables","reduce","reducer","initialValue","slice","arr","to","consume","atMost","Number","POSITIVE_INFINITY","consumed","push"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/iterator.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function wrap(iterableOrElement) {\n        if (is(iterableOrElement)) {\n            return iterableOrElement;\n        }\n        else {\n            return single(iterableOrElement);\n        }\n    }\n    Iterable.wrap = wrap;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function* reverse(array) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            yield array[i];\n        }\n    }\n    Iterable.reverse = reverse;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    Iterable.concat = concat;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n})(Iterable || (Iterable = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}