{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */;\n}\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254 /* Constants.ColorMaskInverse */ | color << 0 /* Constants.ColorOffset */;\n}\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */ === 1;\n}\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253 /* Constants.IsVisitedMaskInverse */ | (value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */;\n}\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */ === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251 /* Constants.IsForValidationMaskInverse */ | (value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */;\n}\nfunction getNodeIsInGlyphMargin(node) {\n  return (node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */ === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n  node.metadata = node.metadata & 191 /* Constants.IsMarginMaskInverse */ | (value ? 1 : 0) << 6 /* Constants.IsMarginOffset */;\n}\nfunction getNodeStickiness(node) {\n  return (node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */;\n}\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 231 /* Constants.StickinessMaskInverse */ | stickiness << 3 /* Constants.StickinessOffset */;\n}\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */ === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */ | (value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */;\n}\nexport class IntervalNode {\n  constructor(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1 /* NodeColor.Red */);\n    this.start = start;\n    this.end = end;\n    // FORCE_OVERFLOWING_TEST: this.delta = start;\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n    setNodeIsInGlyphMargin(this, false);\n    _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n  reset(versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  }\n  setOptions(options) {\n    this.options = options;\n    const className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */ || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */ || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */);\n    setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n    _setNodeStickiness(this, this.options.stickiness);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  }\n  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  }\n  detach() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n  constructor() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n  }\n  search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n  collectNodesFromOwner(ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n  collectNodesPostOrder() {\n    return collectNodesPostOrder(this);\n  }\n  insert(node) {\n    rbTreeInsert(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  delete(node) {\n    rbTreeDelete(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  resolveNode(node, cachedVersionId) {\n    const initialNode = node;\n    let delta = 0;\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n      node = node.parent;\n    }\n    const nodeStart = initialNode.start + delta;\n    const nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    const nodesOfInterest = searchForEditing(this, offset, offset + length);\n    // (2) remove all nodes that are intersecting this edit\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n    // (3) edit all tree nodes except the nodes of interest\n    noOverlapReplace(this, offset, offset + length, textLength);\n    this._normalizeDeltaIfNecessary();\n    // (4) edit the nodes of interest and insert them back in the tree\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n  }\n  _normalizeDeltaIfNecessary() {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n  let node = T.root;\n  let delta = 0;\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true);\n    // going up from this node\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n    node = node.parent;\n  }\n  setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n  if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n    return false;\n  }\n  if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n    return true;\n  }\n  return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  const nodeStickiness = getNodeStickiness(node);\n  const startStickToPreviousCharacter = nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  const endStickToPreviousCharacter = nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  const deletingCnt = end - start;\n  const insertingCnt = textLength;\n  const commonLength = Math.min(deletingCnt, insertingCnt);\n  const nodeStart = node.start;\n  let startDone = false;\n  const nodeEnd = node.end;\n  let endDone = false;\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  if (commonLength > 0 && !forceMoveMarkers) {\n    const moveSemantics = deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  }\n  // Finish\n  const deltaColumn = insertingCnt - deletingCnt;\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  const editDelta = textLength - (end - start);\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n      if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n      }\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction collectNodesPostOrder(T) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n  let node = T.root;\n  let delta = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    let include = true;\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n    if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n      include = false;\n    }\n    if (include) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      let include = true;\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n      if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n        include = false;\n      }\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0 /* NodeColor.Black */);\n    T.root = newNode;\n    return T.root;\n  }\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent);\n  // repair tree\n  let x = newNode;\n  while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n    if (x.parent === x.parent.parent.left) {\n      const y = x.parent.parent.right;\n      if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      const y = x.parent.parent.left;\n      if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n  setNodeColor(T.root, 0 /* NodeColor.Black */);\n  return newNode;\n}\nfunction treeInsert(T, z) {\n  let delta = 0;\n  let x = T.root;\n  const zAbsoluteStart = z.start;\n  const zAbsoluteEnd = z.end;\n  while (true) {\n    const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n  let x;\n  let y;\n  // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z;\n    // x's delta is no longer influenced by z's delta\n    x.delta += z.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n    // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n  const yWasRed = getNodeColor(y) === 1 /* NodeColor.Red */;\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n  z.detach();\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n    resetSentinel();\n    return;\n  }\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  }\n  // RB-DELETE-FIXUP\n  let w;\n  while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.left, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.right, 0 /* NodeColor.Black */);\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.right, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.left, 0 /* NodeColor.Black */);\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n  setNodeColor(x, 0 /* NodeColor.Black */);\n  resetSentinel();\n}\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n  return node;\n}\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n  SENTINEL.start = 0; // optional\n  SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n  const y = x.right; // set y.\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent; // link x's parent to y.\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x; // put x on y's left.\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n  const x = y.left;\n  y.delta -= x.delta;\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n  let maxEnd = node.end;\n  if (node.left !== SENTINEL) {\n    const leftMaxEnd = node.left.maxEnd;\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n  if (node.right !== SENTINEL) {\n    const rightMaxEnd = node.right.maxEnd + node.delta;\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n  return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    const maxEnd = computeMaxEnd(node);\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n  return aStart - bStart;\n}\n//#endregion","map":{"version":3,"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","constructor","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","reset","versionId","setOptions","className","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","onlyMarginDecorations","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}