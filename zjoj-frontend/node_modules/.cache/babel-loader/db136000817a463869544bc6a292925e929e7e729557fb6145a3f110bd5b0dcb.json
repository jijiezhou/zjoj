{"ast":null,"code":"import { ref, computed, onMounted } from \"vue\";\nconst useSize = ({\n  dataKeys,\n  contentRef,\n  fixedSize,\n  estimatedSize,\n  buffer\n}) => {\n  const firstRangeAverageSize = ref(0);\n  const sizeMap = new Map();\n  const total = computed(() => dataKeys.value.length);\n  const start = ref(0);\n  const end = computed(() => {\n    const _end = start.value + buffer.value * 3;\n    if (_end > total.value) return total.value;\n    return _end;\n  });\n  const maxStart = computed(() => {\n    const max = total.value - buffer.value * 3;\n    if (max < 0) return 0;\n    return max;\n  });\n  const setStart = index => {\n    if (index < 0) {\n      start.value = 0;\n    } else if (index > maxStart.value) {\n      start.value = maxStart.value;\n    } else {\n      start.value = index;\n    }\n  };\n  const isFixed = ref(fixedSize.value);\n  const _estimatedSize = computed(() => {\n    if (estimatedSize.value !== 30) {\n      return estimatedSize.value;\n    }\n    return firstRangeAverageSize.value || estimatedSize.value;\n  });\n  const setItemSize = (key, size) => {\n    sizeMap.set(key, size);\n  };\n  const getItemSize = index => {\n    var _a;\n    if (isFixed.value) {\n      return _estimatedSize.value;\n    }\n    const _key = dataKeys.value[index];\n    return (_a = sizeMap.get(_key)) != null ? _a : _estimatedSize.value;\n  };\n  const hasItemSize = key => {\n    return sizeMap.has(key);\n  };\n  onMounted(() => {\n    const firstRangeTotalSize = Array.from(sizeMap.values()).reduce((pre, value) => pre + value, 0);\n    if (firstRangeTotalSize > 0) {\n      firstRangeAverageSize.value = firstRangeTotalSize / sizeMap.size;\n    }\n  });\n  const getScrollOffset = index => {\n    if (isFixed.value) {\n      return _estimatedSize.value * index;\n    }\n    return getOffset(0, index);\n  };\n  const getOffset = (start2, end2) => {\n    let offset = 0;\n    for (let i = start2; i < end2; i++) {\n      offset += getItemSize(i);\n    }\n    return offset;\n  };\n  const frontPadding = computed(() => {\n    if (isFixed.value) {\n      return _estimatedSize.value * start.value;\n    }\n    return getOffset(0, start.value);\n  });\n  const getOffsetIndex = scrollOffset => {\n    const isForward = scrollOffset >= frontPadding.value;\n    let offset = Math.abs(scrollOffset - frontPadding.value);\n    const _start = isForward ? start.value : start.value - 1;\n    let offsetIndex = 0;\n    while (offset > 0) {\n      offset -= getItemSize(_start + offsetIndex);\n      isForward ? offsetIndex++ : offsetIndex--;\n    }\n    return offsetIndex;\n  };\n  const getStartByScroll = scrollOffset => {\n    const offsetIndex = getOffsetIndex(scrollOffset);\n    const _start = start.value + offsetIndex - buffer.value;\n    if (_start < 0) return 0;\n    if (_start > maxStart.value) return maxStart.value;\n    return _start;\n  };\n  const behindPadding = computed(() => {\n    if (isFixed.value) {\n      return _estimatedSize.value * (total.value - end.value);\n    }\n    return getOffset(end.value, total.value);\n  });\n  return {\n    frontPadding,\n    behindPadding,\n    start,\n    end,\n    getStartByScroll,\n    setItemSize,\n    hasItemSize,\n    setStart,\n    getScrollOffset\n  };\n};\nexport { useSize };","map":{"version":3,"names":["ref","computed","onMounted","useSize","dataKeys","contentRef","fixedSize","estimatedSize","buffer","firstRangeAverageSize","sizeMap","Map","total","value","length","start","end","_end","maxStart","max","setStart","index","isFixed","_estimatedSize","setItemSize","key","size","set","getItemSize","_a","_key","get","hasItemSize","has","firstRangeTotalSize","Array","from","values","reduce","pre","getScrollOffset","getOffset","start2","end2","offset","i","frontPadding","getOffsetIndex","scrollOffset","isForward","Math","abs","_start","offsetIndex","getStartByScroll","behindPadding"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/@arco-design/web-vue/es/_components/virtual-list-v2/hooks/use-size.js"],"sourcesContent":["import { ref, computed, onMounted } from \"vue\";\nconst useSize = ({\n  dataKeys,\n  contentRef,\n  fixedSize,\n  estimatedSize,\n  buffer\n}) => {\n  const firstRangeAverageSize = ref(0);\n  const sizeMap = new Map();\n  const total = computed(() => dataKeys.value.length);\n  const start = ref(0);\n  const end = computed(() => {\n    const _end = start.value + buffer.value * 3;\n    if (_end > total.value)\n      return total.value;\n    return _end;\n  });\n  const maxStart = computed(() => {\n    const max = total.value - buffer.value * 3;\n    if (max < 0)\n      return 0;\n    return max;\n  });\n  const setStart = (index) => {\n    if (index < 0) {\n      start.value = 0;\n    } else if (index > maxStart.value) {\n      start.value = maxStart.value;\n    } else {\n      start.value = index;\n    }\n  };\n  const isFixed = ref(fixedSize.value);\n  const _estimatedSize = computed(() => {\n    if (estimatedSize.value !== 30) {\n      return estimatedSize.value;\n    }\n    return firstRangeAverageSize.value || estimatedSize.value;\n  });\n  const setItemSize = (key, size) => {\n    sizeMap.set(key, size);\n  };\n  const getItemSize = (index) => {\n    var _a;\n    if (isFixed.value) {\n      return _estimatedSize.value;\n    }\n    const _key = dataKeys.value[index];\n    return (_a = sizeMap.get(_key)) != null ? _a : _estimatedSize.value;\n  };\n  const hasItemSize = (key) => {\n    return sizeMap.has(key);\n  };\n  onMounted(() => {\n    const firstRangeTotalSize = Array.from(sizeMap.values()).reduce((pre, value) => pre + value, 0);\n    if (firstRangeTotalSize > 0) {\n      firstRangeAverageSize.value = firstRangeTotalSize / sizeMap.size;\n    }\n  });\n  const getScrollOffset = (index) => {\n    if (isFixed.value) {\n      return _estimatedSize.value * index;\n    }\n    return getOffset(0, index);\n  };\n  const getOffset = (start2, end2) => {\n    let offset = 0;\n    for (let i = start2; i < end2; i++) {\n      offset += getItemSize(i);\n    }\n    return offset;\n  };\n  const frontPadding = computed(() => {\n    if (isFixed.value) {\n      return _estimatedSize.value * start.value;\n    }\n    return getOffset(0, start.value);\n  });\n  const getOffsetIndex = (scrollOffset) => {\n    const isForward = scrollOffset >= frontPadding.value;\n    let offset = Math.abs(scrollOffset - frontPadding.value);\n    const _start = isForward ? start.value : start.value - 1;\n    let offsetIndex = 0;\n    while (offset > 0) {\n      offset -= getItemSize(_start + offsetIndex);\n      isForward ? offsetIndex++ : offsetIndex--;\n    }\n    return offsetIndex;\n  };\n  const getStartByScroll = (scrollOffset) => {\n    const offsetIndex = getOffsetIndex(scrollOffset);\n    const _start = start.value + offsetIndex - buffer.value;\n    if (_start < 0)\n      return 0;\n    if (_start > maxStart.value)\n      return maxStart.value;\n    return _start;\n  };\n  const behindPadding = computed(() => {\n    if (isFixed.value) {\n      return _estimatedSize.value * (total.value - end.value);\n    }\n    return getOffset(end.value, total.value);\n  });\n  return {\n    frontPadding,\n    behindPadding,\n    start,\n    end,\n    getStartByScroll,\n    setItemSize,\n    hasItemSize,\n    setStart,\n    getScrollOffset\n  };\n};\nexport { useSize };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}