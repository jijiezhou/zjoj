{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\n// util definitions to make working with the above types easier within this module:\nexport const NoMatchingKb = {\n  kind: 0 /* ResultKind.NoMatchingKb */\n};\nconst MoreChordsNeeded = {\n  kind: 1 /* ResultKind.MoreChordsNeeded */\n};\nfunction KbFound(commandId, commandArgs, isBubble) {\n  return {\n    kind: 2 /* ResultKind.KbFound */,\n    commandId,\n    commandArgs,\n    isBubble\n  };\n}\n//#endregion\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n  constructor( /** built-in and extension-provided keybindings */\n  defaultKeybindings, /** user's keybindings */\n  overrides, log) {\n    var _a;\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n    for (const defaultKeybinding of defaultKeybindings) {\n      const command = defaultKeybinding.command;\n      if (command && command.charAt(0) !== '-') {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n    for (let i = 0, len = this._keybindings.length; i < len; i++) {\n      const k = this._keybindings[i];\n      if (k.chords.length === 0) {\n        // unbound\n        continue;\n      }\n      // substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n      const when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();\n      if (when && when.type === 0 /* ContextKeyExprType.False */) {\n        // when condition is false\n        continue;\n      }\n      this._addKeyPress(k.chords[0], k);\n    }\n  }\n  static _isTargetedForRemoval(defaultKb, keypress, when) {\n    if (keypress) {\n      for (let i = 0; i < keypress.length; i++) {\n        if (keypress[i] !== defaultKb.chords[i]) {\n          return false;\n        }\n      }\n    }\n    // `true` means always, as does `undefined`\n    // so we will treat `true` === `undefined`\n    if (when && when.type !== 1 /* ContextKeyExprType.True */) {\n      if (!defaultKb.when) {\n        return false;\n      }\n      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Looks for rules containing \"-commandId\" and removes them.\n   */\n  static handleRemovals(rules) {\n    // Do a first pass and construct a hash-map for removals\n    const removals = new Map();\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n      if (rule.command && rule.command.charAt(0) === '-') {\n        const command = rule.command.substring(1);\n        if (!removals.has(command)) {\n          removals.set(command, [rule]);\n        } else {\n          removals.get(command).push(rule);\n        }\n      }\n    }\n    if (removals.size === 0) {\n      // There are no removals\n      return rules;\n    }\n    // Do a second pass and keep only non-removed keybindings\n    const result = [];\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n      if (!rule.command || rule.command.length === 0) {\n        result.push(rule);\n        continue;\n      }\n      if (rule.command.charAt(0) === '-') {\n        continue;\n      }\n      const commandRemovals = removals.get(rule.command);\n      if (!commandRemovals || !rule.isDefault) {\n        result.push(rule);\n        continue;\n      }\n      let isRemoved = false;\n      for (const commandRemoval of commandRemovals) {\n        const when = commandRemoval.when;\n        if (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n          isRemoved = true;\n          break;\n        }\n      }\n      if (!isRemoved) {\n        result.push(rule);\n        continue;\n      }\n    }\n    return result;\n  }\n  _addKeyPress(keypress, item) {\n    const conflicts = this._map.get(keypress);\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n      this._addToLookupMap(item);\n      return;\n    }\n    for (let i = conflicts.length - 1; i >= 0; i--) {\n      const conflict = conflicts[i];\n      if (conflict.command === item.command) {\n        continue;\n      }\n      // Test if the shorter keybinding is a prefix of the longer one.\n      // If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n      let isShorterKbPrefix = true;\n      for (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n        if (conflict.chords[i] !== item.chords[i]) {\n          // The ith step does not conflict\n          isShorterKbPrefix = false;\n          break;\n        }\n      }\n      if (!isShorterKbPrefix) {\n        continue;\n      }\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n    conflicts.push(item);\n    this._addToLookupMap(item);\n  }\n  _addToLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    let arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      arr = [item];\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  }\n  _removeFromLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    const arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      return;\n    }\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Returns true if it is provable `a` implies `b`.\n   */\n  static whenIsEntirelyIncluded(a, b) {\n    if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n      return true;\n    }\n    if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n      return false;\n    }\n    return implies(a, b);\n  }\n  getKeybindings() {\n    return this._keybindings;\n  }\n  lookupPrimaryKeybinding(commandId, context) {\n    const items = this._lookupMap.get(commandId);\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n    if (items.length === 1) {\n      return items[0];\n    }\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      if (context.contextMatchesRules(item.when)) {\n        return item;\n      }\n    }\n    return items[items.length - 1];\n  }\n  /**\n   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n   *\n   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n   * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n   */\n  resolve(context, currentChords, keypress) {\n    const pressedChords = [...currentChords, keypress];\n    this._log(`| Resolving ${pressedChords}`);\n    const kbCandidates = this._map.get(pressedChords[0]);\n    if (kbCandidates === undefined) {\n      // No bindings with such 0-th chord\n      this._log(`\\\\ No keybinding entries.`);\n      return NoMatchingKb;\n    }\n    let lookupMap = null;\n    if (pressedChords.length < 2) {\n      lookupMap = kbCandidates;\n    } else {\n      // Fetch all chord bindings for `currentChords`\n      lookupMap = [];\n      for (let i = 0, len = kbCandidates.length; i < len; i++) {\n        const candidate = kbCandidates[i];\n        if (pressedChords.length > candidate.chords.length) {\n          // # of pressed chords can't be less than # of chords in a keybinding to invoke\n          continue;\n        }\n        let prefixMatches = true;\n        for (let i = 1; i < pressedChords.length; i++) {\n          if (candidate.chords[i] !== pressedChords[i]) {\n            prefixMatches = false;\n            break;\n          }\n        }\n        if (prefixMatches) {\n          lookupMap.push(candidate);\n        }\n      }\n    }\n    // check there's a keybinding with a matching when clause\n    const result = this._findCommand(context, lookupMap);\n    if (!result) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n      return NoMatchingKb;\n    }\n    // check we got all chords necessary to be sure a particular keybinding needs to be invoked\n    if (pressedChords.length < result.chords.length) {\n      // The chord sequence is not complete\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n      return MoreChordsNeeded;\n    }\n    this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n    return KbFound(result.command, result.commandArgs, result.bubble);\n  }\n  _findCommand(context, matches) {\n    for (let i = matches.length - 1; i >= 0; i--) {\n      const k = matches[i];\n      if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n        continue;\n      }\n      return k;\n    }\n    return null;\n  }\n  static _contextMatchesRules(context, rules) {\n    if (!rules) {\n      return true;\n    }\n    return rules.evaluate(context);\n  }\n}\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return `no when condition`;\n  }\n  return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;\n}","map":{"version":3,"names":["implies","expressionsAreEqualWithConstantSubstitution","NoMatchingKb","kind","MoreChordsNeeded","KbFound","commandId","commandArgs","isBubble","KeybindingResolver","constructor","defaultKeybindings","overrides","log","_a","_log","_defaultKeybindings","_defaultBoundCommands","Map","defaultKeybinding","command","charAt","set","_map","_lookupMap","_keybindings","handleRemovals","concat","i","len","length","k","chords","when","substituteConstants","type","_addKeyPress","_isTargetedForRemoval","defaultKb","keypress","rules","removals","rule","substring","has","get","push","size","result","commandRemovals","isDefault","isRemoved","commandRemoval","item","conflicts","_addToLookupMap","conflict","isShorterKbPrefix","whenIsEntirelyIncluded","_removeFromLookupMap","arr","splice","a","b","getKeybindings","lookupPrimaryKeybinding","context","items","contextMatchesRules","resolve","currentChords","pressedChords","kbCandidates","undefined","lookupMap","candidate","prefixMatches","_findCommand","printWhenExplanation","printSourceExplanation","bubble","matches","_contextMatchesRules","evaluate","serialize","kb","extensionId","isBuiltinExtension"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\n// util definitions to make working with the above types easier within this module:\nexport const NoMatchingKb = { kind: 0 /* ResultKind.NoMatchingKb */ };\nconst MoreChordsNeeded = { kind: 1 /* ResultKind.MoreChordsNeeded */ };\nfunction KbFound(commandId, commandArgs, isBubble) {\n    return { kind: 2 /* ResultKind.KbFound */, commandId, commandArgs, isBubble };\n}\n//#endregion\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n    constructor(\n    /** built-in and extension-provided keybindings */\n    defaultKeybindings, \n    /** user's keybindings */\n    overrides, log) {\n        var _a;\n        this._log = log;\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (const defaultKeybinding of defaultKeybindings) {\n            const command = defaultKeybinding.command;\n            if (command && command.charAt(0) !== '-') {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\n            const k = this._keybindings[i];\n            if (k.chords.length === 0) {\n                // unbound\n                continue;\n            }\n            // substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n            const when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();\n            if (when && when.type === 0 /* ContextKeyExprType.False */) {\n                // when condition is false\n                continue;\n            }\n            this._addKeyPress(k.chords[0], k);\n        }\n    }\n    static _isTargetedForRemoval(defaultKb, keypress, when) {\n        if (keypress) {\n            for (let i = 0; i < keypress.length; i++) {\n                if (keypress[i] !== defaultKb.chords[i]) {\n                    return false;\n                }\n            }\n        }\n        // `true` means always, as does `undefined`\n        // so we will treat `true` === `undefined`\n        if (when && when.type !== 1 /* ContextKeyExprType.True */) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Looks for rules containing \"-commandId\" and removes them.\n     */\n    static handleRemovals(rules) {\n        // Do a first pass and construct a hash-map for removals\n        const removals = new Map();\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (rule.command && rule.command.charAt(0) === '-') {\n                const command = rule.command.substring(1);\n                if (!removals.has(command)) {\n                    removals.set(command, [rule]);\n                }\n                else {\n                    removals.get(command).push(rule);\n                }\n            }\n        }\n        if (removals.size === 0) {\n            // There are no removals\n            return rules;\n        }\n        // Do a second pass and keep only non-removed keybindings\n        const result = [];\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (!rule.command || rule.command.length === 0) {\n                result.push(rule);\n                continue;\n            }\n            if (rule.command.charAt(0) === '-') {\n                continue;\n            }\n            const commandRemovals = removals.get(rule.command);\n            if (!commandRemovals || !rule.isDefault) {\n                result.push(rule);\n                continue;\n            }\n            let isRemoved = false;\n            for (const commandRemoval of commandRemovals) {\n                const when = commandRemoval.when;\n                if (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n                    isRemoved = true;\n                    break;\n                }\n            }\n            if (!isRemoved) {\n                result.push(rule);\n                continue;\n            }\n        }\n        return result;\n    }\n    _addKeyPress(keypress, item) {\n        const conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (let i = conflicts.length - 1; i >= 0; i--) {\n            const conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            // Test if the shorter keybinding is a prefix of the longer one.\n            // If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n            let isShorterKbPrefix = true;\n            for (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n                if (conflict.chords[i] !== item.chords[i]) {\n                    // The ith step does not conflict\n                    isShorterKbPrefix = false;\n                    break;\n                }\n            }\n            if (!isShorterKbPrefix) {\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    }\n    _addToLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    }\n    _removeFromLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        const arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n    static whenIsEntirelyIncluded(a, b) {\n        if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n            return true;\n        }\n        if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n            return false;\n        }\n        return implies(a, b);\n    }\n    getKeybindings() {\n        return this._keybindings;\n    }\n    lookupPrimaryKeybinding(commandId, context) {\n        const items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        if (items.length === 1) {\n            return items[0];\n        }\n        for (let i = items.length - 1; i >= 0; i--) {\n            const item = items[i];\n            if (context.contextMatchesRules(item.when)) {\n                return item;\n            }\n        }\n        return items[items.length - 1];\n    }\n    /**\n     * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n     *\n     * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n     * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n     */\n    resolve(context, currentChords, keypress) {\n        const pressedChords = [...currentChords, keypress];\n        this._log(`| Resolving ${pressedChords}`);\n        const kbCandidates = this._map.get(pressedChords[0]);\n        if (kbCandidates === undefined) {\n            // No bindings with such 0-th chord\n            this._log(`\\\\ No keybinding entries.`);\n            return NoMatchingKb;\n        }\n        let lookupMap = null;\n        if (pressedChords.length < 2) {\n            lookupMap = kbCandidates;\n        }\n        else {\n            // Fetch all chord bindings for `currentChords`\n            lookupMap = [];\n            for (let i = 0, len = kbCandidates.length; i < len; i++) {\n                const candidate = kbCandidates[i];\n                if (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n                    continue;\n                }\n                let prefixMatches = true;\n                for (let i = 1; i < pressedChords.length; i++) {\n                    if (candidate.chords[i] !== pressedChords[i]) {\n                        prefixMatches = false;\n                        break;\n                    }\n                }\n                if (prefixMatches) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        // check there's a keybinding with a matching when clause\n        const result = this._findCommand(context, lookupMap);\n        if (!result) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n            return NoMatchingKb;\n        }\n        // check we got all chords necessary to be sure a particular keybinding needs to be invoked\n        if (pressedChords.length < result.chords.length) {\n            // The chord sequence is not complete\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n            return MoreChordsNeeded;\n        }\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n        return KbFound(result.command, result.commandArgs, result.bubble);\n    }\n    _findCommand(context, matches) {\n        for (let i = matches.length - 1; i >= 0; i--) {\n            const k = matches[i];\n            if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    }\n    static _contextMatchesRules(context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    }\n}\nfunction printWhenExplanation(when) {\n    if (!when) {\n        return `no when condition`;\n    }\n    return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n    return (kb.extensionId\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n        : (kb.isDefault ? `built-in` : `user`));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}