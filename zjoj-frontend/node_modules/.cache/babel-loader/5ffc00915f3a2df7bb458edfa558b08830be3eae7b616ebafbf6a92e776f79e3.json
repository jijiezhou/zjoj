{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalState } from '../../../base/common/errors.js';\nimport { localize } from '../../../nls.js';\nfunction hintDidYouMean(...meant) {\n  switch (meant.length) {\n    case 1:\n      return localize('contextkey.scanner.hint.didYouMean1', \"Did you mean {0}?\", meant[0]);\n    case 2:\n      return localize('contextkey.scanner.hint.didYouMean2', \"Did you mean {0} or {1}?\", meant[0], meant[1]);\n    case 3:\n      return localize('contextkey.scanner.hint.didYouMean3', \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]);\n    default:\n      // we just don't expect that many\n      return undefined;\n  }\n}\nconst hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', \"Did you forget to open or close the quote?\");\nconst hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\");\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n  constructor() {\n    this._input = '';\n    this._start = 0;\n    this._current = 0;\n    this._tokens = [];\n    this._errors = [];\n    // u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n    this.stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n  }\n  static getLexeme(token) {\n    switch (token.type) {\n      case 0 /* TokenType.LParen */:\n        return '(';\n      case 1 /* TokenType.RParen */:\n        return ')';\n      case 2 /* TokenType.Neg */:\n        return '!';\n      case 3 /* TokenType.Eq */:\n        return token.isTripleEq ? '===' : '==';\n      case 4 /* TokenType.NotEq */:\n        return token.isTripleEq ? '!==' : '!=';\n      case 5 /* TokenType.Lt */:\n        return '<';\n      case 6 /* TokenType.LtEq */:\n        return '<=';\n      case 7 /* TokenType.Gt */:\n        return '>=';\n      case 8 /* TokenType.GtEq */:\n        return '>=';\n      case 9 /* TokenType.RegexOp */:\n        return '=~';\n      case 10 /* TokenType.RegexStr */:\n        return token.lexeme;\n      case 11 /* TokenType.True */:\n        return 'true';\n      case 12 /* TokenType.False */:\n        return 'false';\n      case 13 /* TokenType.In */:\n        return 'in';\n      case 14 /* TokenType.Not */:\n        return 'not';\n      case 15 /* TokenType.And */:\n        return '&&';\n      case 16 /* TokenType.Or */:\n        return '||';\n      case 17 /* TokenType.Str */:\n        return token.lexeme;\n      case 18 /* TokenType.QuotedStr */:\n        return token.lexeme;\n      case 19 /* TokenType.Error */:\n        return token.lexeme;\n      case 20 /* TokenType.EOF */:\n        return 'EOF';\n      default:\n        throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n    }\n  }\n  reset(value) {\n    this._input = value;\n    this._start = 0;\n    this._current = 0;\n    this._tokens = [];\n    this._errors = [];\n    return this;\n  }\n  scan() {\n    while (!this._isAtEnd()) {\n      this._start = this._current;\n      const ch = this._advance();\n      switch (ch) {\n        case 40 /* CharCode.OpenParen */:\n          this._addToken(0 /* TokenType.LParen */);\n          break;\n        case 41 /* CharCode.CloseParen */:\n          this._addToken(1 /* TokenType.RParen */);\n          break;\n        case 33 /* CharCode.ExclamationMark */:\n          if (this._match(61 /* CharCode.Equals */)) {\n            const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `!==`\n            this._tokens.push({\n              type: 4 /* TokenType.NotEq */,\n              offset: this._start,\n              isTripleEq\n            });\n          } else {\n            this._addToken(2 /* TokenType.Neg */);\n          }\n          break;\n        case 39 /* CharCode.SingleQuote */:\n          this._quotedString();\n          break;\n        case 47 /* CharCode.Slash */:\n          this._regex();\n          break;\n        case 61 /* CharCode.Equals */:\n          if (this._match(61 /* CharCode.Equals */)) {\n            // support `==`\n            const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `===`\n            this._tokens.push({\n              type: 3 /* TokenType.Eq */,\n              offset: this._start,\n              isTripleEq\n            });\n          } else if (this._match(126 /* CharCode.Tilde */)) {\n            this._addToken(9 /* TokenType.RegexOp */);\n          } else {\n            this._error(hintDidYouMean('==', '=~'));\n          }\n          break;\n        case 60 /* CharCode.LessThan */:\n          this._addToken(this._match(61 /* CharCode.Equals */) ? 6 /* TokenType.LtEq */ : 5 /* TokenType.Lt */);\n          break;\n        case 62 /* CharCode.GreaterThan */:\n          this._addToken(this._match(61 /* CharCode.Equals */) ? 8 /* TokenType.GtEq */ : 7 /* TokenType.Gt */);\n          break;\n        case 38 /* CharCode.Ampersand */:\n          if (this._match(38 /* CharCode.Ampersand */)) {\n            this._addToken(15 /* TokenType.And */);\n          } else {\n            this._error(hintDidYouMean('&&'));\n          }\n          break;\n        case 124 /* CharCode.Pipe */:\n          if (this._match(124 /* CharCode.Pipe */)) {\n            this._addToken(16 /* TokenType.Or */);\n          } else {\n            this._error(hintDidYouMean('||'));\n          }\n          break;\n        // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n        case 32 /* CharCode.Space */:\n        case 13 /* CharCode.CarriageReturn */:\n        case 9 /* CharCode.Tab */:\n        case 10 /* CharCode.LineFeed */:\n        case 160 /* CharCode.NoBreakSpace */:\n          // &nbsp\n          break;\n        default:\n          this._string();\n      }\n    }\n    this._start = this._current;\n    this._addToken(20 /* TokenType.EOF */);\n    return Array.from(this._tokens);\n  }\n  _match(expected) {\n    if (this._isAtEnd()) {\n      return false;\n    }\n    if (this._input.charCodeAt(this._current) !== expected) {\n      return false;\n    }\n    this._current++;\n    return true;\n  }\n  _advance() {\n    return this._input.charCodeAt(this._current++);\n  }\n  _peek() {\n    return this._isAtEnd() ? 0 /* CharCode.Null */ : this._input.charCodeAt(this._current);\n  }\n  _addToken(type) {\n    this._tokens.push({\n      type,\n      offset: this._start\n    });\n  }\n  _error(additional) {\n    const offset = this._start;\n    const lexeme = this._input.substring(this._start, this._current);\n    const errToken = {\n      type: 19 /* TokenType.Error */,\n      offset: this._start,\n      lexeme\n    };\n    this._errors.push({\n      offset,\n      lexeme,\n      additionalInfo: additional\n    });\n    this._tokens.push(errToken);\n  }\n  _string() {\n    this.stringRe.lastIndex = this._start;\n    const match = this.stringRe.exec(this._input);\n    if (match) {\n      this._current = this._start + match[0].length;\n      const lexeme = this._input.substring(this._start, this._current);\n      const keyword = Scanner._keywords.get(lexeme);\n      if (keyword) {\n        this._addToken(keyword);\n      } else {\n        this._tokens.push({\n          type: 17 /* TokenType.Str */,\n          lexeme,\n          offset: this._start\n        });\n      }\n    }\n  }\n  // captures the lexeme without the leading and trailing '\n  _quotedString() {\n    while (this._peek() !== 39 /* CharCode.SingleQuote */ && !this._isAtEnd()) {\n      // TODO@ulugbekna: add support for escaping ' ?\n      this._advance();\n    }\n    if (this._isAtEnd()) {\n      this._error(hintDidYouForgetToOpenOrCloseQuote);\n      return;\n    }\n    // consume the closing '\n    this._advance();\n    this._tokens.push({\n      type: 18 /* TokenType.QuotedStr */,\n      lexeme: this._input.substring(this._start + 1, this._current - 1),\n      offset: this._start + 1\n    });\n  }\n  /*\n   * Lexing a regex expression: /.../[igsmyu]*\n   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n   *\n   * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n   */\n  _regex() {\n    let p = this._current;\n    let inEscape = false;\n    let inCharacterClass = false;\n    while (true) {\n      if (p >= this._input.length) {\n        this._current = p;\n        this._error(hintDidYouForgetToEscapeSlash);\n        return;\n      }\n      const ch = this._input.charCodeAt(p);\n      if (inEscape) {\n        // parsing an escape character\n        inEscape = false;\n      } else if (ch === 47 /* CharCode.Slash */ && !inCharacterClass) {\n        // end of regex\n        p++;\n        break;\n      } else if (ch === 91 /* CharCode.OpenSquareBracket */) {\n        inCharacterClass = true;\n      } else if (ch === 92 /* CharCode.Backslash */) {\n        inEscape = true;\n      } else if (ch === 93 /* CharCode.CloseSquareBracket */) {\n        inCharacterClass = false;\n      }\n      p++;\n    }\n    // Consume flags // TODO@ulugbekna: use regex instead\n    while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {\n      p++;\n    }\n    this._current = p;\n    const lexeme = this._input.substring(this._start, this._current);\n    this._tokens.push({\n      type: 10 /* TokenType.RegexStr */,\n      lexeme,\n      offset: this._start\n    });\n  }\n  _isAtEnd() {\n    return this._current >= this._input.length;\n  }\n}\nScanner._regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0)));\nScanner._keywords = new Map([['not', 14 /* TokenType.Not */], ['in', 13 /* TokenType.In */], ['false', 12 /* TokenType.False */], ['true', 11 /* TokenType.True */]]);","map":{"version":3,"names":["illegalState","localize","hintDidYouMean","meant","length","undefined","hintDidYouForgetToOpenOrCloseQuote","hintDidYouForgetToEscapeSlash","Scanner","constructor","_input","_start","_current","_tokens","_errors","stringRe","getLexeme","token","type","isTripleEq","lexeme","JSON","stringify","reset","value","scan","_isAtEnd","ch","_advance","_addToken","_match","push","offset","_quotedString","_regex","_error","_string","Array","from","expected","charCodeAt","_peek","additional","substring","errToken","additionalInfo","lastIndex","match","exec","keyword","_keywords","get","p","inEscape","inCharacterClass","_regexFlags","has","Set","map","Map"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalState } from '../../../base/common/errors.js';\nimport { localize } from '../../../nls.js';\nfunction hintDidYouMean(...meant) {\n    switch (meant.length) {\n        case 1:\n            return localize('contextkey.scanner.hint.didYouMean1', \"Did you mean {0}?\", meant[0]);\n        case 2:\n            return localize('contextkey.scanner.hint.didYouMean2', \"Did you mean {0} or {1}?\", meant[0], meant[1]);\n        case 3:\n            return localize('contextkey.scanner.hint.didYouMean3', \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]);\n        default: // we just don't expect that many\n            return undefined;\n    }\n}\nconst hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', \"Did you forget to open or close the quote?\");\nconst hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\");\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n    constructor() {\n        this._input = '';\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        // u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n        this.stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n    }\n    static getLexeme(token) {\n        switch (token.type) {\n            case 0 /* TokenType.LParen */:\n                return '(';\n            case 1 /* TokenType.RParen */:\n                return ')';\n            case 2 /* TokenType.Neg */:\n                return '!';\n            case 3 /* TokenType.Eq */:\n                return token.isTripleEq ? '===' : '==';\n            case 4 /* TokenType.NotEq */:\n                return token.isTripleEq ? '!==' : '!=';\n            case 5 /* TokenType.Lt */:\n                return '<';\n            case 6 /* TokenType.LtEq */:\n                return '<=';\n            case 7 /* TokenType.Gt */:\n                return '>=';\n            case 8 /* TokenType.GtEq */:\n                return '>=';\n            case 9 /* TokenType.RegexOp */:\n                return '=~';\n            case 10 /* TokenType.RegexStr */:\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                return 'true';\n            case 12 /* TokenType.False */:\n                return 'false';\n            case 13 /* TokenType.In */:\n                return 'in';\n            case 14 /* TokenType.Not */:\n                return 'not';\n            case 15 /* TokenType.And */:\n                return '&&';\n            case 16 /* TokenType.Or */:\n                return '||';\n            case 17 /* TokenType.Str */:\n                return token.lexeme;\n            case 18 /* TokenType.QuotedStr */:\n                return token.lexeme;\n            case 19 /* TokenType.Error */:\n                return token.lexeme;\n            case 20 /* TokenType.EOF */:\n                return 'EOF';\n            default:\n                throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n        }\n    }\n    reset(value) {\n        this._input = value;\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        return this;\n    }\n    scan() {\n        while (!this._isAtEnd()) {\n            this._start = this._current;\n            const ch = this._advance();\n            switch (ch) {\n                case 40 /* CharCode.OpenParen */:\n                    this._addToken(0 /* TokenType.LParen */);\n                    break;\n                case 41 /* CharCode.CloseParen */:\n                    this._addToken(1 /* TokenType.RParen */);\n                    break;\n                case 33 /* CharCode.ExclamationMark */:\n                    if (this._match(61 /* CharCode.Equals */)) {\n                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `!==`\n                        this._tokens.push({ type: 4 /* TokenType.NotEq */, offset: this._start, isTripleEq });\n                    }\n                    else {\n                        this._addToken(2 /* TokenType.Neg */);\n                    }\n                    break;\n                case 39 /* CharCode.SingleQuote */:\n                    this._quotedString();\n                    break;\n                case 47 /* CharCode.Slash */:\n                    this._regex();\n                    break;\n                case 61 /* CharCode.Equals */:\n                    if (this._match(61 /* CharCode.Equals */)) { // support `==`\n                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `===`\n                        this._tokens.push({ type: 3 /* TokenType.Eq */, offset: this._start, isTripleEq });\n                    }\n                    else if (this._match(126 /* CharCode.Tilde */)) {\n                        this._addToken(9 /* TokenType.RegexOp */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('==', '=~'));\n                    }\n                    break;\n                case 60 /* CharCode.LessThan */:\n                    this._addToken(this._match(61 /* CharCode.Equals */) ? 6 /* TokenType.LtEq */ : 5 /* TokenType.Lt */);\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    this._addToken(this._match(61 /* CharCode.Equals */) ? 8 /* TokenType.GtEq */ : 7 /* TokenType.Gt */);\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    if (this._match(38 /* CharCode.Ampersand */)) {\n                        this._addToken(15 /* TokenType.And */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('&&'));\n                    }\n                    break;\n                case 124 /* CharCode.Pipe */:\n                    if (this._match(124 /* CharCode.Pipe */)) {\n                        this._addToken(16 /* TokenType.Or */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('||'));\n                    }\n                    break;\n                // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n                case 32 /* CharCode.Space */:\n                case 13 /* CharCode.CarriageReturn */:\n                case 9 /* CharCode.Tab */:\n                case 10 /* CharCode.LineFeed */:\n                case 160 /* CharCode.NoBreakSpace */: // &nbsp\n                    break;\n                default:\n                    this._string();\n            }\n        }\n        this._start = this._current;\n        this._addToken(20 /* TokenType.EOF */);\n        return Array.from(this._tokens);\n    }\n    _match(expected) {\n        if (this._isAtEnd()) {\n            return false;\n        }\n        if (this._input.charCodeAt(this._current) !== expected) {\n            return false;\n        }\n        this._current++;\n        return true;\n    }\n    _advance() {\n        return this._input.charCodeAt(this._current++);\n    }\n    _peek() {\n        return this._isAtEnd() ? 0 /* CharCode.Null */ : this._input.charCodeAt(this._current);\n    }\n    _addToken(type) {\n        this._tokens.push({ type, offset: this._start });\n    }\n    _error(additional) {\n        const offset = this._start;\n        const lexeme = this._input.substring(this._start, this._current);\n        const errToken = { type: 19 /* TokenType.Error */, offset: this._start, lexeme };\n        this._errors.push({ offset, lexeme, additionalInfo: additional });\n        this._tokens.push(errToken);\n    }\n    _string() {\n        this.stringRe.lastIndex = this._start;\n        const match = this.stringRe.exec(this._input);\n        if (match) {\n            this._current = this._start + match[0].length;\n            const lexeme = this._input.substring(this._start, this._current);\n            const keyword = Scanner._keywords.get(lexeme);\n            if (keyword) {\n                this._addToken(keyword);\n            }\n            else {\n                this._tokens.push({ type: 17 /* TokenType.Str */, lexeme, offset: this._start });\n            }\n        }\n    }\n    // captures the lexeme without the leading and trailing '\n    _quotedString() {\n        while (this._peek() !== 39 /* CharCode.SingleQuote */ && !this._isAtEnd()) { // TODO@ulugbekna: add support for escaping ' ?\n            this._advance();\n        }\n        if (this._isAtEnd()) {\n            this._error(hintDidYouForgetToOpenOrCloseQuote);\n            return;\n        }\n        // consume the closing '\n        this._advance();\n        this._tokens.push({ type: 18 /* TokenType.QuotedStr */, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });\n    }\n    /*\n     * Lexing a regex expression: /.../[igsmyu]*\n     * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n     *\n     * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n     */\n    _regex() {\n        let p = this._current;\n        let inEscape = false;\n        let inCharacterClass = false;\n        while (true) {\n            if (p >= this._input.length) {\n                this._current = p;\n                this._error(hintDidYouForgetToEscapeSlash);\n                return;\n            }\n            const ch = this._input.charCodeAt(p);\n            if (inEscape) { // parsing an escape character\n                inEscape = false;\n            }\n            else if (ch === 47 /* CharCode.Slash */ && !inCharacterClass) { // end of regex\n                p++;\n                break;\n            }\n            else if (ch === 91 /* CharCode.OpenSquareBracket */) {\n                inCharacterClass = true;\n            }\n            else if (ch === 92 /* CharCode.Backslash */) {\n                inEscape = true;\n            }\n            else if (ch === 93 /* CharCode.CloseSquareBracket */) {\n                inCharacterClass = false;\n            }\n            p++;\n        }\n        // Consume flags // TODO@ulugbekna: use regex instead\n        while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {\n            p++;\n        }\n        this._current = p;\n        const lexeme = this._input.substring(this._start, this._current);\n        this._tokens.push({ type: 10 /* TokenType.RegexStr */, lexeme, offset: this._start });\n    }\n    _isAtEnd() {\n        return this._current >= this._input.length;\n    }\n}\nScanner._regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0)));\nScanner._keywords = new Map([\n    ['not', 14 /* TokenType.Not */],\n    ['in', 13 /* TokenType.In */],\n    ['false', 12 /* TokenType.False */],\n    ['true', 11 /* TokenType.True */],\n]);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}