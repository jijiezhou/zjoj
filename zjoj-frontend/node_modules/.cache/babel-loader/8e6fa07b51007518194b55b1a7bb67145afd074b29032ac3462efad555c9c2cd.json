{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n  static create(items, additionalItems) {\n    if (items <= 128 && additionalItems.length === 0) {\n      // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n      let cached = SmallImmutableSet.cache[items];\n      if (!cached) {\n        cached = new SmallImmutableSet(items, additionalItems);\n        SmallImmutableSet.cache[items] = cached;\n      }\n      return cached;\n    }\n    return new SmallImmutableSet(items, additionalItems);\n  }\n  static getEmpty() {\n    return this.empty;\n  }\n  constructor(items, additionalItems) {\n    this.items = items;\n    this.additionalItems = additionalItems;\n  }\n  add(value, keyProvider) {\n    const key = keyProvider.getKey(value);\n    let idx = key >> 5; // divided by 32\n    if (idx === 0) {\n      // fast path\n      const newItem = 1 << key | this.items;\n      if (newItem === this.items) {\n        return this;\n      }\n      return SmallImmutableSet.create(newItem, this.additionalItems);\n    }\n    idx--;\n    const newItems = this.additionalItems.slice(0);\n    while (newItems.length < idx) {\n      newItems.push(0);\n    }\n    newItems[idx] |= 1 << (key & 31);\n    return SmallImmutableSet.create(this.items, newItems);\n  }\n  merge(other) {\n    const merged = this.items | other.items;\n    if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n      // fast path\n      if (merged === this.items) {\n        return this;\n      }\n      if (merged === other.items) {\n        return other;\n      }\n      return SmallImmutableSet.create(merged, emptyArr);\n    }\n    // This can be optimized, but it's not a common case\n    const newItems = [];\n    for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n      const item1 = this.additionalItems[i] || 0;\n      const item2 = other.additionalItems[i] || 0;\n      newItems.push(item1 | item2);\n    }\n    return SmallImmutableSet.create(merged, newItems);\n  }\n  intersects(other) {\n    if ((this.items & other.items) !== 0) {\n      return true;\n    }\n    for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n      if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n  getKey(value) {\n    return value;\n  }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n  constructor() {\n    this.items = new Map();\n  }\n  getKey(value) {\n    let existing = this.items.get(value);\n    if (existing === undefined) {\n      existing = this.items.size;\n      this.items.set(value, existing);\n    }\n    return existing;\n  }\n}","map":{"version":3,"names":["emptyArr","SmallImmutableSet","create","items","additionalItems","length","cached","cache","getEmpty","empty","constructor","add","value","keyProvider","key","getKey","idx","newItem","newItems","slice","push","merge","other","merged","i","Math","max","item1","item2","intersects","min","Array","identityKeyProvider","DenseKeyProvider","Map","existing","get","undefined","size","set"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}