{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport class OneSnippet {\n  constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {\n    this._editor = _editor;\n    this._snippet = _snippet;\n    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n    this._offset = -1;\n    this._nestingLevel = 1;\n    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n  initialize(textChange) {\n    this._offset = textChange.newPosition;\n  }\n  dispose() {\n    if (this._placeholderDecorations) {\n      this._editor.removeDecorations([...this._placeholderDecorations.values()]);\n    }\n    this._placeholderGroups.length = 0;\n  }\n  _initDecorations() {\n    if (this._offset === -1) {\n      throw new Error(`Snippet not initialized!`);\n    }\n    if (this._placeholderDecorations) {\n      // already initialized\n      return;\n    }\n    this._placeholderDecorations = new Map();\n    const model = this._editor.getModel();\n    this._editor.changeDecorations(accessor => {\n      // create a decoration for each placeholder\n      for (const placeholder of this._snippet.placeholders) {\n        const placeholderOffset = this._snippet.offset(placeholder);\n        const placeholderLen = this._snippet.fullLen(placeholder);\n        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n        const handle = accessor.addDecoration(range, options);\n        this._placeholderDecorations.set(placeholder, handle);\n      }\n    });\n  }\n  move(fwd) {\n    if (!this._editor.hasModel()) {\n      return [];\n    }\n    this._initDecorations();\n    // Transform placeholder text if necessary\n    if (this._placeholderGroupsIdx >= 0) {\n      const operations = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        // Check if the placeholder has a transformation\n        if (placeholder.transform) {\n          const id = this._placeholderDecorations.get(placeholder);\n          const range = this._editor.getModel().getDecorationRange(id);\n          const currentValue = this._editor.getModel().getValueInRange(range);\n          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n          // fix indentation for transformed lines\n          for (let i = 1; i < transformedValueLines.length; i++) {\n            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n          }\n          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n        }\n      }\n      if (operations.length > 0) {\n        this._editor.executeEdits('snippet.placeholderTransform', operations);\n      }\n    }\n    let couldSkipThisPlaceholder = false;\n    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n      this._placeholderGroupsIdx += 1;\n      couldSkipThisPlaceholder = true;\n    } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n      this._placeholderGroupsIdx -= 1;\n      couldSkipThisPlaceholder = true;\n    } else {\n      // the selection of the current placeholder might\n      // not acurate any more -> simply restore it\n    }\n    const newSelections = this._editor.getModel().changeDecorations(accessor => {\n      const activePlaceholders = new Set();\n      // change stickiness to always grow when typing at its edges\n      // because these decorations represent the currently active\n      // tabstop.\n      // Special case #1: reaching the final tabstop\n      // Special case #2: placeholders enclosing active placeholders\n      const selections = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n        // consider to skip this placeholder index when the decoration\n        // range is empty but when the placeholder wasn't. that's a strong\n        // hint that the placeholder has been deleted. (all placeholder must match this)\n        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n        activePlaceholders.add(placeholder);\n        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n          const id = this._placeholderDecorations.get(enclosingPlaceholder);\n          accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n          activePlaceholders.add(enclosingPlaceholder);\n        }\n      }\n      // change stickness to never grow when typing at its edges\n      // so that in-active tabstops never grow\n      for (const [placeholder, id] of this._placeholderDecorations) {\n        if (!activePlaceholders.has(placeholder)) {\n          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n        }\n      }\n      return selections;\n    });\n    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n  }\n  _hasPlaceholderBeenCollapsed(placeholder) {\n    // A placeholder is empty when it wasn't empty when authored but\n    // when its tracking decoration is empty. This also applies to all\n    // potential parent placeholders\n    let marker = placeholder;\n    while (marker) {\n      if (marker instanceof Placeholder) {\n        const id = this._placeholderDecorations.get(marker);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (range.isEmpty() && marker.toString().length > 0) {\n          return true;\n        }\n      }\n      marker = marker.parent;\n    }\n    return false;\n  }\n  get isAtFirstPlaceholder() {\n    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n  }\n  get isAtLastPlaceholder() {\n    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n  }\n  get hasPlaceholder() {\n    return this._snippet.placeholders.length > 0;\n  }\n  /**\n   * A snippet is trivial when it has no placeholder or only a final placeholder at\n   * its very end\n   */\n  get isTrivialSnippet() {\n    if (this._snippet.placeholders.length === 0) {\n      return true;\n    }\n    if (this._snippet.placeholders.length === 1) {\n      const [placeholder] = this._snippet.placeholders;\n      if (placeholder.isFinalTabstop) {\n        if (this._snippet.rightMostDescendant === placeholder) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  computePossibleSelections() {\n    const result = new Map();\n    for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n      let ranges;\n      for (const placeholder of placeholdersWithEqualIndex) {\n        if (placeholder.isFinalTabstop) {\n          // ignore those\n          break;\n        }\n        if (!ranges) {\n          ranges = [];\n          result.set(placeholder.index, ranges);\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n          // one of the placeholder lost its decoration and\n          // therefore we bail out and pretend the placeholder\n          // (with its mirrors) doesn't exist anymore.\n          result.delete(placeholder.index);\n          break;\n        }\n        ranges.push(range);\n      }\n    }\n    return result;\n  }\n  get activeChoice() {\n    if (!this._placeholderDecorations) {\n      return undefined;\n    }\n    const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n    if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {\n      return undefined;\n    }\n    const id = this._placeholderDecorations.get(placeholder);\n    if (!id) {\n      return undefined;\n    }\n    const range = this._editor.getModel().getDecorationRange(id);\n    if (!range) {\n      return undefined;\n    }\n    return {\n      range,\n      choice: placeholder.choice\n    };\n  }\n  get hasChoice() {\n    let result = false;\n    this._snippet.walk(marker => {\n      result = marker instanceof Choice;\n      return !result;\n    });\n    return result;\n  }\n  merge(others) {\n    const model = this._editor.getModel();\n    this._nestingLevel *= 10;\n    this._editor.changeDecorations(accessor => {\n      // For each active placeholder take one snippet and merge it\n      // in that the placeholder (can be many for `$1foo$1foo`). Because\n      // everything is sorted by editor selection we can simply remove\n      // elements from the beginning of the array\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const nested = others.shift();\n        console.assert(nested._offset !== -1);\n        console.assert(!nested._placeholderDecorations);\n        // Massage placeholder-indicies of the nested snippet to be\n        // sorted right after the insertion point. This ensures we move\n        // through the placeholders in the correct order\n        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n          if (nestedPlaceholder.isFinalTabstop) {\n            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;\n          } else {\n            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;\n          }\n        }\n        this._snippet.replace(placeholder, nested._snippet.children);\n        // Remove the placeholder at which position are inserting\n        // the snippet and also remove its decoration.\n        const id = this._placeholderDecorations.get(placeholder);\n        accessor.removeDecoration(id);\n        this._placeholderDecorations.delete(placeholder);\n        // For each *new* placeholder we create decoration to monitor\n        // how and if it grows/shrinks.\n        for (const placeholder of nested._snippet.placeholders) {\n          const placeholderOffset = nested._snippet.offset(placeholder);\n          const placeholderLen = nested._snippet.fullLen(placeholder);\n          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n          this._placeholderDecorations.set(placeholder, handle);\n        }\n      }\n      // Last, re-create the placeholder groups by sorting placeholders by their index.\n      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n    });\n  }\n}\nOneSnippet._decor = {\n  active: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-1',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  inactive: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-2',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  activeFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-3',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  }),\n  inactiveFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-4',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  })\n};\nconst _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined,\n  overtypingCapturer: undefined\n};\nlet SnippetSession = SnippetSession_1 = class SnippetSession {\n  static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n    const line = model.getLineContent(position.lineNumber);\n    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n    // the snippet as inserted\n    let snippetTextString;\n    snippet.walk(marker => {\n      // all text elements that are not inside choice\n      if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n        return true;\n      }\n      // check with filter (iff provided)\n      if (filter && !filter.has(marker)) {\n        return true;\n      }\n      const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n      if (adjustIndentation) {\n        // adjust indentation of snippet test\n        // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n        // -all N+1 lines get extra-indented and normalized\n        // -the text start get extra-indented and normalized when following a linebreak\n        const offset = snippet.offset(marker);\n        if (offset === 0) {\n          // snippet start\n          lines[0] = model.normalizeIndentation(lines[0]);\n        } else {\n          // check if text start is after a linebreak\n          snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n          const prevChar = snippetTextString.charCodeAt(offset - 1);\n          if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n          }\n        }\n        for (let i = 1; i < lines.length; i++) {\n          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n        }\n      }\n      const newValue = lines.join(model.getEOL());\n      if (newValue !== marker.value) {\n        marker.parent.replace(marker, [new Text(newValue)]);\n        snippetTextString = undefined;\n      }\n      return true;\n    });\n    return lineLeadingWhitespace;\n  }\n  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n    if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n      // overwrite[Before|After] is compute using the position, not the whole\n      // selection. therefore we adjust the selection around that position\n      const {\n        positionLineNumber,\n        positionColumn\n      } = selection;\n      const positionColumnBefore = positionColumn - overwriteBefore;\n      const positionColumnAfter = positionColumn + overwriteAfter;\n      const range = model.validateRange({\n        startLineNumber: positionLineNumber,\n        startColumn: positionColumnBefore,\n        endLineNumber: positionLineNumber,\n        endColumn: positionColumnAfter\n      });\n      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n    }\n    return selection;\n  }\n  static createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n    const edits = [];\n    const snippets = [];\n    if (!editor.hasModel()) {\n      return {\n        edits,\n        snippets\n      };\n    }\n    const model = editor.getModel();\n    const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n    const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n    const readClipboardText = () => clipboardText;\n    // know what text the overwrite[Before|After] extensions\n    // of the primary curser have selected because only when\n    // secondary selections extend to the same text we can grow them\n    const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n    const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n    // remember the first non-whitespace column to decide if\n    // `keepWhitespace` should be overruled for secondary selections\n    const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n    // sort selections by their start position but remeber\n    // the original index. that allows you to create correct\n    // offset-based selection logic without changing the\n    // primary selection\n    const indexedSelections = editor.getSelections().map((selection, idx) => ({\n      selection,\n      idx\n    })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n    for (const {\n      selection,\n      idx\n    } of indexedSelections) {\n      // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n      // compare if this matches the extensions of the primary selection\n      let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n      let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n        extensionBefore = selection;\n      }\n      if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n        extensionAfter = selection;\n      }\n      // merge the before and after selection into one\n      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n      // adjust the template string to match the indentation and\n      // whitespace rules of this insert location (can be different for each cursor)\n      // happens when being asked for (default) or when this is a secondary\n      // cursor and the leading whitespace is different\n      const start = snippetSelection.getStartPosition();\n      const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), snippet);\n      snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(78 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer), new CommentBasedVariableResolver(model, selection, languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService), new RandomBasedVariableResolver()]));\n      // store snippets with the index of their originating selection.\n      // that ensures the primiary cursor stays primary despite not being\n      // the one with lowest start position\n      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n      edits[idx].identifier = {\n        major: idx,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n      edits[idx]._isTracked = true;\n      snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n    }\n    return {\n      edits,\n      snippets\n    };\n  }\n  static createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n    if (!editor.hasModel() || snippetEdits.length === 0) {\n      return {\n        edits: [],\n        snippets: []\n      };\n    }\n    const edits = [];\n    const model = editor.getModel();\n    const parser = new SnippetParser();\n    const snippet = new TextmateSnippet();\n    // snippet variables resolver\n    const resolver = new CompositeSnippetVariableResolver([editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model)), new ClipboardBasedVariableResolver(() => clipboardText, 0, editor.getSelections().length, editor.getOption(78 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer), new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService))), new RandomBasedVariableResolver()]);\n    //\n    snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n    let offset = 0;\n    for (let i = 0; i < snippetEdits.length; i++) {\n      const {\n        range,\n        template\n      } = snippetEdits[i];\n      // gaps between snippet edits are appended as text nodes. this\n      // ensures placeholder-offsets are later correct\n      if (i > 0) {\n        const lastRange = snippetEdits[i - 1].range;\n        const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n        const textNode = new Text(model.getValueInRange(textRange));\n        snippet.appendChild(textNode);\n        offset += textNode.value.length;\n      }\n      const newNodes = parser.parseFragment(template, snippet);\n      SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n      snippet.resolveVariables(resolver);\n      const snippetText = snippet.toString();\n      const snippetFragmentText = snippetText.slice(offset);\n      offset = snippetText.length;\n      // make edit\n      const edit = EditOperation.replace(range, snippetFragmentText);\n      edit.identifier = {\n        major: i,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n      edit._isTracked = true;\n      edits.push(edit);\n    }\n    //\n    parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n    return {\n      edits,\n      snippets: [new OneSnippet(editor, snippet, '')]\n    };\n  }\n  constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {\n    this._editor = _editor;\n    this._template = _template;\n    this._options = _options;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._templateMerges = [];\n    this._snippets = [];\n  }\n  dispose() {\n    dispose(this._snippets);\n  }\n  _logInfo() {\n    return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n  }\n  insert() {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    // make insert edit and start with first selections\n    const {\n      edits,\n      snippets\n    } = typeof this._template === 'string' ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);\n    this._snippets = snippets;\n    this._editor.executeEdits('snippet', edits, _undoEdits => {\n      // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n      // so we need to look only at the undo edits relevant for us.\n      // Our edits have an identifier set so that's how we can distinguish them\n      const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n      for (let idx = 0; idx < snippets.length; idx++) {\n        snippets[idx].initialize(undoEdits[idx].textChange);\n      }\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(true);\n      } else {\n        return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n    this._editor.revealRange(this._editor.getSelections()[0]);\n  }\n  merge(template, options = _defaultOptions) {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n    const {\n      edits,\n      snippets\n    } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);\n    this._editor.executeEdits('snippet', edits, _undoEdits => {\n      // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n      // so we need to look only at the undo edits relevant for us.\n      // Our edits have an identifier set so that's how we can distinguish them\n      const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n      for (let idx = 0; idx < snippets.length; idx++) {\n        snippets[idx].initialize(undoEdits[idx].textChange);\n      }\n      // Trivial snippets have no placeholder or are just the final placeholder. That means they\n      // are just text insertions and we don't need to merge the nested snippet into the existing\n      // snippet\n      const isTrivialSnippet = snippets[0].isTrivialSnippet;\n      if (!isTrivialSnippet) {\n        for (const snippet of this._snippets) {\n          snippet.merge(snippets);\n        }\n        console.assert(snippets.length === 0);\n      }\n      if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n        return this._move(undefined);\n      } else {\n        return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n  }\n  next() {\n    const newSelections = this._move(true);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  prev() {\n    const newSelections = this._move(false);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  _move(fwd) {\n    const selections = [];\n    for (const snippet of this._snippets) {\n      const oneSelection = snippet.move(fwd);\n      selections.push(...oneSelection);\n    }\n    return selections;\n  }\n  get isAtFirstPlaceholder() {\n    return this._snippets[0].isAtFirstPlaceholder;\n  }\n  get isAtLastPlaceholder() {\n    return this._snippets[0].isAtLastPlaceholder;\n  }\n  get hasPlaceholder() {\n    return this._snippets[0].hasPlaceholder;\n  }\n  get hasChoice() {\n    return this._snippets[0].hasChoice;\n  }\n  get activeChoice() {\n    return this._snippets[0].activeChoice;\n  }\n  isSelectionWithinPlaceholders() {\n    if (!this.hasPlaceholder) {\n      return false;\n    }\n    const selections = this._editor.getSelections();\n    if (selections.length < this._snippets.length) {\n      // this means we started snippet mode with N\n      // selections and have M (N > M) selections.\n      // So one snippet is without selection -> cancel\n      return false;\n    }\n    const allPossibleSelections = new Map();\n    for (const snippet of this._snippets) {\n      const possibleSelections = snippet.computePossibleSelections();\n      // for the first snippet find the placeholder (and its ranges)\n      // that contain at least one selection. for all remaining snippets\n      // the same placeholder (and their ranges) must be used.\n      if (allPossibleSelections.size === 0) {\n        for (const [index, ranges] of possibleSelections) {\n          ranges.sort(Range.compareRangesUsingStarts);\n          for (const selection of selections) {\n            if (ranges[0].containsRange(selection)) {\n              allPossibleSelections.set(index, []);\n              break;\n            }\n          }\n        }\n      }\n      if (allPossibleSelections.size === 0) {\n        // return false if we couldn't associate a selection to\n        // this (the first) snippet\n        return false;\n      }\n      // add selections from 'this' snippet so that we know all\n      // selections for this placeholder\n      allPossibleSelections.forEach((array, index) => {\n        array.push(...possibleSelections.get(index));\n      });\n    }\n    // sort selections (and later placeholder-ranges). then walk both\n    // arrays and make sure the placeholder-ranges contain the corresponding\n    // selection\n    selections.sort(Range.compareRangesUsingStarts);\n    for (const [index, ranges] of allPossibleSelections) {\n      if (ranges.length !== selections.length) {\n        allPossibleSelections.delete(index);\n        continue;\n      }\n      ranges.sort(Range.compareRangesUsingStarts);\n      for (let i = 0; i < ranges.length; i++) {\n        if (!ranges[i].containsRange(selections[i])) {\n          allPossibleSelections.delete(index);\n          continue;\n        }\n      }\n    }\n    // from all possible selections we have deleted those\n    // that don't match with the current selection. if we don't\n    // have any left, we don't have a selection anymore\n    return allPossibleSelections.size > 0;\n  }\n};\nSnippetSession = SnippetSession_1 = __decorate([__param(3, ILanguageConfigurationService)], SnippetSession);\nexport { SnippetSession };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","SnippetSession_1","groupBy","dispose","getLeadingWhitespace","EditOperation","Range","Selection","ILanguageConfigurationService","ModelDecorationOptions","ILabelService","IWorkspaceContextService","Choice","Placeholder","SnippetParser","Text","TextmateSnippet","ClipboardBasedVariableResolver","CommentBasedVariableResolver","CompositeSnippetVariableResolver","ModelBasedVariableResolver","RandomBasedVariableResolver","SelectionBasedVariableResolver","TimeBasedVariableResolver","WorkspaceBasedVariableResolver","OneSnippet","constructor","_editor","_snippet","_snippetLineLeadingWhitespace","_offset","_nestingLevel","_placeholderGroups","placeholders","compareByIndex","_placeholderGroupsIdx","initialize","textChange","newPosition","_placeholderDecorations","removeDecorations","values","_initDecorations","Error","Map","model","getModel","changeDecorations","accessor","placeholder","placeholderOffset","offset","placeholderLen","fullLen","range","fromPositions","getPositionAt","options","isFinalTabstop","_decor","inactiveFinal","inactive","handle","addDecoration","set","move","fwd","hasModel","operations","transform","id","get","getDecorationRange","currentValue","getValueInRange","transformedValueLines","resolve","split","normalizeIndentation","push","replace","join","getEOL","executeEdits","couldSkipThisPlaceholder","newSelections","activePlaceholders","Set","selections","startLineNumber","startColumn","endLineNumber","endColumn","_hasPlaceholderBeenCollapsed","changeDecorationOptions","activeFinal","active","add","enclosingPlaceholder","enclosingPlaceholders","has","marker","isEmpty","toString","parent","isAtFirstPlaceholder","isAtLastPlaceholder","hasPlaceholder","isTrivialSnippet","rightMostDescendant","computePossibleSelections","result","placeholdersWithEqualIndex","ranges","index","delete","activeChoice","undefined","choice","hasChoice","walk","merge","others","nested","shift","console","assert","indexLastPlaceholder","placeholderInfo","last","nestedPlaceholder","all","children","removeDecoration","register","description","stickiness","className","_defaultOptions","overwriteBefore","overwriteAfter","adjustWhitespace","clipboardText","overtypingCapturer","SnippetSession","position","adjustIndentation","snippet","filter","line","getLineContent","lineNumber","lineLeadingWhitespace","column","snippetTextString","lines","value","prevChar","charCodeAt","newValue","adjustSelection","selection","positionLineNumber","positionColumn","positionColumnBefore","positionColumnAfter","validateRange","createWithDirection","getDirection","createEditsAndSnippetsFromSelections","editor","template","enforceFinalTabstop","languageConfigurationService","edits","snippets","workspaceService","invokeWithinContext","modelBasedVariableResolver","readClipboardText","firstBeforeText","getSelection","firstAfterText","firstLineFirstNonWhitespace","getLineFirstNonWhitespaceColumn","indexedSelections","getSelections","map","idx","sort","a","b","compareRangesUsingStarts","extensionBefore","extensionAfter","snippetSelection","setStartPosition","setEndPosition","parse","start","getStartPosition","snippetLineLeadingWhitespace","resolveVariables","getOption","identifier","major","minor","_isTracked","createEditsAndSnippetsFromEdits","snippetEdits","parser","resolver","lastRange","textRange","getEndPosition","textNode","appendChild","newNodes","parseFragment","snippetText","snippetFragmentText","slice","edit","ensureFinalTabstop","_template","_options","_languageConfigurationService","_templateMerges","_snippets","_logInfo","insert","_undoEdits","undoEdits","_move","revealRange","next","setSelections","revealPositionInCenterIfOutsideViewport","getPosition","prev","oneSelection","isSelectionWithinPlaceholders","allPossibleSelections","possibleSelections","size","containsRange","forEach","array"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport class OneSnippet {\n    constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {\n        this._editor = _editor;\n        this._snippet = _snippet;\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n        this._offset = -1;\n        this._nestingLevel = 1;\n        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n        this._placeholderGroupsIdx = -1;\n    }\n    initialize(textChange) {\n        this._offset = textChange.newPosition;\n    }\n    dispose() {\n        if (this._placeholderDecorations) {\n            this._editor.removeDecorations([...this._placeholderDecorations.values()]);\n        }\n        this._placeholderGroups.length = 0;\n    }\n    _initDecorations() {\n        if (this._offset === -1) {\n            throw new Error(`Snippet not initialized!`);\n        }\n        if (this._placeholderDecorations) {\n            // already initialized\n            return;\n        }\n        this._placeholderDecorations = new Map();\n        const model = this._editor.getModel();\n        this._editor.changeDecorations(accessor => {\n            // create a decoration for each placeholder\n            for (const placeholder of this._snippet.placeholders) {\n                const placeholderOffset = this._snippet.offset(placeholder);\n                const placeholderLen = this._snippet.fullLen(placeholder);\n                const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n                const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                const handle = accessor.addDecoration(range, options);\n                this._placeholderDecorations.set(placeholder, handle);\n            }\n        });\n    }\n    move(fwd) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this._initDecorations();\n        // Transform placeholder text if necessary\n        if (this._placeholderGroupsIdx >= 0) {\n            const operations = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                // Check if the placeholder has a transformation\n                if (placeholder.transform) {\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    const currentValue = this._editor.getModel().getValueInRange(range);\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n                    // fix indentation for transformed lines\n                    for (let i = 1; i < transformedValueLines.length; i++) {\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n                    }\n                    operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n                }\n            }\n            if (operations.length > 0) {\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\n            }\n        }\n        let couldSkipThisPlaceholder = false;\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n            this._placeholderGroupsIdx += 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\n            this._placeholderGroupsIdx -= 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else {\n            // the selection of the current placeholder might\n            // not acurate any more -> simply restore it\n        }\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\n            const activePlaceholders = new Set();\n            // change stickiness to always grow when typing at its edges\n            // because these decorations represent the currently active\n            // tabstop.\n            // Special case #1: reaching the final tabstop\n            // Special case #2: placeholders enclosing active placeholders\n            const selections = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                // consider to skip this placeholder index when the decoration\n                // range is empty but when the placeholder wasn't. that's a strong\n                // hint that the placeholder has been deleted. (all placeholder must match this)\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(placeholder);\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(enclosingPlaceholder);\n                }\n            }\n            // change stickness to never grow when typing at its edges\n            // so that in-active tabstops never grow\n            for (const [placeholder, id] of this._placeholderDecorations) {\n                if (!activePlaceholders.has(placeholder)) {\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                }\n            }\n            return selections;\n        });\n        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n    }\n    _hasPlaceholderBeenCollapsed(placeholder) {\n        // A placeholder is empty when it wasn't empty when authored but\n        // when its tracking decoration is empty. This also applies to all\n        // potential parent placeholders\n        let marker = placeholder;\n        while (marker) {\n            if (marker instanceof Placeholder) {\n                const id = this._placeholderDecorations.get(marker);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (range.isEmpty() && marker.toString().length > 0) {\n                    return true;\n                }\n            }\n            marker = marker.parent;\n        }\n        return false;\n    }\n    get isAtFirstPlaceholder() {\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    }\n    get isAtLastPlaceholder() {\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    }\n    get hasPlaceholder() {\n        return this._snippet.placeholders.length > 0;\n    }\n    /**\n     * A snippet is trivial when it has no placeholder or only a final placeholder at\n     * its very end\n     */\n    get isTrivialSnippet() {\n        if (this._snippet.placeholders.length === 0) {\n            return true;\n        }\n        if (this._snippet.placeholders.length === 1) {\n            const [placeholder] = this._snippet.placeholders;\n            if (placeholder.isFinalTabstop) {\n                if (this._snippet.rightMostDescendant === placeholder) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    computePossibleSelections() {\n        const result = new Map();\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n            let ranges;\n            for (const placeholder of placeholdersWithEqualIndex) {\n                if (placeholder.isFinalTabstop) {\n                    // ignore those\n                    break;\n                }\n                if (!ranges) {\n                    ranges = [];\n                    result.set(placeholder.index, ranges);\n                }\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (!range) {\n                    // one of the placeholder lost its decoration and\n                    // therefore we bail out and pretend the placeholder\n                    // (with its mirrors) doesn't exist anymore.\n                    result.delete(placeholder.index);\n                    break;\n                }\n                ranges.push(range);\n            }\n        }\n        return result;\n    }\n    get activeChoice() {\n        if (!this._placeholderDecorations) {\n            return undefined;\n        }\n        const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n        if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {\n            return undefined;\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        if (!id) {\n            return undefined;\n        }\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n            return undefined;\n        }\n        return { range, choice: placeholder.choice };\n    }\n    get hasChoice() {\n        let result = false;\n        this._snippet.walk(marker => {\n            result = marker instanceof Choice;\n            return !result;\n        });\n        return result;\n    }\n    merge(others) {\n        const model = this._editor.getModel();\n        this._nestingLevel *= 10;\n        this._editor.changeDecorations(accessor => {\n            // For each active placeholder take one snippet and merge it\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\n            // everything is sorted by editor selection we can simply remove\n            // elements from the beginning of the array\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const nested = others.shift();\n                console.assert(nested._offset !== -1);\n                console.assert(!nested._placeholderDecorations);\n                // Massage placeholder-indicies of the nested snippet to be\n                // sorted right after the insertion point. This ensures we move\n                // through the placeholders in the correct order\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n                    if (nestedPlaceholder.isFinalTabstop) {\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n                    }\n                    else {\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n                    }\n                }\n                this._snippet.replace(placeholder, nested._snippet.children);\n                // Remove the placeholder at which position are inserting\n                // the snippet and also remove its decoration.\n                const id = this._placeholderDecorations.get(placeholder);\n                accessor.removeDecoration(id);\n                this._placeholderDecorations.delete(placeholder);\n                // For each *new* placeholder we create decoration to monitor\n                // how and if it grows/shrinks.\n                for (const placeholder of nested._snippet.placeholders) {\n                    const placeholderOffset = nested._snippet.offset(placeholder);\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\n                    const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                    const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                    this._placeholderDecorations.set(placeholder, handle);\n                }\n            }\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\n            this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n        });\n    }\n}\nOneSnippet._decor = {\n    active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    inactive: ModelDecorationOptions.register({ description: 'snippet-placeholder-2', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    activeFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-3', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n    inactiveFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-4', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n};\nconst _defaultOptions = {\n    overwriteBefore: 0,\n    overwriteAfter: 0,\n    adjustWhitespace: true,\n    clipboardText: undefined,\n    overtypingCapturer: undefined\n};\nlet SnippetSession = SnippetSession_1 = class SnippetSession {\n    static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n        const line = model.getLineContent(position.lineNumber);\n        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n        // the snippet as inserted\n        let snippetTextString;\n        snippet.walk(marker => {\n            // all text elements that are not inside choice\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n                return true;\n            }\n            // check with filter (iff provided)\n            if (filter && !filter.has(marker)) {\n                return true;\n            }\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n            if (adjustIndentation) {\n                // adjust indentation of snippet test\n                // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n                // -all N+1 lines get extra-indented and normalized\n                // -the text start get extra-indented and normalized when following a linebreak\n                const offset = snippet.offset(marker);\n                if (offset === 0) {\n                    // snippet start\n                    lines[0] = model.normalizeIndentation(lines[0]);\n                }\n                else {\n                    // check if text start is after a linebreak\n                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n                    const prevChar = snippetTextString.charCodeAt(offset - 1);\n                    if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n                    }\n                }\n                for (let i = 1; i < lines.length; i++) {\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n                }\n            }\n            const newValue = lines.join(model.getEOL());\n            if (newValue !== marker.value) {\n                marker.parent.replace(marker, [new Text(newValue)]);\n                snippetTextString = undefined;\n            }\n            return true;\n        });\n        return lineLeadingWhitespace;\n    }\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n            // overwrite[Before|After] is compute using the position, not the whole\n            // selection. therefore we adjust the selection around that position\n            const { positionLineNumber, positionColumn } = selection;\n            const positionColumnBefore = positionColumn - overwriteBefore;\n            const positionColumnAfter = positionColumn + overwriteAfter;\n            const range = model.validateRange({\n                startLineNumber: positionLineNumber,\n                startColumn: positionColumnBefore,\n                endLineNumber: positionLineNumber,\n                endColumn: positionColumnAfter\n            });\n            selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n        }\n        return selection;\n    }\n    static createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        const edits = [];\n        const snippets = [];\n        if (!editor.hasModel()) {\n            return { edits, snippets };\n        }\n        const model = editor.getModel();\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n        const readClipboardText = () => clipboardText;\n        // know what text the overwrite[Before|After] extensions\n        // of the primary curser have selected because only when\n        // secondary selections extend to the same text we can grow them\n        const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n        const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n        // remember the first non-whitespace column to decide if\n        // `keepWhitespace` should be overruled for secondary selections\n        const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n        // sort selections by their start position but remeber\n        // the original index. that allows you to create correct\n        // offset-based selection logic without changing the\n        // primary selection\n        const indexedSelections = editor.getSelections()\n            .map((selection, idx) => ({ selection, idx }))\n            .sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        for (const { selection, idx } of indexedSelections) {\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n            // compare if this matches the extensions of the primary selection\n            let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n            let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                extensionBefore = selection;\n            }\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                extensionAfter = selection;\n            }\n            // merge the before and after selection into one\n            const snippetSelection = selection\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n            // adjust the template string to match the indentation and\n            // whitespace rules of this insert location (can be different for each cursor)\n            // happens when being asked for (default) or when this is a secondary\n            // cursor and the leading whitespace is different\n            const start = snippetSelection.getStartPosition();\n            const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), snippet);\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\n                modelBasedVariableResolver,\n                new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(78 /* EditorOption.multiCursorPaste */) === 'spread'),\n                new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\n                new CommentBasedVariableResolver(model, selection, languageConfigurationService),\n                new TimeBasedVariableResolver,\n                new WorkspaceBasedVariableResolver(workspaceService),\n                new RandomBasedVariableResolver,\n            ]));\n            // store snippets with the index of their originating selection.\n            // that ensures the primiary cursor stays primary despite not being\n            // the one with lowest start position\n            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edits[idx]._isTracked = true;\n            snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n        }\n        return { edits, snippets };\n    }\n    static createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        if (!editor.hasModel() || snippetEdits.length === 0) {\n            return { edits: [], snippets: [] };\n        }\n        const edits = [];\n        const model = editor.getModel();\n        const parser = new SnippetParser();\n        const snippet = new TextmateSnippet();\n        // snippet variables resolver\n        const resolver = new CompositeSnippetVariableResolver([\n            editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),\n            new ClipboardBasedVariableResolver(() => clipboardText, 0, editor.getSelections().length, editor.getOption(78 /* EditorOption.multiCursorPaste */) === 'spread'),\n            new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer),\n            new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService),\n            new TimeBasedVariableResolver,\n            new WorkspaceBasedVariableResolver(editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService))),\n            new RandomBasedVariableResolver,\n        ]);\n        //\n        snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n        let offset = 0;\n        for (let i = 0; i < snippetEdits.length; i++) {\n            const { range, template } = snippetEdits[i];\n            // gaps between snippet edits are appended as text nodes. this\n            // ensures placeholder-offsets are later correct\n            if (i > 0) {\n                const lastRange = snippetEdits[i - 1].range;\n                const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n                const textNode = new Text(model.getValueInRange(textRange));\n                snippet.appendChild(textNode);\n                offset += textNode.value.length;\n            }\n            const newNodes = parser.parseFragment(template, snippet);\n            SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n            snippet.resolveVariables(resolver);\n            const snippetText = snippet.toString();\n            const snippetFragmentText = snippetText.slice(offset);\n            offset = snippetText.length;\n            // make edit\n            const edit = EditOperation.replace(range, snippetFragmentText);\n            edit.identifier = { major: i, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edit._isTracked = true;\n            edits.push(edit);\n        }\n        //\n        parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n        return {\n            edits,\n            snippets: [new OneSnippet(editor, snippet, '')]\n        };\n    }\n    constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {\n        this._editor = _editor;\n        this._template = _template;\n        this._options = _options;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._templateMerges = [];\n        this._snippets = [];\n    }\n    dispose() {\n        dispose(this._snippets);\n    }\n    _logInfo() {\n        return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n    }\n    insert() {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        // make insert edit and start with first selections\n        const { edits, snippets } = typeof this._template === 'string'\n            ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService)\n            : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);\n        this._snippets = snippets;\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            if (this._snippets[0].hasPlaceholder) {\n                return this._move(true);\n            }\n            else {\n                return undoEdits\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n        this._editor.revealRange(this._editor.getSelections()[0]);\n    }\n    merge(template, options = _defaultOptions) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n        const { edits, snippets } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            // Trivial snippets have no placeholder or are just the final placeholder. That means they\n            // are just text insertions and we don't need to merge the nested snippet into the existing\n            // snippet\n            const isTrivialSnippet = snippets[0].isTrivialSnippet;\n            if (!isTrivialSnippet) {\n                for (const snippet of this._snippets) {\n                    snippet.merge(snippets);\n                }\n                console.assert(snippets.length === 0);\n            }\n            if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n                return this._move(undefined);\n            }\n            else {\n                return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n    }\n    next() {\n        const newSelections = this._move(true);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    prev() {\n        const newSelections = this._move(false);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    _move(fwd) {\n        const selections = [];\n        for (const snippet of this._snippets) {\n            const oneSelection = snippet.move(fwd);\n            selections.push(...oneSelection);\n        }\n        return selections;\n    }\n    get isAtFirstPlaceholder() {\n        return this._snippets[0].isAtFirstPlaceholder;\n    }\n    get isAtLastPlaceholder() {\n        return this._snippets[0].isAtLastPlaceholder;\n    }\n    get hasPlaceholder() {\n        return this._snippets[0].hasPlaceholder;\n    }\n    get hasChoice() {\n        return this._snippets[0].hasChoice;\n    }\n    get activeChoice() {\n        return this._snippets[0].activeChoice;\n    }\n    isSelectionWithinPlaceholders() {\n        if (!this.hasPlaceholder) {\n            return false;\n        }\n        const selections = this._editor.getSelections();\n        if (selections.length < this._snippets.length) {\n            // this means we started snippet mode with N\n            // selections and have M (N > M) selections.\n            // So one snippet is without selection -> cancel\n            return false;\n        }\n        const allPossibleSelections = new Map();\n        for (const snippet of this._snippets) {\n            const possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n                for (const [index, ranges] of possibleSelections) {\n                    ranges.sort(Range.compareRangesUsingStarts);\n                    for (const selection of selections) {\n                        if (ranges[0].containsRange(selection)) {\n                            allPossibleSelections.set(index, []);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (allPossibleSelections.size === 0) {\n                // return false if we couldn't associate a selection to\n                // this (the first) snippet\n                return false;\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach((array, index) => {\n                array.push(...possibleSelections.get(index));\n            });\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n        selections.sort(Range.compareRangesUsingStarts);\n        for (const [index, ranges] of allPossibleSelections) {\n            if (ranges.length !== selections.length) {\n                allPossibleSelections.delete(index);\n                continue;\n            }\n            ranges.sort(Range.compareRangesUsingStarts);\n            for (let i = 0; i < ranges.length; i++) {\n                if (!ranges[i].containsRange(selections[i])) {\n                    allPossibleSelections.delete(index);\n                    continue;\n                }\n            }\n        }\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n        return allPossibleSelections.size > 0;\n    }\n};\nSnippetSession = SnippetSession_1 = __decorate([\n    __param(3, ILanguageConfigurationService)\n], SnippetSession);\nexport { SnippetSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}