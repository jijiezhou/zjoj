{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { getFunctionName } from './base.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n  return new AutorunObserver(undefined, fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n  return new AutorunObserver(options.debugName, fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n  return new AutorunObserver(options.debugName, fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n  const store = new DisposableStore();\n  const disposable = autorunOpts({\n    debugName: () => getFunctionName(fn) || '(anonymous)'\n  }, reader => {\n    store.clear();\n    fn(reader, store);\n  });\n  return toDisposable(() => {\n    disposable.dispose();\n    store.dispose();\n  });\n}\nexport class AutorunObserver {\n  get debugName() {\n    if (typeof this._debugName === 'string') {\n      return this._debugName;\n    }\n    if (typeof this._debugName === 'function') {\n      const name = this._debugName();\n      if (name !== undefined) {\n        return name;\n      }\n    }\n    const name = getFunctionName(this._runFn);\n    if (name !== undefined) {\n      return name;\n    }\n    return '(anonymous)';\n  }\n  constructor(_debugName, _runFn, createChangeSummary, _handleChange) {\n    var _a, _b;\n    this._debugName = _debugName;\n    this._runFn = _runFn;\n    this.createChangeSummary = createChangeSummary;\n    this._handleChange = _handleChange;\n    this.state = 2 /* AutorunState.stale */;\n    this.updateCount = 0;\n    this.disposed = false;\n    this.dependencies = new Set();\n    this.dependenciesToBeRemoved = new Set();\n    this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleAutorunCreated(this);\n    this._runIfNeeded();\n    trackDisposable(this);\n  }\n  dispose() {\n    this.disposed = true;\n    for (const o of this.dependencies) {\n      o.removeObserver(this);\n    }\n    this.dependencies.clear();\n    markAsDisposed(this);\n  }\n  _runIfNeeded() {\n    var _a, _b, _c;\n    if (this.state === 3 /* AutorunState.upToDate */) {\n      return;\n    }\n    const emptySet = this.dependenciesToBeRemoved;\n    this.dependenciesToBeRemoved = this.dependencies;\n    this.dependencies = emptySet;\n    this.state = 3 /* AutorunState.upToDate */;\n    const isDisposed = this.disposed;\n    try {\n      if (!isDisposed) {\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleAutorunTriggered(this);\n        const changeSummary = this.changeSummary;\n        this.changeSummary = (_b = this.createChangeSummary) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._runFn(this, changeSummary);\n      }\n    } finally {\n      if (!isDisposed) {\n        (_c = getLogger()) === null || _c === void 0 ? void 0 : _c.handleAutorunFinished(this);\n      }\n      // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n      // Thus, we only unsubscribe from observables that are definitely not read anymore.\n      for (const o of this.dependenciesToBeRemoved) {\n        o.removeObserver(this);\n      }\n      this.dependenciesToBeRemoved.clear();\n    }\n  }\n  toString() {\n    return `Autorun<${this.debugName}>`;\n  }\n  // IObserver implementation\n  beginUpdate() {\n    if (this.state === 3 /* AutorunState.upToDate */) {\n      this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n    }\n    this.updateCount++;\n  }\n  endUpdate() {\n    if (this.updateCount === 1) {\n      do {\n        if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n          this.state = 3 /* AutorunState.upToDate */;\n          for (const d of this.dependencies) {\n            d.reportChanges();\n            if (this.state === 2 /* AutorunState.stale */) {\n              // The other dependencies will refresh on demand\n              break;\n            }\n          }\n        }\n        this._runIfNeeded();\n      } while (this.state !== 3 /* AutorunState.upToDate */);\n    }\n    this.updateCount--;\n    assertFn(() => this.updateCount >= 0);\n  }\n  handlePossibleChange(observable) {\n    if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n    }\n  }\n  handleChange(observable, change) {\n    if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      const shouldReact = this._handleChange ? this._handleChange({\n        changedObservable: observable,\n        change,\n        didChange: o => o === observable\n      }, this.changeSummary) : true;\n      if (shouldReact) {\n        this.state = 2 /* AutorunState.stale */;\n      }\n    }\n  }\n  // IReader implementation\n  readObservable(observable) {\n    // In case the run action disposes the autorun\n    if (this.disposed) {\n      return observable.get();\n    }\n    observable.addObserver(this);\n    const value = observable.get();\n    this.dependencies.add(observable);\n    this.dependenciesToBeRemoved.delete(observable);\n    return value;\n  }\n}\n(function (autorun) {\n  autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));","map":{"version":3,"names":["assertFn","DisposableStore","markAsDisposed","toDisposable","trackDisposable","getFunctionName","getLogger","autorun","fn","AutorunObserver","undefined","autorunOpts","options","debugName","autorunHandleChanges","createEmptyChangeSummary","handleChange","autorunWithStore","store","disposable","reader","clear","dispose","_debugName","name","_runFn","constructor","createChangeSummary","_handleChange","_a","_b","state","updateCount","disposed","dependencies","Set","dependenciesToBeRemoved","changeSummary","call","handleAutorunCreated","_runIfNeeded","o","removeObserver","_c","emptySet","isDisposed","handleAutorunTriggered","handleAutorunFinished","toString","beginUpdate","endUpdate","d","reportChanges","handlePossibleChange","observable","has","change","shouldReact","changedObservable","didChange","readObservable","get","addObserver","value","add","delete","Observer"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { getFunctionName } from './base.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(undefined, fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(options.debugName, fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(options.debugName, fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        debugName: () => getFunctionName(fn) || '(anonymous)',\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        if (typeof this._debugName === 'string') {\n            return this._debugName;\n        }\n        if (typeof this._debugName === 'function') {\n            const name = this._debugName();\n            if (name !== undefined) {\n                return name;\n            }\n        }\n        const name = getFunctionName(this._runFn);\n        if (name !== undefined) {\n            return name;\n        }\n        return '(anonymous)';\n    }\n    constructor(_debugName, _runFn, createChangeSummary, _handleChange) {\n        var _a, _b;\n        this._debugName = _debugName;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        var _a, _b, _c;\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = (_b = this.createChangeSummary) === null || _b === void 0 ? void 0 : _b.call(this);\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                (_c = getLogger()) === null || _c === void 0 ? void 0 : _c.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: o => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,cAAc;AACvC,SAASC,eAAe,EAAEC,cAAc,EAAEC,YAAY,EAAEC,eAAe,QAAQ,iBAAiB;AAChG,SAASC,eAAe,QAAQ,WAAW;AAC3C,SAASC,SAAS,QAAQ,cAAc;AACxC;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,EAAE,EAAE;EACxB,OAAO,IAAIC,eAAe,CAACC,SAAS,EAAEF,EAAE,EAAEE,SAAS,EAAEA,SAAS,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,OAAO,EAAEJ,EAAE,EAAE;EACrC,OAAO,IAAIC,eAAe,CAACG,OAAO,CAACC,SAAS,EAAEL,EAAE,EAAEE,SAAS,EAAEA,SAAS,CAAC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,oBAAoBA,CAACF,OAAO,EAAEJ,EAAE,EAAE;EAC9C,OAAO,IAAIC,eAAe,CAACG,OAAO,CAACC,SAAS,EAAEL,EAAE,EAAEI,OAAO,CAACG,wBAAwB,EAAEH,OAAO,CAACI,YAAY,CAAC;AAC7G;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACT,EAAE,EAAE;EACjC,MAAMU,KAAK,GAAG,IAAIjB,eAAe,CAAC,CAAC;EACnC,MAAMkB,UAAU,GAAGR,WAAW,CAAC;IAC3BE,SAAS,EAAEA,CAAA,KAAMR,eAAe,CAACG,EAAE,CAAC,IAAI;EAC5C,CAAC,EAAEY,MAAM,IAAI;IACTF,KAAK,CAACG,KAAK,CAAC,CAAC;IACbb,EAAE,CAACY,MAAM,EAAEF,KAAK,CAAC;EACrB,CAAC,CAAC;EACF,OAAOf,YAAY,CAAC,MAAM;IACtBgB,UAAU,CAACG,OAAO,CAAC,CAAC;IACpBJ,KAAK,CAACI,OAAO,CAAC,CAAC;EACnB,CAAC,CAAC;AACN;AACA,OAAO,MAAMb,eAAe,CAAC;EACzB,IAAII,SAASA,CAAA,EAAG;IACZ,IAAI,OAAO,IAAI,CAACU,UAAU,KAAK,QAAQ,EAAE;MACrC,OAAO,IAAI,CAACA,UAAU;IAC1B;IACA,IAAI,OAAO,IAAI,CAACA,UAAU,KAAK,UAAU,EAAE;MACvC,MAAMC,IAAI,GAAG,IAAI,CAACD,UAAU,CAAC,CAAC;MAC9B,IAAIC,IAAI,KAAKd,SAAS,EAAE;QACpB,OAAOc,IAAI;MACf;IACJ;IACA,MAAMA,IAAI,GAAGnB,eAAe,CAAC,IAAI,CAACoB,MAAM,CAAC;IACzC,IAAID,IAAI,KAAKd,SAAS,EAAE;MACpB,OAAOc,IAAI;IACf;IACA,OAAO,aAAa;EACxB;EACAE,WAAWA,CAACH,UAAU,EAAEE,MAAM,EAAEE,mBAAmB,EAAEC,aAAa,EAAE;IAChE,IAAIC,EAAE,EAAEC,EAAE;IACV,IAAI,CAACP,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACE,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC7B,IAAI,CAACC,uBAAuB,GAAG,IAAID,GAAG,CAAC,CAAC;IACxC,IAAI,CAACE,aAAa,GAAG,CAACR,EAAE,GAAG,IAAI,CAACF,mBAAmB,MAAM,IAAI,IAAIE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACS,IAAI,CAAC,IAAI,CAAC;IACvG,CAACR,EAAE,GAAGxB,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIwB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACS,oBAAoB,CAAC,IAAI,CAAC;IACrF,IAAI,CAACC,YAAY,CAAC,CAAC;IACnBpC,eAAe,CAAC,IAAI,CAAC;EACzB;EACAkB,OAAOA,CAAA,EAAG;IACN,IAAI,CAACW,QAAQ,GAAG,IAAI;IACpB,KAAK,MAAMQ,CAAC,IAAI,IAAI,CAACP,YAAY,EAAE;MAC/BO,CAAC,CAACC,cAAc,CAAC,IAAI,CAAC;IAC1B;IACA,IAAI,CAACR,YAAY,CAACb,KAAK,CAAC,CAAC;IACzBnB,cAAc,CAAC,IAAI,CAAC;EACxB;EACAsC,YAAYA,CAAA,EAAG;IACX,IAAIX,EAAE,EAAEC,EAAE,EAAEa,EAAE;IACd,IAAI,IAAI,CAACZ,KAAK,KAAK,CAAC,CAAC,6BAA6B;MAC9C;IACJ;IACA,MAAMa,QAAQ,GAAG,IAAI,CAACR,uBAAuB;IAC7C,IAAI,CAACA,uBAAuB,GAAG,IAAI,CAACF,YAAY;IAChD,IAAI,CAACA,YAAY,GAAGU,QAAQ;IAC5B,IAAI,CAACb,KAAK,GAAG,CAAC,CAAC;IACf,MAAMc,UAAU,GAAG,IAAI,CAACZ,QAAQ;IAChC,IAAI;MACA,IAAI,CAACY,UAAU,EAAE;QACb,CAAChB,EAAE,GAAGvB,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACiB,sBAAsB,CAAC,IAAI,CAAC;QACvF,MAAMT,aAAa,GAAG,IAAI,CAACA,aAAa;QACxC,IAAI,CAACA,aAAa,GAAG,CAACP,EAAE,GAAG,IAAI,CAACH,mBAAmB,MAAM,IAAI,IAAIG,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACQ,IAAI,CAAC,IAAI,CAAC;QACvG,IAAI,CAACb,MAAM,CAAC,IAAI,EAAEY,aAAa,CAAC;MACpC;IACJ,CAAC,SACO;MACJ,IAAI,CAACQ,UAAU,EAAE;QACb,CAACF,EAAE,GAAGrC,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIqC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,qBAAqB,CAAC,IAAI,CAAC;MAC1F;MACA;MACA;MACA,KAAK,MAAMN,CAAC,IAAI,IAAI,CAACL,uBAAuB,EAAE;QAC1CK,CAAC,CAACC,cAAc,CAAC,IAAI,CAAC;MAC1B;MACA,IAAI,CAACN,uBAAuB,CAACf,KAAK,CAAC,CAAC;IACxC;EACJ;EACA2B,QAAQA,CAAA,EAAG;IACP,OAAQ,WAAU,IAAI,CAACnC,SAAU,GAAE;EACvC;EACA;EACAoC,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAAClB,KAAK,KAAK,CAAC,CAAC,6BAA6B;MAC9C,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;IACnB;IACA,IAAI,CAACC,WAAW,EAAE;EACtB;EACAkB,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAAClB,WAAW,KAAK,CAAC,EAAE;MACxB,GAAG;QACC,IAAI,IAAI,CAACD,KAAK,KAAK,CAAC,CAAC,iDAAiD;UAClE,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;UACf,KAAK,MAAMoB,CAAC,IAAI,IAAI,CAACjB,YAAY,EAAE;YAC/BiB,CAAC,CAACC,aAAa,CAAC,CAAC;YACjB,IAAI,IAAI,CAACrB,KAAK,KAAK,CAAC,CAAC,0BAA0B;cAC3C;cACA;YACJ;UACJ;QACJ;QACA,IAAI,CAACS,YAAY,CAAC,CAAC;MACvB,CAAC,QAAQ,IAAI,CAACT,KAAK,KAAK,CAAC,CAAC;IAC9B;IACA,IAAI,CAACC,WAAW,EAAE;IAClBhC,QAAQ,CAAC,MAAM,IAAI,CAACgC,WAAW,IAAI,CAAC,CAAC;EACzC;EACAqB,oBAAoBA,CAACC,UAAU,EAAE;IAC7B,IAAI,IAAI,CAACvB,KAAK,KAAK,CAAC,CAAC,+BAA+B,IAAI,CAACG,YAAY,CAACqB,GAAG,CAACD,UAAU,CAAC,IAAI,CAAC,IAAI,CAAClB,uBAAuB,CAACmB,GAAG,CAACD,UAAU,CAAC,EAAE;MACpI,IAAI,CAACvB,KAAK,GAAG,CAAC,CAAC;IACnB;EACJ;EACAf,YAAYA,CAACsC,UAAU,EAAEE,MAAM,EAAE;IAC7B,IAAI,IAAI,CAACtB,YAAY,CAACqB,GAAG,CAACD,UAAU,CAAC,IAAI,CAAC,IAAI,CAAClB,uBAAuB,CAACmB,GAAG,CAACD,UAAU,CAAC,EAAE;MACpF,MAAMG,WAAW,GAAG,IAAI,CAAC7B,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC;QACxD8B,iBAAiB,EAAEJ,UAAU;QAC7BE,MAAM;QACNG,SAAS,EAAElB,CAAC,IAAIA,CAAC,KAAKa;MAC1B,CAAC,EAAE,IAAI,CAACjB,aAAa,CAAC,GAAG,IAAI;MAC7B,IAAIoB,WAAW,EAAE;QACb,IAAI,CAAC1B,KAAK,GAAG,CAAC,CAAC;MACnB;IACJ;EACJ;EACA;EACA6B,cAAcA,CAACN,UAAU,EAAE;IACvB;IACA,IAAI,IAAI,CAACrB,QAAQ,EAAE;MACf,OAAOqB,UAAU,CAACO,GAAG,CAAC,CAAC;IAC3B;IACAP,UAAU,CAACQ,WAAW,CAAC,IAAI,CAAC;IAC5B,MAAMC,KAAK,GAAGT,UAAU,CAACO,GAAG,CAAC,CAAC;IAC9B,IAAI,CAAC3B,YAAY,CAAC8B,GAAG,CAACV,UAAU,CAAC;IACjC,IAAI,CAAClB,uBAAuB,CAAC6B,MAAM,CAACX,UAAU,CAAC;IAC/C,OAAOS,KAAK;EAChB;AACJ;AACA,CAAC,UAAUxD,OAAO,EAAE;EAChBA,OAAO,CAAC2D,QAAQ,GAAGzD,eAAe;AACtC,CAAC,EAAEF,OAAO,KAAKA,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}