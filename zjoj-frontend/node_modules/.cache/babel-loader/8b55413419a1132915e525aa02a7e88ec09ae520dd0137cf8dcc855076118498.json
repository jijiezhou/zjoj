{"ast":null,"code":"import { defineComponent, ref, onMounted, onUnmounted, createVNode, mergeProps, createTextVNode, cloneVNode } from \"vue\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport { getStyle } from \"../_utils/style.js\";\nimport useMenuContext from \"./hooks/use-menu-context.js\";\nimport SubMenu from \"./sub-menu.js\";\nimport { unFragment } from \"../_utils/vue-utils.js\";\nconst OVERFLOW_THRESHOLD = 10;\nfunction getNodeWidth(el) {\n  return el && +el.getBoundingClientRect().width.toFixed(2);\n}\nfunction translatePxToNumber(str) {\n  const result = Number(str.replace(\"px\", \"\"));\n  return Number.isNaN(result) ? 0 : result;\n}\nvar OverflowWrap = defineComponent({\n  name: \"MenuOverflowWrap\",\n  setup(_, {\n    slots\n  }) {\n    const menuContext = useMenuContext();\n    const overflowPrefixCls = `${menuContext.prefixCls}-overflow`;\n    const overflowSubMenuClass = `${overflowPrefixCls}-sub-menu`;\n    const overflowMenuItemClass = `${overflowPrefixCls}-hidden-menu-item`;\n    const overflowSubMenuMirrorClass = `${overflowPrefixCls}-sub-menu-mirror`;\n    const refWrapper = ref();\n    const lastVisibleIndex = ref(null);\n    const refResizeObserver = ref();\n    function computeLastVisibleIndex() {\n      const wrapperElement = refWrapper.value;\n      const wrapperWidth = getNodeWidth(wrapperElement);\n      const childNodeList = [].slice.call(wrapperElement.children);\n      let menuItemIndex = 0;\n      let currentRightWidth = 0;\n      let overflowSubMenuWidth = 0;\n      for (let i = 0; i < childNodeList.length; i++) {\n        const node = childNodeList[i];\n        const classNames = node.className.split(\" \");\n        const isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;\n        const isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;\n        if (isOverflowSubMenu) {\n          continue;\n        }\n        const nodeWidth = getNodeWidth(node) + translatePxToNumber(getStyle(node, \"marginLeft\")) + translatePxToNumber(getStyle(node, \"marginRight\"));\n        if (isOverflowSubMenuMirror) {\n          overflowSubMenuWidth = nodeWidth;\n          continue;\n        }\n        currentRightWidth += nodeWidth;\n        if (currentRightWidth + overflowSubMenuWidth + OVERFLOW_THRESHOLD > wrapperWidth) {\n          lastVisibleIndex.value = menuItemIndex - 1;\n          return;\n        }\n        menuItemIndex++;\n      }\n      lastVisibleIndex.value = null;\n    }\n    onMounted(() => {\n      computeLastVisibleIndex();\n      refResizeObserver.value = new ResizeObserver(entries => {\n        entries.forEach(computeLastVisibleIndex);\n      });\n      if (refWrapper.value) {\n        refResizeObserver.value.observe(refWrapper.value);\n      }\n    });\n    onUnmounted(() => {\n      refResizeObserver.value && refResizeObserver.value.disconnect();\n    });\n    return () => {\n      const renderSubMenu = (children, options) => {\n        const {\n          isMirror = false,\n          props = {}\n        } = options || {};\n        return createVNode(SubMenu, mergeProps({\n          \"key\": `__arco-menu-overflow-sub-menu${isMirror ? \"-mirror\" : \"\"}`,\n          \"class\": isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass\n        }, props), {\n          title: () => createVNode(\"span\", null, [createTextVNode(\"...\")]),\n          default: () => children\n        });\n      };\n      const renderChildren = () => {\n        var _a;\n        const originChildren = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];\n        const children = unFragment(originChildren);\n        let overflowSubMenu = null;\n        const overflowSubMenuMirror = renderSubMenu(null, {\n          isMirror: true\n        });\n        const menuItems = children.map((child, index) => {\n          const item = cloneVNode(child, lastVisibleIndex.value !== null && index > lastVisibleIndex.value ? {\n            class: overflowMenuItemClass\n          } : {\n            class: \"\"\n          });\n          if (lastVisibleIndex.value !== null && index === lastVisibleIndex.value + 1) {\n            const overflowMenuItems = children.slice(index).map(child2 => cloneVNode(child2));\n            overflowSubMenu = renderSubMenu(overflowMenuItems);\n          }\n          return item;\n        });\n        return [overflowSubMenuMirror, ...menuItems, overflowSubMenu];\n      };\n      return createVNode(\"div\", {\n        \"class\": `${overflowPrefixCls}-wrap`,\n        \"ref\": refWrapper\n      }, [renderChildren()]);\n    };\n  }\n});\nexport { OverflowWrap as default };","map":{"version":3,"names":["defineComponent","ref","onMounted","onUnmounted","createVNode","mergeProps","createTextVNode","cloneVNode","ResizeObserver","getStyle","useMenuContext","SubMenu","unFragment","OVERFLOW_THRESHOLD","getNodeWidth","el","getBoundingClientRect","width","toFixed","translatePxToNumber","str","result","Number","replace","isNaN","OverflowWrap","name","setup","_","slots","menuContext","overflowPrefixCls","prefixCls","overflowSubMenuClass","overflowMenuItemClass","overflowSubMenuMirrorClass","refWrapper","lastVisibleIndex","refResizeObserver","computeLastVisibleIndex","wrapperElement","value","wrapperWidth","childNodeList","slice","call","children","menuItemIndex","currentRightWidth","overflowSubMenuWidth","i","length","node","classNames","className","split","isOverflowSubMenu","indexOf","isOverflowSubMenuMirror","nodeWidth","entries","forEach","observe","disconnect","renderSubMenu","options","isMirror","props","title","default","renderChildren","_a","originChildren","overflowSubMenu","overflowSubMenuMirror","menuItems","map","child","index","item","class","overflowMenuItems","child2"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/@arco-design/web-vue/es/menu/overflow-wrap.js"],"sourcesContent":["import { defineComponent, ref, onMounted, onUnmounted, createVNode, mergeProps, createTextVNode, cloneVNode } from \"vue\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport { getStyle } from \"../_utils/style.js\";\nimport useMenuContext from \"./hooks/use-menu-context.js\";\nimport SubMenu from \"./sub-menu.js\";\nimport { unFragment } from \"../_utils/vue-utils.js\";\nconst OVERFLOW_THRESHOLD = 10;\nfunction getNodeWidth(el) {\n  return el && +el.getBoundingClientRect().width.toFixed(2);\n}\nfunction translatePxToNumber(str) {\n  const result = Number(str.replace(\"px\", \"\"));\n  return Number.isNaN(result) ? 0 : result;\n}\nvar OverflowWrap = defineComponent({\n  name: \"MenuOverflowWrap\",\n  setup(_, {\n    slots\n  }) {\n    const menuContext = useMenuContext();\n    const overflowPrefixCls = `${menuContext.prefixCls}-overflow`;\n    const overflowSubMenuClass = `${overflowPrefixCls}-sub-menu`;\n    const overflowMenuItemClass = `${overflowPrefixCls}-hidden-menu-item`;\n    const overflowSubMenuMirrorClass = `${overflowPrefixCls}-sub-menu-mirror`;\n    const refWrapper = ref();\n    const lastVisibleIndex = ref(null);\n    const refResizeObserver = ref();\n    function computeLastVisibleIndex() {\n      const wrapperElement = refWrapper.value;\n      const wrapperWidth = getNodeWidth(wrapperElement);\n      const childNodeList = [].slice.call(wrapperElement.children);\n      let menuItemIndex = 0;\n      let currentRightWidth = 0;\n      let overflowSubMenuWidth = 0;\n      for (let i = 0; i < childNodeList.length; i++) {\n        const node = childNodeList[i];\n        const classNames = node.className.split(\" \");\n        const isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;\n        const isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;\n        if (isOverflowSubMenu) {\n          continue;\n        }\n        const nodeWidth = getNodeWidth(node) + translatePxToNumber(getStyle(node, \"marginLeft\")) + translatePxToNumber(getStyle(node, \"marginRight\"));\n        if (isOverflowSubMenuMirror) {\n          overflowSubMenuWidth = nodeWidth;\n          continue;\n        }\n        currentRightWidth += nodeWidth;\n        if (currentRightWidth + overflowSubMenuWidth + OVERFLOW_THRESHOLD > wrapperWidth) {\n          lastVisibleIndex.value = menuItemIndex - 1;\n          return;\n        }\n        menuItemIndex++;\n      }\n      lastVisibleIndex.value = null;\n    }\n    onMounted(() => {\n      computeLastVisibleIndex();\n      refResizeObserver.value = new ResizeObserver((entries) => {\n        entries.forEach(computeLastVisibleIndex);\n      });\n      if (refWrapper.value) {\n        refResizeObserver.value.observe(refWrapper.value);\n      }\n    });\n    onUnmounted(() => {\n      refResizeObserver.value && refResizeObserver.value.disconnect();\n    });\n    return () => {\n      const renderSubMenu = (children, options) => {\n        const {\n          isMirror = false,\n          props = {}\n        } = options || {};\n        return createVNode(SubMenu, mergeProps({\n          \"key\": `__arco-menu-overflow-sub-menu${isMirror ? \"-mirror\" : \"\"}`,\n          \"class\": isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass\n        }, props), {\n          title: () => createVNode(\"span\", null, [createTextVNode(\"...\")]),\n          default: () => children\n        });\n      };\n      const renderChildren = () => {\n        var _a;\n        const originChildren = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];\n        const children = unFragment(originChildren);\n        let overflowSubMenu = null;\n        const overflowSubMenuMirror = renderSubMenu(null, {\n          isMirror: true\n        });\n        const menuItems = children.map((child, index) => {\n          const item = cloneVNode(child, lastVisibleIndex.value !== null && index > lastVisibleIndex.value ? {\n            class: overflowMenuItemClass\n          } : {\n            class: \"\"\n          });\n          if (lastVisibleIndex.value !== null && index === lastVisibleIndex.value + 1) {\n            const overflowMenuItems = children.slice(index).map((child2) => cloneVNode(child2));\n            overflowSubMenu = renderSubMenu(overflowMenuItems);\n          }\n          return item;\n        });\n        return [overflowSubMenuMirror, ...menuItems, overflowSubMenu];\n      };\n      return createVNode(\"div\", {\n        \"class\": `${overflowPrefixCls}-wrap`,\n        \"ref\": refWrapper\n      }, [renderChildren()]);\n    };\n  }\n});\nexport { OverflowWrap as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}