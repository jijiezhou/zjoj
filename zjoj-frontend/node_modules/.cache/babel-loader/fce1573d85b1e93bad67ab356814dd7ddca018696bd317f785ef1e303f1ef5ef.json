{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\nexport var StorageHint;\n(function (StorageHint) {\n  // A hint to the storage that the storage\n  // does not exist on disk yet. This allows\n  // the storage library to improve startup\n  // time by not checking the storage for data.\n  StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n  // A hint to the storage that the storage\n  // is backed by an in-memory storage.\n  StorageHint[StorageHint[\"STORAGE_IN_MEMORY\"] = 1] = \"STORAGE_IN_MEMORY\";\n})(StorageHint || (StorageHint = {}));\nexport var StorageState;\n(function (StorageState) {\n  StorageState[StorageState[\"None\"] = 0] = \"None\";\n  StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n  StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n  constructor(database, options = Object.create(null)) {\n    super();\n    this.database = database;\n    this.options = options;\n    this._onDidChangeStorage = this._register(new PauseableEmitter());\n    this.onDidChangeStorage = this._onDidChangeStorage.event;\n    this.state = StorageState.None;\n    this.cache = new Map();\n    this.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n    this.pendingDeletes = new Set();\n    this.pendingInserts = new Map();\n    this.whenFlushedCallbacks = [];\n    this.registerListeners();\n  }\n  registerListeners() {\n    this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n  }\n  onDidChangeItemsExternal(e) {\n    var _a, _b;\n    this._onDidChangeStorage.pause();\n    try {\n      // items that change external require us to update our\n      // caches with the values. we just accept the value and\n      // emit an event if there is a change.\n      (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.acceptExternal(key, value));\n      (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.acceptExternal(key, undefined));\n    } finally {\n      this._onDidChangeStorage.resume();\n    }\n  }\n  acceptExternal(key, value) {\n    if (this.state === StorageState.Closed) {\n      return; // Return early if we are already closed\n    }\n    let changed = false;\n    // Item got removed, check for deletion\n    if (isUndefinedOrNull(value)) {\n      changed = this.cache.delete(key);\n    }\n    // Item got updated, check for change\n    else {\n      const currentValue = this.cache.get(key);\n      if (currentValue !== value) {\n        this.cache.set(key, value);\n        changed = true;\n      }\n    }\n    // Signal to outside listeners\n    if (changed) {\n      this._onDidChangeStorage.fire({\n        key,\n        external: true\n      });\n    }\n  }\n  get(key, fallbackValue) {\n    const value = this.cache.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return value;\n  }\n  getBoolean(key, fallbackValue) {\n    const value = this.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return value === 'true';\n  }\n  getNumber(key, fallbackValue) {\n    const value = this.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return parseInt(value, 10);\n  }\n  async set(key, value, external = false) {\n    if (this.state === StorageState.Closed) {\n      return; // Return early if we are already closed\n    }\n    // We remove the key for undefined/null values\n    if (isUndefinedOrNull(value)) {\n      return this.delete(key, external);\n    }\n    // Otherwise, convert to String and store\n    const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n    // Return early if value already set\n    const currentValue = this.cache.get(key);\n    if (currentValue === valueStr) {\n      return;\n    }\n    // Update in cache and pending\n    this.cache.set(key, valueStr);\n    this.pendingInserts.set(key, valueStr);\n    this.pendingDeletes.delete(key);\n    // Event\n    this._onDidChangeStorage.fire({\n      key,\n      external\n    });\n    // Accumulate work by scheduling after timeout\n    return this.doFlush();\n  }\n  async delete(key, external = false) {\n    if (this.state === StorageState.Closed) {\n      return; // Return early if we are already closed\n    }\n    // Remove from cache and add to pending\n    const wasDeleted = this.cache.delete(key);\n    if (!wasDeleted) {\n      return; // Return early if value already deleted\n    }\n    if (!this.pendingDeletes.has(key)) {\n      this.pendingDeletes.add(key);\n    }\n    this.pendingInserts.delete(key);\n    // Event\n    this._onDidChangeStorage.fire({\n      key,\n      external\n    });\n    // Accumulate work by scheduling after timeout\n    return this.doFlush();\n  }\n  get hasPending() {\n    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n  }\n  async flushPending() {\n    if (!this.hasPending) {\n      return; // return early if nothing to do\n    }\n    // Get pending data\n    const updateRequest = {\n      insert: this.pendingInserts,\n      delete: this.pendingDeletes\n    };\n    // Reset pending data for next run\n    this.pendingDeletes = new Set();\n    this.pendingInserts = new Map();\n    // Update in storage and release any\n    // waiters we have once done\n    return this.database.updateItems(updateRequest).finally(() => {\n      var _a;\n      if (!this.hasPending) {\n        while (this.whenFlushedCallbacks.length) {\n          (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n        }\n      }\n    });\n  }\n  async doFlush(delay) {\n    if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n      return this.flushPending(); // return early if in-memory\n    }\n    return this.flushDelayer.trigger(() => this.flushPending(), delay);\n  }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n  constructor() {\n    this.onDidChangeItemsExternal = Event.None;\n    this.items = new Map();\n  }\n  async updateItems(request) {\n    var _a, _b;\n    (_a = request.insert) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.items.set(key, value));\n    (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));\n  }\n}","map":{"version":3,"names":["ThrottledDelayer","Event","PauseableEmitter","Disposable","stringify","isObject","isUndefinedOrNull","StorageHint","StorageState","Storage","constructor","database","options","Object","create","_onDidChangeStorage","_register","onDidChangeStorage","event","state","None","cache","Map","flushDelayer","DEFAULT_FLUSH_DELAY","pendingDeletes","Set","pendingInserts","whenFlushedCallbacks","registerListeners","onDidChangeItemsExternal","e","_a","_b","pause","changed","forEach","value","key","acceptExternal","deleted","undefined","resume","Closed","delete","currentValue","get","set","fire","external","fallbackValue","getBoolean","getNumber","parseInt","valueStr","Array","isArray","String","doFlush","wasDeleted","has","add","hasPending","size","flushPending","updateRequest","insert","updateItems","finally","length","pop","delay","hint","STORAGE_IN_MEMORY","trigger","InMemoryStorageDatabase","items","request"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/parts/storage/common/storage.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\nexport var StorageHint;\n(function (StorageHint) {\n    // A hint to the storage that the storage\n    // does not exist on disk yet. This allows\n    // the storage library to improve startup\n    // time by not checking the storage for data.\n    StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n    // A hint to the storage that the storage\n    // is backed by an in-memory storage.\n    StorageHint[StorageHint[\"STORAGE_IN_MEMORY\"] = 1] = \"STORAGE_IN_MEMORY\";\n})(StorageHint || (StorageHint = {}));\nexport var StorageState;\n(function (StorageState) {\n    StorageState[StorageState[\"None\"] = 0] = \"None\";\n    StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n    StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n    constructor(database, options = Object.create(null)) {\n        super();\n        this.database = database;\n        this.options = options;\n        this._onDidChangeStorage = this._register(new PauseableEmitter());\n        this.onDidChangeStorage = this._onDidChangeStorage.event;\n        this.state = StorageState.None;\n        this.cache = new Map();\n        this.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        this.whenFlushedCallbacks = [];\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n    }\n    onDidChangeItemsExternal(e) {\n        var _a, _b;\n        this._onDidChangeStorage.pause();\n        try {\n            // items that change external require us to update our\n            // caches with the values. we just accept the value and\n            // emit an event if there is a change.\n            (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.acceptExternal(key, value));\n            (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.acceptExternal(key, undefined));\n        }\n        finally {\n            this._onDidChangeStorage.resume();\n        }\n    }\n    acceptExternal(key, value) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        let changed = false;\n        // Item got removed, check for deletion\n        if (isUndefinedOrNull(value)) {\n            changed = this.cache.delete(key);\n        }\n        // Item got updated, check for change\n        else {\n            const currentValue = this.cache.get(key);\n            if (currentValue !== value) {\n                this.cache.set(key, value);\n                changed = true;\n            }\n        }\n        // Signal to outside listeners\n        if (changed) {\n            this._onDidChangeStorage.fire({ key, external: true });\n        }\n    }\n    get(key, fallbackValue) {\n        const value = this.cache.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    }\n    getBoolean(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    }\n    getNumber(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    }\n    async set(key, value, external = false) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        // We remove the key for undefined/null values\n        if (isUndefinedOrNull(value)) {\n            return this.delete(key, external);\n        }\n        // Otherwise, convert to String and store\n        const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n        // Return early if value already set\n        const currentValue = this.cache.get(key);\n        if (currentValue === valueStr) {\n            return;\n        }\n        // Update in cache and pending\n        this.cache.set(key, valueStr);\n        this.pendingInserts.set(key, valueStr);\n        this.pendingDeletes.delete(key);\n        // Event\n        this._onDidChangeStorage.fire({ key, external });\n        // Accumulate work by scheduling after timeout\n        return this.doFlush();\n    }\n    async delete(key, external = false) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        // Remove from cache and add to pending\n        const wasDeleted = this.cache.delete(key);\n        if (!wasDeleted) {\n            return; // Return early if value already deleted\n        }\n        if (!this.pendingDeletes.has(key)) {\n            this.pendingDeletes.add(key);\n        }\n        this.pendingInserts.delete(key);\n        // Event\n        this._onDidChangeStorage.fire({ key, external });\n        // Accumulate work by scheduling after timeout\n        return this.doFlush();\n    }\n    get hasPending() {\n        return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n    }\n    async flushPending() {\n        if (!this.hasPending) {\n            return; // return early if nothing to do\n        }\n        // Get pending data\n        const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n        // Reset pending data for next run\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        // Update in storage and release any\n        // waiters we have once done\n        return this.database.updateItems(updateRequest).finally(() => {\n            var _a;\n            if (!this.hasPending) {\n                while (this.whenFlushedCallbacks.length) {\n                    (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n                }\n            }\n        });\n    }\n    async doFlush(delay) {\n        if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n            return this.flushPending(); // return early if in-memory\n        }\n        return this.flushDelayer.trigger(() => this.flushPending(), delay);\n    }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n    constructor() {\n        this.onDidChangeItemsExternal = Event.None;\n        this.items = new Map();\n    }\n    async updateItems(request) {\n        var _a, _b;\n        (_a = request.insert) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.items.set(key, value));\n        (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}