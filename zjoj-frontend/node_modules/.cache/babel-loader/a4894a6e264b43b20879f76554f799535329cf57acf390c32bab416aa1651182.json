{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n  constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n    this._richEditBracketBrand = undefined;\n    this.languageId = languageId;\n    this.index = index;\n    this.open = open;\n    this.close = close;\n    this.forwardRegex = forwardRegex;\n    this.reversedRegex = reversedRegex;\n    this._openSet = RichEditBracket._toSet(this.open);\n    this._closeSet = RichEditBracket._toSet(this.close);\n  }\n  /**\n   * Check if the provided `text` is an open bracket in this group.\n   */\n  isOpen(text) {\n    return this._openSet.has(text);\n  }\n  /**\n   * Check if the provided `text` is a close bracket in this group.\n   */\n  isClose(text) {\n    return this._closeSet.has(text);\n  }\n  static _toSet(arr) {\n    const result = new Set();\n    for (const element of arr) {\n      result.add(element);\n    }\n    return result;\n  }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n  const N = brackets.length;\n  brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n  const group = [];\n  for (let i = 0; i < N; i++) {\n    group[i] = i;\n  }\n  const areOverlapping = (a, b) => {\n    const [aOpen, aClose] = a;\n    const [bOpen, bClose] = b;\n    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;\n  };\n  const mergeGroups = (g1, g2) => {\n    const newG = Math.min(g1, g2);\n    const oldG = Math.max(g1, g2);\n    for (let i = 0; i < N; i++) {\n      if (group[i] === oldG) {\n        group[i] = newG;\n      }\n    }\n  };\n  // group together brackets that have the same open or the same close sequence\n  for (let i = 0; i < N; i++) {\n    const a = brackets[i];\n    for (let j = i + 1; j < N; j++) {\n      const b = brackets[j];\n      if (areOverlapping(a, b)) {\n        mergeGroups(group[i], group[j]);\n      }\n    }\n  }\n  const result = [];\n  for (let g = 0; g < N; g++) {\n    const currentOpen = [];\n    const currentClose = [];\n    for (let i = 0; i < N; i++) {\n      if (group[i] === g) {\n        const [open, close] = brackets[i];\n        currentOpen.push(open);\n        currentClose.push(close);\n      }\n    }\n    if (currentOpen.length > 0) {\n      result.push({\n        open: currentOpen,\n        close: currentClose\n      });\n    }\n  }\n  return result;\n}\nexport class RichEditBrackets {\n  constructor(languageId, _brackets) {\n    this._richEditBracketsBrand = undefined;\n    const brackets = groupFuzzyBrackets(_brackets);\n    this.brackets = brackets.map((b, index) => {\n      return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n    });\n    this.forwardRegex = getRegexForBrackets(this.brackets);\n    this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n    this.textIsBracket = {};\n    this.textIsOpenBracket = {};\n    this.maxBracketLength = 0;\n    for (const bracket of this.brackets) {\n      for (const open of bracket.open) {\n        this.textIsBracket[open] = bracket;\n        this.textIsOpenBracket[open] = true;\n        this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n      }\n      for (const close of bracket.close) {\n        this.textIsBracket[close] = bracket;\n        this.textIsOpenBracket[close] = false;\n        this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n      }\n    }\n  }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n  for (let i = 0, len = brackets.length; i < len; i++) {\n    if (i === currentIndex) {\n      continue;\n    }\n    const bracket = brackets[i];\n    for (const open of bracket.open) {\n      if (open.indexOf(str) >= 0) {\n        dest.push(open);\n      }\n    }\n    for (const close of bracket.close) {\n      if (close.indexOf(str) >= 0) {\n        dest.push(close);\n      }\n    }\n  }\n}\nfunction lengthcmp(a, b) {\n  return a.length - b.length;\n}\nfunction unique(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  const result = [];\n  const seen = new Set();\n  for (const element of arr) {\n    if (seen.has(element)) {\n      continue;\n    }\n    result.push(element);\n    seen.add(element);\n  }\n  return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n  let pieces = [];\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n  let pieces = [];\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n  // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n  const insertWordBoundaries = /^[\\w ]+$/.test(str);\n  str = strings.escapeRegExpCharacters(str);\n  return insertWordBoundaries ? `\\\\b${str}\\\\b` : str;\n}\nfunction createBracketOrRegExp(pieces) {\n  const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n  return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = function () {\n  function reverse(str) {\n    // create a Uint16Array and then use a TextDecoder to create a string\n    const arr = new Uint16Array(str.length);\n    let offset = 0;\n    for (let i = str.length - 1; i >= 0; i--) {\n      arr[offset++] = str.charCodeAt(i);\n    }\n    return stringBuilder.getPlatformTextDecoder().decode(arr);\n  }\n  let lastInput = null;\n  let lastOutput = null;\n  return function toReversedString(str) {\n    if (lastInput !== str) {\n      lastInput = str;\n      lastOutput = reverse(lastInput);\n    }\n    return lastOutput;\n  };\n}();\nexport class BracketsUtils {\n  static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n    const m = reversedText.match(reversedBracketRegex);\n    if (!m) {\n      return null;\n    }\n    const matchOffset = reversedText.length - (m.index || 0);\n    const matchLength = m[0].length;\n    const absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n  }\n  static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n    const reversedLineText = toReversedString(lineText);\n    const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n    return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n  }\n  static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n    const m = text.match(bracketRegex);\n    if (!m) {\n      return null;\n    }\n    const matchOffset = m.index || 0;\n    const matchLength = m[0].length;\n    if (matchLength === 0) {\n      return null;\n    }\n    const absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n  }\n  static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    const substr = lineText.substring(startOffset, endOffset);\n    return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n  }\n}","map":{"version":3,"names":["strings","stringBuilder","Range","RichEditBracket","constructor","languageId","index","open","close","forwardRegex","reversedRegex","_richEditBracketBrand","undefined","_openSet","_toSet","_closeSet","isOpen","text","has","isClose","arr","result","Set","element","add","groupFuzzyBrackets","brackets","N","length","map","b","toLowerCase","group","i","areOverlapping","a","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","Math","min","oldG","max","j","g","currentOpen","currentClose","push","RichEditBrackets","_brackets","_richEditBracketsBrand","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","textIsOpenBracket","maxBracketLength","bracket","collectSuperstrings","str","currentIndex","dest","len","indexOf","lengthcmp","unique","seen","pieces","concat","sort","reverse","createBracketOrRegExp","toReversedString","prepareBracketForRegExp","insertWordBoundaries","test","escapeRegExpCharacters","regexStr","join","createRegExp","Uint16Array","offset","charCodeAt","getPlatformTextDecoder","decode","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedBracketRegex","lineNumber","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","findPrevBracketInRange","lineText","startOffset","endOffset","reversedLineText","reversedSubstr","substring","findNextBracketInText","bracketRegex","findNextBracketInRange","substr"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}