{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var inputLatency;\n(function (inputLatency) {\n  const totalKeydownTime = {\n    total: 0,\n    min: Number.MAX_VALUE,\n    max: 0\n  };\n  const totalInputTime = {\n    ...totalKeydownTime\n  };\n  const totalRenderTime = {\n    ...totalKeydownTime\n  };\n  const totalInputLatencyTime = {\n    ...totalKeydownTime\n  };\n  let measurementsCount = 0;\n  const state = {\n    keydown: 0 /* EventPhase.Before */,\n    input: 0 /* EventPhase.Before */,\n    render: 0 /* EventPhase.Before */\n  };\n  /**\n   * Record the start of the keydown event.\n   */\n  function onKeyDown() {\n    /** Direct Check C. See explanation in {@link recordIfFinished} */\n    recordIfFinished();\n    performance.mark('inputlatency/start');\n    performance.mark('keydown/start');\n    state.keydown = 1 /* EventPhase.InProgress */;\n    queueMicrotask(markKeyDownEnd);\n  }\n  inputLatency.onKeyDown = onKeyDown;\n  /**\n   * Mark the end of the keydown event.\n   */\n  function markKeyDownEnd() {\n    if (state.keydown === 1 /* EventPhase.InProgress */) {\n      performance.mark('keydown/end');\n      state.keydown = 2 /* EventPhase.Finished */;\n    }\n  }\n  /**\n   * Record the start of the beforeinput event.\n   */\n  function onBeforeInput() {\n    performance.mark('input/start');\n    state.input = 1 /* EventPhase.InProgress */;\n    /** Schedule Task A. See explanation in {@link recordIfFinished} */\n    scheduleRecordIfFinishedTask();\n  }\n  inputLatency.onBeforeInput = onBeforeInput;\n  /**\n   * Record the start of the input event.\n   */\n  function onInput() {\n    if (state.input === 0 /* EventPhase.Before */) {\n      // it looks like we didn't receive a `beforeinput`\n      onBeforeInput();\n    }\n    queueMicrotask(markInputEnd);\n  }\n  inputLatency.onInput = onInput;\n  function markInputEnd() {\n    if (state.input === 1 /* EventPhase.InProgress */) {\n      performance.mark('input/end');\n      state.input = 2 /* EventPhase.Finished */;\n    }\n  }\n  /**\n   * Record the start of the keyup event.\n   */\n  function onKeyUp() {\n    /** Direct Check D. See explanation in {@link recordIfFinished} */\n    recordIfFinished();\n  }\n  inputLatency.onKeyUp = onKeyUp;\n  /**\n   * Record the start of the selectionchange event.\n   */\n  function onSelectionChange() {\n    /** Direct Check E. See explanation in {@link recordIfFinished} */\n    recordIfFinished();\n  }\n  inputLatency.onSelectionChange = onSelectionChange;\n  /**\n   * Record the start of the animation frame performing the rendering.\n   */\n  function onRenderStart() {\n    // Render may be triggered during input, but we only measure the following animation frame\n    if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 0 /* EventPhase.Before */) {\n      // Only measure the first render after keyboard input\n      performance.mark('render/start');\n      state.render = 1 /* EventPhase.InProgress */;\n      queueMicrotask(markRenderEnd);\n      /** Schedule Task B. See explanation in {@link recordIfFinished} */\n      scheduleRecordIfFinishedTask();\n    }\n  }\n  inputLatency.onRenderStart = onRenderStart;\n  /**\n   * Mark the end of the animation frame performing the rendering.\n   */\n  function markRenderEnd() {\n    if (state.render === 1 /* EventPhase.InProgress */) {\n      performance.mark('render/end');\n      state.render = 2 /* EventPhase.Finished */;\n    }\n  }\n  function scheduleRecordIfFinishedTask() {\n    // Here we can safely assume that the `setTimeout` will not be\n    // artificially delayed by 4ms because we schedule it from\n    // event handlers\n    setTimeout(recordIfFinished);\n  }\n  /**\n   * Record the input latency sample if input handling and rendering are finished.\n   *\n   * The challenge here is that we want to record the latency in such a way that it includes\n   * also the layout and painting work the browser does during the animation frame task.\n   *\n   * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n   * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n   * so we need to use multiple strategies to make sure our task runs before others:\n   *\n   * We schedule tasks (A and B):\n   *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n   *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n   *      chance of being the very first task after the animation frame and thus will record the input latency.\n   *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n   *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n   *\n   * We do direct checks in browser event handlers (C, D, E):\n   *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n   *      so we do a direct check in the keydown event handler (C).\n   *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n   *      do a direct check there too (E).\n   *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n   */\n  function recordIfFinished() {\n    if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 2 /* EventPhase.Finished */) {\n      performance.mark('inputlatency/end');\n      performance.measure('keydown', 'keydown/start', 'keydown/end');\n      performance.measure('input', 'input/start', 'input/end');\n      performance.measure('render', 'render/start', 'render/end');\n      performance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n      addMeasure('keydown', totalKeydownTime);\n      addMeasure('input', totalInputTime);\n      addMeasure('render', totalRenderTime);\n      addMeasure('inputlatency', totalInputLatencyTime);\n      // console.info(\n      // \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n      // \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n      // \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n      // \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n      // \t`]`\n      // );\n      measurementsCount++;\n      reset();\n    }\n  }\n  function addMeasure(entryName, cumulativeMeasurement) {\n    const duration = performance.getEntriesByName(entryName)[0].duration;\n    cumulativeMeasurement.total += duration;\n    cumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n    cumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n  }\n  /**\n   * Clear the current sample.\n   */\n  function reset() {\n    performance.clearMarks('keydown/start');\n    performance.clearMarks('keydown/end');\n    performance.clearMarks('input/start');\n    performance.clearMarks('input/end');\n    performance.clearMarks('render/start');\n    performance.clearMarks('render/end');\n    performance.clearMarks('inputlatency/start');\n    performance.clearMarks('inputlatency/end');\n    performance.clearMeasures('keydown');\n    performance.clearMeasures('input');\n    performance.clearMeasures('render');\n    performance.clearMeasures('inputlatency');\n    state.keydown = 0 /* EventPhase.Before */;\n    state.input = 0 /* EventPhase.Before */;\n    state.render = 0 /* EventPhase.Before */;\n  }\n  /**\n   * Gets all input latency samples and clears the internal buffers to start recording a new set\n   * of samples.\n   */\n  function getAndClearMeasurements() {\n    if (measurementsCount === 0) {\n      return undefined;\n    }\n    // Assemble the result\n    const result = {\n      keydown: cumulativeToFinalMeasurement(totalKeydownTime),\n      input: cumulativeToFinalMeasurement(totalInputTime),\n      render: cumulativeToFinalMeasurement(totalRenderTime),\n      total: cumulativeToFinalMeasurement(totalInputLatencyTime),\n      sampleCount: measurementsCount\n    };\n    // Clear the cumulative measurements\n    clearCumulativeMeasurement(totalKeydownTime);\n    clearCumulativeMeasurement(totalInputTime);\n    clearCumulativeMeasurement(totalRenderTime);\n    clearCumulativeMeasurement(totalInputLatencyTime);\n    measurementsCount = 0;\n    return result;\n  }\n  inputLatency.getAndClearMeasurements = getAndClearMeasurements;\n  function cumulativeToFinalMeasurement(cumulative) {\n    return {\n      average: cumulative.total / measurementsCount,\n      max: cumulative.max,\n      min: cumulative.min\n    };\n  }\n  function clearCumulativeMeasurement(cumulative) {\n    cumulative.total = 0;\n    cumulative.min = Number.MAX_VALUE;\n    cumulative.max = 0;\n  }\n})(inputLatency || (inputLatency = {}));","map":{"version":3,"names":["inputLatency","totalKeydownTime","total","min","Number","MAX_VALUE","max","totalInputTime","totalRenderTime","totalInputLatencyTime","measurementsCount","state","keydown","input","render","onKeyDown","recordIfFinished","performance","mark","queueMicrotask","markKeyDownEnd","onBeforeInput","scheduleRecordIfFinishedTask","onInput","markInputEnd","onKeyUp","onSelectionChange","onRenderStart","markRenderEnd","setTimeout","measure","addMeasure","reset","entryName","cumulativeMeasurement","duration","getEntriesByName","Math","clearMarks","clearMeasures","getAndClearMeasurements","undefined","result","cumulativeToFinalMeasurement","sampleCount","clearCumulativeMeasurement","cumulative","average"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/browser/performance.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var inputLatency;\n(function (inputLatency) {\n    const totalKeydownTime = { total: 0, min: Number.MAX_VALUE, max: 0 };\n    const totalInputTime = { ...totalKeydownTime };\n    const totalRenderTime = { ...totalKeydownTime };\n    const totalInputLatencyTime = { ...totalKeydownTime };\n    let measurementsCount = 0;\n    const state = {\n        keydown: 0 /* EventPhase.Before */,\n        input: 0 /* EventPhase.Before */,\n        render: 0 /* EventPhase.Before */,\n    };\n    /**\n     * Record the start of the keydown event.\n     */\n    function onKeyDown() {\n        /** Direct Check C. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n        performance.mark('inputlatency/start');\n        performance.mark('keydown/start');\n        state.keydown = 1 /* EventPhase.InProgress */;\n        queueMicrotask(markKeyDownEnd);\n    }\n    inputLatency.onKeyDown = onKeyDown;\n    /**\n     * Mark the end of the keydown event.\n     */\n    function markKeyDownEnd() {\n        if (state.keydown === 1 /* EventPhase.InProgress */) {\n            performance.mark('keydown/end');\n            state.keydown = 2 /* EventPhase.Finished */;\n        }\n    }\n    /**\n     * Record the start of the beforeinput event.\n     */\n    function onBeforeInput() {\n        performance.mark('input/start');\n        state.input = 1 /* EventPhase.InProgress */;\n        /** Schedule Task A. See explanation in {@link recordIfFinished} */\n        scheduleRecordIfFinishedTask();\n    }\n    inputLatency.onBeforeInput = onBeforeInput;\n    /**\n     * Record the start of the input event.\n     */\n    function onInput() {\n        if (state.input === 0 /* EventPhase.Before */) {\n            // it looks like we didn't receive a `beforeinput`\n            onBeforeInput();\n        }\n        queueMicrotask(markInputEnd);\n    }\n    inputLatency.onInput = onInput;\n    function markInputEnd() {\n        if (state.input === 1 /* EventPhase.InProgress */) {\n            performance.mark('input/end');\n            state.input = 2 /* EventPhase.Finished */;\n        }\n    }\n    /**\n     * Record the start of the keyup event.\n     */\n    function onKeyUp() {\n        /** Direct Check D. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n    }\n    inputLatency.onKeyUp = onKeyUp;\n    /**\n     * Record the start of the selectionchange event.\n     */\n    function onSelectionChange() {\n        /** Direct Check E. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n    }\n    inputLatency.onSelectionChange = onSelectionChange;\n    /**\n     * Record the start of the animation frame performing the rendering.\n     */\n    function onRenderStart() {\n        // Render may be triggered during input, but we only measure the following animation frame\n        if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 0 /* EventPhase.Before */) {\n            // Only measure the first render after keyboard input\n            performance.mark('render/start');\n            state.render = 1 /* EventPhase.InProgress */;\n            queueMicrotask(markRenderEnd);\n            /** Schedule Task B. See explanation in {@link recordIfFinished} */\n            scheduleRecordIfFinishedTask();\n        }\n    }\n    inputLatency.onRenderStart = onRenderStart;\n    /**\n     * Mark the end of the animation frame performing the rendering.\n     */\n    function markRenderEnd() {\n        if (state.render === 1 /* EventPhase.InProgress */) {\n            performance.mark('render/end');\n            state.render = 2 /* EventPhase.Finished */;\n        }\n    }\n    function scheduleRecordIfFinishedTask() {\n        // Here we can safely assume that the `setTimeout` will not be\n        // artificially delayed by 4ms because we schedule it from\n        // event handlers\n        setTimeout(recordIfFinished);\n    }\n    /**\n     * Record the input latency sample if input handling and rendering are finished.\n     *\n     * The challenge here is that we want to record the latency in such a way that it includes\n     * also the layout and painting work the browser does during the animation frame task.\n     *\n     * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n     * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n     * so we need to use multiple strategies to make sure our task runs before others:\n     *\n     * We schedule tasks (A and B):\n     *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n     *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n     *      chance of being the very first task after the animation frame and thus will record the input latency.\n     *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n     *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n     *\n     * We do direct checks in browser event handlers (C, D, E):\n     *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n     *      so we do a direct check in the keydown event handler (C).\n     *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n     *      do a direct check there too (E).\n     *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n     */\n    function recordIfFinished() {\n        if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 2 /* EventPhase.Finished */) {\n            performance.mark('inputlatency/end');\n            performance.measure('keydown', 'keydown/start', 'keydown/end');\n            performance.measure('input', 'input/start', 'input/end');\n            performance.measure('render', 'render/start', 'render/end');\n            performance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n            addMeasure('keydown', totalKeydownTime);\n            addMeasure('input', totalInputTime);\n            addMeasure('render', totalRenderTime);\n            addMeasure('inputlatency', totalInputLatencyTime);\n            // console.info(\n            // \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n            // \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n            // \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n            // \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n            // \t`]`\n            // );\n            measurementsCount++;\n            reset();\n        }\n    }\n    function addMeasure(entryName, cumulativeMeasurement) {\n        const duration = performance.getEntriesByName(entryName)[0].duration;\n        cumulativeMeasurement.total += duration;\n        cumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n        cumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n    }\n    /**\n     * Clear the current sample.\n     */\n    function reset() {\n        performance.clearMarks('keydown/start');\n        performance.clearMarks('keydown/end');\n        performance.clearMarks('input/start');\n        performance.clearMarks('input/end');\n        performance.clearMarks('render/start');\n        performance.clearMarks('render/end');\n        performance.clearMarks('inputlatency/start');\n        performance.clearMarks('inputlatency/end');\n        performance.clearMeasures('keydown');\n        performance.clearMeasures('input');\n        performance.clearMeasures('render');\n        performance.clearMeasures('inputlatency');\n        state.keydown = 0 /* EventPhase.Before */;\n        state.input = 0 /* EventPhase.Before */;\n        state.render = 0 /* EventPhase.Before */;\n    }\n    /**\n     * Gets all input latency samples and clears the internal buffers to start recording a new set\n     * of samples.\n     */\n    function getAndClearMeasurements() {\n        if (measurementsCount === 0) {\n            return undefined;\n        }\n        // Assemble the result\n        const result = {\n            keydown: cumulativeToFinalMeasurement(totalKeydownTime),\n            input: cumulativeToFinalMeasurement(totalInputTime),\n            render: cumulativeToFinalMeasurement(totalRenderTime),\n            total: cumulativeToFinalMeasurement(totalInputLatencyTime),\n            sampleCount: measurementsCount\n        };\n        // Clear the cumulative measurements\n        clearCumulativeMeasurement(totalKeydownTime);\n        clearCumulativeMeasurement(totalInputTime);\n        clearCumulativeMeasurement(totalRenderTime);\n        clearCumulativeMeasurement(totalInputLatencyTime);\n        measurementsCount = 0;\n        return result;\n    }\n    inputLatency.getAndClearMeasurements = getAndClearMeasurements;\n    function cumulativeToFinalMeasurement(cumulative) {\n        return {\n            average: cumulative.total / measurementsCount,\n            max: cumulative.max,\n            min: cumulative.min,\n        };\n    }\n    function clearCumulativeMeasurement(cumulative) {\n        cumulative.total = 0;\n        cumulative.min = Number.MAX_VALUE;\n        cumulative.max = 0;\n    }\n})(inputLatency || (inputLatency = {}));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,IAAIA,YAAY;AACvB,CAAC,UAAUA,YAAY,EAAE;EACrB,MAAMC,gBAAgB,GAAG;IAAEC,KAAK,EAAE,CAAC;IAAEC,GAAG,EAAEC,MAAM,CAACC,SAAS;IAAEC,GAAG,EAAE;EAAE,CAAC;EACpE,MAAMC,cAAc,GAAG;IAAE,GAAGN;EAAiB,CAAC;EAC9C,MAAMO,eAAe,GAAG;IAAE,GAAGP;EAAiB,CAAC;EAC/C,MAAMQ,qBAAqB,GAAG;IAAE,GAAGR;EAAiB,CAAC;EACrD,IAAIS,iBAAiB,GAAG,CAAC;EACzB,MAAMC,KAAK,GAAG;IACVC,OAAO,EAAE,CAAC,CAAC;IACXC,KAAK,EAAE,CAAC,CAAC;IACTC,MAAM,EAAE,CAAC,CAAC;EACd,CAAC;EACD;AACJ;AACA;EACI,SAASC,SAASA,CAAA,EAAG;IACjB;IACAC,gBAAgB,CAAC,CAAC;IAClBC,WAAW,CAACC,IAAI,CAAC,oBAAoB,CAAC;IACtCD,WAAW,CAACC,IAAI,CAAC,eAAe,CAAC;IACjCP,KAAK,CAACC,OAAO,GAAG,CAAC,CAAC;IAClBO,cAAc,CAACC,cAAc,CAAC;EAClC;EACApB,YAAY,CAACe,SAAS,GAAGA,SAAS;EAClC;AACJ;AACA;EACI,SAASK,cAAcA,CAAA,EAAG;IACtB,IAAIT,KAAK,CAACC,OAAO,KAAK,CAAC,CAAC,6BAA6B;MACjDK,WAAW,CAACC,IAAI,CAAC,aAAa,CAAC;MAC/BP,KAAK,CAACC,OAAO,GAAG,CAAC,CAAC;IACtB;EACJ;EACA;AACJ;AACA;EACI,SAASS,aAAaA,CAAA,EAAG;IACrBJ,WAAW,CAACC,IAAI,CAAC,aAAa,CAAC;IAC/BP,KAAK,CAACE,KAAK,GAAG,CAAC,CAAC;IAChB;IACAS,4BAA4B,CAAC,CAAC;EAClC;EACAtB,YAAY,CAACqB,aAAa,GAAGA,aAAa;EAC1C;AACJ;AACA;EACI,SAASE,OAAOA,CAAA,EAAG;IACf,IAAIZ,KAAK,CAACE,KAAK,KAAK,CAAC,CAAC,yBAAyB;MAC3C;MACAQ,aAAa,CAAC,CAAC;IACnB;IACAF,cAAc,CAACK,YAAY,CAAC;EAChC;EACAxB,YAAY,CAACuB,OAAO,GAAGA,OAAO;EAC9B,SAASC,YAAYA,CAAA,EAAG;IACpB,IAAIb,KAAK,CAACE,KAAK,KAAK,CAAC,CAAC,6BAA6B;MAC/CI,WAAW,CAACC,IAAI,CAAC,WAAW,CAAC;MAC7BP,KAAK,CAACE,KAAK,GAAG,CAAC,CAAC;IACpB;EACJ;EACA;AACJ;AACA;EACI,SAASY,OAAOA,CAAA,EAAG;IACf;IACAT,gBAAgB,CAAC,CAAC;EACtB;EACAhB,YAAY,CAACyB,OAAO,GAAGA,OAAO;EAC9B;AACJ;AACA;EACI,SAASC,iBAAiBA,CAAA,EAAG;IACzB;IACAV,gBAAgB,CAAC,CAAC;EACtB;EACAhB,YAAY,CAAC0B,iBAAiB,GAAGA,iBAAiB;EAClD;AACJ;AACA;EACI,SAASC,aAAaA,CAAA,EAAG;IACrB;IACA,IAAIhB,KAAK,CAACC,OAAO,KAAK,CAAC,CAAC,6BAA6BD,KAAK,CAACE,KAAK,KAAK,CAAC,CAAC,6BAA6BF,KAAK,CAACG,MAAM,KAAK,CAAC,CAAC,yBAAyB;MAC5I;MACAG,WAAW,CAACC,IAAI,CAAC,cAAc,CAAC;MAChCP,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;MACjBK,cAAc,CAACS,aAAa,CAAC;MAC7B;MACAN,4BAA4B,CAAC,CAAC;IAClC;EACJ;EACAtB,YAAY,CAAC2B,aAAa,GAAGA,aAAa;EAC1C;AACJ;AACA;EACI,SAASC,aAAaA,CAAA,EAAG;IACrB,IAAIjB,KAAK,CAACG,MAAM,KAAK,CAAC,CAAC,6BAA6B;MAChDG,WAAW,CAACC,IAAI,CAAC,YAAY,CAAC;MAC9BP,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;IACrB;EACJ;EACA,SAASQ,4BAA4BA,CAAA,EAAG;IACpC;IACA;IACA;IACAO,UAAU,CAACb,gBAAgB,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASA,gBAAgBA,CAAA,EAAG;IACxB,IAAIL,KAAK,CAACC,OAAO,KAAK,CAAC,CAAC,6BAA6BD,KAAK,CAACE,KAAK,KAAK,CAAC,CAAC,6BAA6BF,KAAK,CAACG,MAAM,KAAK,CAAC,CAAC,2BAA2B;MAC9IG,WAAW,CAACC,IAAI,CAAC,kBAAkB,CAAC;MACpCD,WAAW,CAACa,OAAO,CAAC,SAAS,EAAE,eAAe,EAAE,aAAa,CAAC;MAC9Db,WAAW,CAACa,OAAO,CAAC,OAAO,EAAE,aAAa,EAAE,WAAW,CAAC;MACxDb,WAAW,CAACa,OAAO,CAAC,QAAQ,EAAE,cAAc,EAAE,YAAY,CAAC;MAC3Db,WAAW,CAACa,OAAO,CAAC,cAAc,EAAE,oBAAoB,EAAE,kBAAkB,CAAC;MAC7EC,UAAU,CAAC,SAAS,EAAE9B,gBAAgB,CAAC;MACvC8B,UAAU,CAAC,OAAO,EAAExB,cAAc,CAAC;MACnCwB,UAAU,CAAC,QAAQ,EAAEvB,eAAe,CAAC;MACrCuB,UAAU,CAAC,cAAc,EAAEtB,qBAAqB,CAAC;MACjD;MACA;MACA;MACA;MACA;MACA;MACA;MACAC,iBAAiB,EAAE;MACnBsB,KAAK,CAAC,CAAC;IACX;EACJ;EACA,SAASD,UAAUA,CAACE,SAAS,EAAEC,qBAAqB,EAAE;IAClD,MAAMC,QAAQ,GAAGlB,WAAW,CAACmB,gBAAgB,CAACH,SAAS,CAAC,CAAC,CAAC,CAAC,CAACE,QAAQ;IACpED,qBAAqB,CAAChC,KAAK,IAAIiC,QAAQ;IACvCD,qBAAqB,CAAC/B,GAAG,GAAGkC,IAAI,CAAClC,GAAG,CAAC+B,qBAAqB,CAAC/B,GAAG,EAAEgC,QAAQ,CAAC;IACzED,qBAAqB,CAAC5B,GAAG,GAAG+B,IAAI,CAAC/B,GAAG,CAAC4B,qBAAqB,CAAC5B,GAAG,EAAE6B,QAAQ,CAAC;EAC7E;EACA;AACJ;AACA;EACI,SAASH,KAAKA,CAAA,EAAG;IACbf,WAAW,CAACqB,UAAU,CAAC,eAAe,CAAC;IACvCrB,WAAW,CAACqB,UAAU,CAAC,aAAa,CAAC;IACrCrB,WAAW,CAACqB,UAAU,CAAC,aAAa,CAAC;IACrCrB,WAAW,CAACqB,UAAU,CAAC,WAAW,CAAC;IACnCrB,WAAW,CAACqB,UAAU,CAAC,cAAc,CAAC;IACtCrB,WAAW,CAACqB,UAAU,CAAC,YAAY,CAAC;IACpCrB,WAAW,CAACqB,UAAU,CAAC,oBAAoB,CAAC;IAC5CrB,WAAW,CAACqB,UAAU,CAAC,kBAAkB,CAAC;IAC1CrB,WAAW,CAACsB,aAAa,CAAC,SAAS,CAAC;IACpCtB,WAAW,CAACsB,aAAa,CAAC,OAAO,CAAC;IAClCtB,WAAW,CAACsB,aAAa,CAAC,QAAQ,CAAC;IACnCtB,WAAW,CAACsB,aAAa,CAAC,cAAc,CAAC;IACzC5B,KAAK,CAACC,OAAO,GAAG,CAAC,CAAC;IAClBD,KAAK,CAACE,KAAK,GAAG,CAAC,CAAC;IAChBF,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;EACrB;EACA;AACJ;AACA;AACA;EACI,SAAS0B,uBAAuBA,CAAA,EAAG;IAC/B,IAAI9B,iBAAiB,KAAK,CAAC,EAAE;MACzB,OAAO+B,SAAS;IACpB;IACA;IACA,MAAMC,MAAM,GAAG;MACX9B,OAAO,EAAE+B,4BAA4B,CAAC1C,gBAAgB,CAAC;MACvDY,KAAK,EAAE8B,4BAA4B,CAACpC,cAAc,CAAC;MACnDO,MAAM,EAAE6B,4BAA4B,CAACnC,eAAe,CAAC;MACrDN,KAAK,EAAEyC,4BAA4B,CAAClC,qBAAqB,CAAC;MAC1DmC,WAAW,EAAElC;IACjB,CAAC;IACD;IACAmC,0BAA0B,CAAC5C,gBAAgB,CAAC;IAC5C4C,0BAA0B,CAACtC,cAAc,CAAC;IAC1CsC,0BAA0B,CAACrC,eAAe,CAAC;IAC3CqC,0BAA0B,CAACpC,qBAAqB,CAAC;IACjDC,iBAAiB,GAAG,CAAC;IACrB,OAAOgC,MAAM;EACjB;EACA1C,YAAY,CAACwC,uBAAuB,GAAGA,uBAAuB;EAC9D,SAASG,4BAA4BA,CAACG,UAAU,EAAE;IAC9C,OAAO;MACHC,OAAO,EAAED,UAAU,CAAC5C,KAAK,GAAGQ,iBAAiB;MAC7CJ,GAAG,EAAEwC,UAAU,CAACxC,GAAG;MACnBH,GAAG,EAAE2C,UAAU,CAAC3C;IACpB,CAAC;EACL;EACA,SAAS0C,0BAA0BA,CAACC,UAAU,EAAE;IAC5CA,UAAU,CAAC5C,KAAK,GAAG,CAAC;IACpB4C,UAAU,CAAC3C,GAAG,GAAGC,MAAM,CAACC,SAAS;IACjCyC,UAAU,CAACxC,GAAG,GAAG,CAAC;EACtB;AACJ,CAAC,EAAEN,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}