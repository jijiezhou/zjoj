{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n  constructor(lineNumber, column, leftoverVisibleColumns) {\n    this._cursorPositionBrand = undefined;\n    this.lineNumber = lineNumber;\n    this.column = column;\n    this.leftoverVisibleColumns = leftoverVisibleColumns;\n  }\n}\nexport class MoveOperations {\n  static leftPosition(model, position) {\n    if (position.column > model.getLineMinColumn(position.lineNumber)) {\n      return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n    } else if (position.lineNumber > 1) {\n      const newLineNumber = position.lineNumber - 1;\n      return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n    } else {\n      return position;\n    }\n  }\n  static leftPositionAtomicSoftTabs(model, position, tabSize) {\n    if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n      const minColumn = model.getLineMinColumn(position.lineNumber);\n      const lineContent = model.getLineContent(position.lineNumber);\n      const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n      if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n        return new Position(position.lineNumber, newPosition + 1);\n      }\n    }\n    return this.leftPosition(model, position);\n  }\n  static left(config, model, position) {\n    const pos = config.stickyTabStops ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize) : MoveOperations.leftPosition(model, position);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n  /**\n   * @param noOfColumns Must be either `1`\n   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n  */\n  static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If the user has a selection and does not want to extend it,\n      // put the cursor at the beginning of the selection.\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      // This has no effect if noOfColumns === 1.\n      // It is ok to do so in the half-line scenario.\n      const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n      // We clip the position before normalization, as normalization is not defined\n      // for possibly negative columns.\n      const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n      const p = MoveOperations.left(config, model, normalizedPos);\n      lineNumber = p.lineNumber;\n      column = p.column;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  /**\n   * Adjusts the column so that it is within min/max of the line.\n  */\n  static clipPositionColumn(position, model) {\n    return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n  }\n  static clipRange(value, min, max) {\n    if (value < min) {\n      return min;\n    }\n    if (value > max) {\n      return max;\n    }\n    return value;\n  }\n  static rightPosition(model, lineNumber, column) {\n    if (column < model.getLineMaxColumn(lineNumber)) {\n      column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n    } else if (lineNumber < model.getLineCount()) {\n      lineNumber = lineNumber + 1;\n      column = model.getLineMinColumn(lineNumber);\n    }\n    return new Position(lineNumber, column);\n  }\n  static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n    if (column < model.getLineIndentColumn(lineNumber)) {\n      const lineContent = model.getLineContent(lineNumber);\n      const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n      if (newPosition !== -1) {\n        return new Position(lineNumber, newPosition + 1);\n      }\n    }\n    return this.rightPosition(model, lineNumber, column);\n  }\n  static right(config, model, position) {\n    const pos = config.stickyTabStops ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize) : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n  static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      const pos = cursor.position.delta(undefined, noOfColumns - 1);\n      const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n      const r = MoveOperations.right(config, model, normalizedPos);\n      lineNumber = r.lineNumber;\n      column = r.column;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n    const lineCount = model.getLineCount();\n    const wasOnFirstPosition = lineNumber === 1 && column === 1;\n    const wasOnLastPosition = lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber);\n    const wasAtEdgePosition = newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition;\n    lineNumber = newLineNumber;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      if (allowMoveOnEdgeLine) {\n        column = model.getLineMinColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else if (lineNumber > lineCount) {\n      lineNumber = lineCount;\n      if (allowMoveOnEdgeLine) {\n        column = model.getLineMaxColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else {\n      column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n    }\n    if (wasAtEdgePosition) {\n      leftoverVisibleColumns = 0;\n    } else {\n      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n    }\n    if (normalizationAffinity !== undefined) {\n      const position = new Position(lineNumber, column);\n      const newPosition = model.normalizePosition(position, normalizationAffinity);\n      leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n      lineNumber = newPosition.lineNumber;\n      column = newPosition.column;\n    }\n    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n  }\n  static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n    return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n  }\n  static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move down acts relative to the end of selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n    let i = 0;\n    let r;\n    do {\n      r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n      const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n      if (np.lineNumber > lineNumber) {\n        break;\n      }\n    } while (i++ < 10 && lineNumber + i < model.getLineCount());\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n  static translateDown(config, model, cursor) {\n    const selection = cursor.selection;\n    const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n  static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n    return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n  }\n  static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move up acts relative to the beginning of selection\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n    const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n  static translateUp(config, model, cursor) {\n    const selection = cursor.selection;\n    const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n  static _isBlankLine(model, lineNumber) {\n    if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n      // empty or contains only whitespace\n      return true;\n    }\n    return false;\n  }\n  static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n    let lineNumber = cursor.position.lineNumber;\n    // If our current line is blank, move to the previous non-blank line\n    while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n      lineNumber--;\n    }\n    // Find the previous blank line\n    while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n      lineNumber--;\n    }\n    return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n  }\n  static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n    const lineCount = model.getLineCount();\n    let lineNumber = cursor.position.lineNumber;\n    // If our current line is blank, move to the next non-blank line\n    while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n      lineNumber++;\n    }\n    // Find the next blank line\n    while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n      lineNumber++;\n    }\n    return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n  }\n  static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n    const lineNumber = cursor.position.lineNumber;\n    const minColumn = model.getLineMinColumn(lineNumber);\n    const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n    let column;\n    const relevantColumnNumber = cursor.position.column;\n    if (relevantColumnNumber === firstNonBlankColumn) {\n      column = minColumn;\n    } else {\n      column = firstNonBlankColumn;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n    const lineNumber = cursor.position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n  }\n  static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n    return cursor.move(inSelectionMode, 1, 1, 0);\n  }\n  static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n    const lastLineNumber = model.getLineCount();\n    const lastColumn = model.getLineMaxColumn(lastLineNumber);\n    return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n  }\n}","map":{"version":3,"names":["strings","CursorColumns","Position","Range","AtomicTabMoveOperations","SingleCursorState","CursorPosition","constructor","lineNumber","column","leftoverVisibleColumns","_cursorPositionBrand","undefined","MoveOperations","leftPosition","model","position","getLineMinColumn","delta","prevCharLength","getLineContent","newLineNumber","getLineMaxColumn","leftPositionAtomicSoftTabs","tabSize","getLineIndentColumn","minColumn","lineContent","newPosition","atomicPosition","left","config","pos","stickyTabStops","moveLeft","cursor","inSelectionMode","noOfColumns","hasSelection","selection","startLineNumber","startColumn","normalizedPos","normalizePosition","clipPositionColumn","p","move","clipRange","value","min","max","rightPosition","nextCharLength","getLineCount","rightPositionAtomicSoftTabs","indentSize","right","moveRight","endLineNumber","endColumn","r","vertical","allowMoveOnEdgeLine","normalizationAffinity","currentVisibleColumn","visibleColumnFromColumn","lineCount","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","Math","columnFromVisibleColumn","down","count","allowMoveOnLastLine","moveDown","linesCount","i","np","translateDown","selectionStart","selectionStartLineNumber","selectionStartColumn","selectionStartLeftoverVisibleColumns","positionLineNumber","positionColumn","up","allowMoveOnFirstLine","moveUp","translateUp","_isBlankLine","getLineFirstNonWhitespaceColumn","moveToPrevBlankLine","moveToNextBlankLine","moveToBeginningOfLine","firstNonBlankColumn","relevantColumnNumber","moveToEndOfLine","sticky","maxColumn","moveToBeginningOfBuffer","moveToEndOfBuffer","lastLineNumber","lastColumn"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,iCAAiC;AAC1D,SAASC,aAAa,QAAQ,0BAA0B;AACxD,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,uBAAuB,QAAQ,iCAAiC;AACzE,SAASC,iBAAiB,QAAQ,oBAAoB;AACtD,OAAO,MAAMC,cAAc,CAAC;EACxBC,WAAWA,CAACC,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAE;IACpD,IAAI,CAACC,oBAAoB,GAAGC,SAAS;IACrC,IAAI,CAACJ,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,sBAAsB,GAAGA,sBAAsB;EACxD;AACJ;AACA,OAAO,MAAMG,cAAc,CAAC;EACxB,OAAOC,YAAYA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IACjC,IAAIA,QAAQ,CAACP,MAAM,GAAGM,KAAK,CAACE,gBAAgB,CAACD,QAAQ,CAACR,UAAU,CAAC,EAAE;MAC/D,OAAOQ,QAAQ,CAACE,KAAK,CAACN,SAAS,EAAE,CAACZ,OAAO,CAACmB,cAAc,CAACJ,KAAK,CAACK,cAAc,CAACJ,QAAQ,CAACR,UAAU,CAAC,EAAEQ,QAAQ,CAACP,MAAM,GAAG,CAAC,CAAC,CAAC;IAC7H,CAAC,MACI,IAAIO,QAAQ,CAACR,UAAU,GAAG,CAAC,EAAE;MAC9B,MAAMa,aAAa,GAAGL,QAAQ,CAACR,UAAU,GAAG,CAAC;MAC7C,OAAO,IAAIN,QAAQ,CAACmB,aAAa,EAAEN,KAAK,CAACO,gBAAgB,CAACD,aAAa,CAAC,CAAC;IAC7E,CAAC,MACI;MACD,OAAOL,QAAQ;IACnB;EACJ;EACA,OAAOO,0BAA0BA,CAACR,KAAK,EAAEC,QAAQ,EAAEQ,OAAO,EAAE;IACxD,IAAIR,QAAQ,CAACP,MAAM,IAAIM,KAAK,CAACU,mBAAmB,CAACT,QAAQ,CAACR,UAAU,CAAC,EAAE;MACnE,MAAMkB,SAAS,GAAGX,KAAK,CAACE,gBAAgB,CAACD,QAAQ,CAACR,UAAU,CAAC;MAC7D,MAAMmB,WAAW,GAAGZ,KAAK,CAACK,cAAc,CAACJ,QAAQ,CAACR,UAAU,CAAC;MAC7D,MAAMoB,WAAW,GAAGxB,uBAAuB,CAACyB,cAAc,CAACF,WAAW,EAAEX,QAAQ,CAACP,MAAM,GAAG,CAAC,EAAEe,OAAO,EAAE,CAAC,CAAC,oBAAoB,CAAC;MAC7H,IAAII,WAAW,KAAK,CAAC,CAAC,IAAIA,WAAW,GAAG,CAAC,IAAIF,SAAS,EAAE;QACpD,OAAO,IAAIxB,QAAQ,CAACc,QAAQ,CAACR,UAAU,EAAEoB,WAAW,GAAG,CAAC,CAAC;MAC7D;IACJ;IACA,OAAO,IAAI,CAACd,YAAY,CAACC,KAAK,EAAEC,QAAQ,CAAC;EAC7C;EACA,OAAOc,IAAIA,CAACC,MAAM,EAAEhB,KAAK,EAAEC,QAAQ,EAAE;IACjC,MAAMgB,GAAG,GAAGD,MAAM,CAACE,cAAc,GAC3BpB,cAAc,CAACU,0BAA0B,CAACR,KAAK,EAAEC,QAAQ,EAAEe,MAAM,CAACP,OAAO,CAAC,GAC1EX,cAAc,CAACC,YAAY,CAACC,KAAK,EAAEC,QAAQ,CAAC;IAClD,OAAO,IAAIV,cAAc,CAAC0B,GAAG,CAACxB,UAAU,EAAEwB,GAAG,CAACvB,MAAM,EAAE,CAAC,CAAC;EAC5D;EACA;AACJ;AACA;AACA;EACI,OAAOyB,QAAQA,CAACH,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAEC,WAAW,EAAE;IACjE,IAAI7B,UAAU,EAAEC,MAAM;IACtB,IAAI0B,MAAM,CAACG,YAAY,CAAC,CAAC,IAAI,CAACF,eAAe,EAAE;MAC3C;MACA;MACA5B,UAAU,GAAG2B,MAAM,CAACI,SAAS,CAACC,eAAe;MAC7C/B,MAAM,GAAG0B,MAAM,CAACI,SAAS,CAACE,WAAW;IACzC,CAAC,MACI;MACD;MACA;MACA,MAAMT,GAAG,GAAGG,MAAM,CAACnB,QAAQ,CAACE,KAAK,CAACN,SAAS,EAAE,EAAEyB,WAAW,GAAG,CAAC,CAAC,CAAC;MAChE;MACA;MACA,MAAMK,aAAa,GAAG3B,KAAK,CAAC4B,iBAAiB,CAAC9B,cAAc,CAAC+B,kBAAkB,CAACZ,GAAG,EAAEjB,KAAK,CAAC,EAAE,CAAC,CAAC,2BAA2B,CAAC;MAC3H,MAAM8B,CAAC,GAAGhC,cAAc,CAACiB,IAAI,CAACC,MAAM,EAAEhB,KAAK,EAAE2B,aAAa,CAAC;MAC3DlC,UAAU,GAAGqC,CAAC,CAACrC,UAAU;MACzBC,MAAM,GAAGoC,CAAC,CAACpC,MAAM;IACrB;IACA,OAAO0B,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAEC,MAAM,EAAE,CAAC,CAAC;EAC9D;EACA;AACJ;AACA;EACI,OAAOmC,kBAAkBA,CAAC5B,QAAQ,EAAED,KAAK,EAAE;IACvC,OAAO,IAAIb,QAAQ,CAACc,QAAQ,CAACR,UAAU,EAAEK,cAAc,CAACkC,SAAS,CAAC/B,QAAQ,CAACP,MAAM,EAAEM,KAAK,CAACE,gBAAgB,CAACD,QAAQ,CAACR,UAAU,CAAC,EAAEO,KAAK,CAACO,gBAAgB,CAACN,QAAQ,CAACR,UAAU,CAAC,CAAC,CAAC;EACjL;EACA,OAAOuC,SAASA,CAACC,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAE;IAC9B,IAAIF,KAAK,GAAGC,GAAG,EAAE;MACb,OAAOA,GAAG;IACd;IACA,IAAID,KAAK,GAAGE,GAAG,EAAE;MACb,OAAOA,GAAG;IACd;IACA,OAAOF,KAAK;EAChB;EACA,OAAOG,aAAaA,CAACpC,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAE;IAC5C,IAAIA,MAAM,GAAGM,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAC,EAAE;MAC7CC,MAAM,GAAGA,MAAM,GAAGT,OAAO,CAACoD,cAAc,CAACrC,KAAK,CAACK,cAAc,CAACZ,UAAU,CAAC,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC1F,CAAC,MACI,IAAID,UAAU,GAAGO,KAAK,CAACsC,YAAY,CAAC,CAAC,EAAE;MACxC7C,UAAU,GAAGA,UAAU,GAAG,CAAC;MAC3BC,MAAM,GAAGM,KAAK,CAACE,gBAAgB,CAACT,UAAU,CAAC;IAC/C;IACA,OAAO,IAAIN,QAAQ,CAACM,UAAU,EAAEC,MAAM,CAAC;EAC3C;EACA,OAAO6C,2BAA2BA,CAACvC,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEe,OAAO,EAAE+B,UAAU,EAAE;IAC/E,IAAI9C,MAAM,GAAGM,KAAK,CAACU,mBAAmB,CAACjB,UAAU,CAAC,EAAE;MAChD,MAAMmB,WAAW,GAAGZ,KAAK,CAACK,cAAc,CAACZ,UAAU,CAAC;MACpD,MAAMoB,WAAW,GAAGxB,uBAAuB,CAACyB,cAAc,CAACF,WAAW,EAAElB,MAAM,GAAG,CAAC,EAAEe,OAAO,EAAE,CAAC,CAAC,qBAAqB,CAAC;MACrH,IAAII,WAAW,KAAK,CAAC,CAAC,EAAE;QACpB,OAAO,IAAI1B,QAAQ,CAACM,UAAU,EAAEoB,WAAW,GAAG,CAAC,CAAC;MACpD;IACJ;IACA,OAAO,IAAI,CAACuB,aAAa,CAACpC,KAAK,EAAEP,UAAU,EAAEC,MAAM,CAAC;EACxD;EACA,OAAO+C,KAAKA,CAACzB,MAAM,EAAEhB,KAAK,EAAEC,QAAQ,EAAE;IAClC,MAAMgB,GAAG,GAAGD,MAAM,CAACE,cAAc,GAC3BpB,cAAc,CAACyC,2BAA2B,CAACvC,KAAK,EAAEC,QAAQ,CAACR,UAAU,EAAEQ,QAAQ,CAACP,MAAM,EAAEsB,MAAM,CAACP,OAAO,EAAEO,MAAM,CAACwB,UAAU,CAAC,GAC1H1C,cAAc,CAACsC,aAAa,CAACpC,KAAK,EAAEC,QAAQ,CAACR,UAAU,EAAEQ,QAAQ,CAACP,MAAM,CAAC;IAC/E,OAAO,IAAIH,cAAc,CAAC0B,GAAG,CAACxB,UAAU,EAAEwB,GAAG,CAACvB,MAAM,EAAE,CAAC,CAAC;EAC5D;EACA,OAAOgD,SAASA,CAAC1B,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAEC,WAAW,EAAE;IAClE,IAAI7B,UAAU,EAAEC,MAAM;IACtB,IAAI0B,MAAM,CAACG,YAAY,CAAC,CAAC,IAAI,CAACF,eAAe,EAAE;MAC3C;MACA5B,UAAU,GAAG2B,MAAM,CAACI,SAAS,CAACmB,aAAa;MAC3CjD,MAAM,GAAG0B,MAAM,CAACI,SAAS,CAACoB,SAAS;IACvC,CAAC,MACI;MACD,MAAM3B,GAAG,GAAGG,MAAM,CAACnB,QAAQ,CAACE,KAAK,CAACN,SAAS,EAAEyB,WAAW,GAAG,CAAC,CAAC;MAC7D,MAAMK,aAAa,GAAG3B,KAAK,CAAC4B,iBAAiB,CAAC9B,cAAc,CAAC+B,kBAAkB,CAACZ,GAAG,EAAEjB,KAAK,CAAC,EAAE,CAAC,CAAC,4BAA4B,CAAC;MAC5H,MAAM6C,CAAC,GAAG/C,cAAc,CAAC2C,KAAK,CAACzB,MAAM,EAAEhB,KAAK,EAAE2B,aAAa,CAAC;MAC5DlC,UAAU,GAAGoD,CAAC,CAACpD,UAAU;MACzBC,MAAM,GAAGmD,CAAC,CAACnD,MAAM;IACrB;IACA,OAAO0B,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAEC,MAAM,EAAE,CAAC,CAAC;EAC9D;EACA,OAAOoD,QAAQA,CAAC9B,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAEW,aAAa,EAAEyC,mBAAmB,EAAEC,qBAAqB,EAAE;IAClI,MAAMC,oBAAoB,GAAG/D,aAAa,CAACgE,uBAAuB,CAAClD,KAAK,CAACK,cAAc,CAACZ,UAAU,CAAC,EAAEC,MAAM,EAAEsB,MAAM,CAACP,OAAO,CAAC,GAAGd,sBAAsB;IACrJ,MAAMwD,SAAS,GAAGnD,KAAK,CAACsC,YAAY,CAAC,CAAC;IACtC,MAAMc,kBAAkB,GAAI3D,UAAU,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAE;IAC7D,MAAM2D,iBAAiB,GAAI5D,UAAU,KAAK0D,SAAS,IAAIzD,MAAM,KAAKM,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAE;IACrG,MAAM6D,iBAAiB,GAAIhD,aAAa,GAAGb,UAAU,GAAG2D,kBAAkB,GAAGC,iBAAkB;IAC/F5D,UAAU,GAAGa,aAAa;IAC1B,IAAIb,UAAU,GAAG,CAAC,EAAE;MAChBA,UAAU,GAAG,CAAC;MACd,IAAIsD,mBAAmB,EAAE;QACrBrD,MAAM,GAAGM,KAAK,CAACE,gBAAgB,CAACT,UAAU,CAAC;MAC/C,CAAC,MACI;QACDC,MAAM,GAAG6D,IAAI,CAACrB,GAAG,CAAClC,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAC,EAAEC,MAAM,CAAC;MACjE;IACJ,CAAC,MACI,IAAID,UAAU,GAAG0D,SAAS,EAAE;MAC7B1D,UAAU,GAAG0D,SAAS;MACtB,IAAIJ,mBAAmB,EAAE;QACrBrD,MAAM,GAAGM,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAC;MAC/C,CAAC,MACI;QACDC,MAAM,GAAG6D,IAAI,CAACrB,GAAG,CAAClC,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAC,EAAEC,MAAM,CAAC;MACjE;IACJ,CAAC,MACI;MACDA,MAAM,GAAGsB,MAAM,CAACwC,uBAAuB,CAACxD,KAAK,EAAEP,UAAU,EAAEwD,oBAAoB,CAAC;IACpF;IACA,IAAIK,iBAAiB,EAAE;MACnB3D,sBAAsB,GAAG,CAAC;IAC9B,CAAC,MACI;MACDA,sBAAsB,GAAGsD,oBAAoB,GAAG/D,aAAa,CAACgE,uBAAuB,CAAClD,KAAK,CAACK,cAAc,CAACZ,UAAU,CAAC,EAAEC,MAAM,EAAEsB,MAAM,CAACP,OAAO,CAAC;IACnJ;IACA,IAAIuC,qBAAqB,KAAKnD,SAAS,EAAE;MACrC,MAAMI,QAAQ,GAAG,IAAId,QAAQ,CAACM,UAAU,EAAEC,MAAM,CAAC;MACjD,MAAMmB,WAAW,GAAGb,KAAK,CAAC4B,iBAAiB,CAAC3B,QAAQ,EAAE+C,qBAAqB,CAAC;MAC5ErD,sBAAsB,GAAGA,sBAAsB,IAAID,MAAM,GAAGmB,WAAW,CAACnB,MAAM,CAAC;MAC/ED,UAAU,GAAGoB,WAAW,CAACpB,UAAU;MACnCC,MAAM,GAAGmB,WAAW,CAACnB,MAAM;IAC/B;IACA,OAAO,IAAIH,cAAc,CAACE,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,CAAC;EACzE;EACA,OAAO8D,IAAIA,CAACzC,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAE+D,KAAK,EAAEC,mBAAmB,EAAE;IAC/F,OAAO,IAAI,CAACb,QAAQ,CAAC9B,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAEF,UAAU,GAAGiE,KAAK,EAAEC,mBAAmB,EAAE,CAAC,CAAC,0CAA0C,CAAC;EAC1K;EACA,OAAOC,QAAQA,CAAC5C,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAEwC,UAAU,EAAE;IAChE,IAAIpE,UAAU,EAAEC,MAAM;IACtB,IAAI0B,MAAM,CAACG,YAAY,CAAC,CAAC,IAAI,CAACF,eAAe,EAAE;MAC3C;MACA5B,UAAU,GAAG2B,MAAM,CAACI,SAAS,CAACmB,aAAa;MAC3CjD,MAAM,GAAG0B,MAAM,CAACI,SAAS,CAACoB,SAAS;IACvC,CAAC,MACI;MACDnD,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;MACvCC,MAAM,GAAG0B,MAAM,CAACnB,QAAQ,CAACP,MAAM;IACnC;IACA,IAAIoE,CAAC,GAAG,CAAC;IACT,IAAIjB,CAAC;IACL,GAAG;MACCA,CAAC,GAAG/C,cAAc,CAAC2D,IAAI,CAACzC,MAAM,EAAEhB,KAAK,EAAEP,UAAU,GAAGqE,CAAC,EAAEpE,MAAM,EAAE0B,MAAM,CAACzB,sBAAsB,EAAEkE,UAAU,EAAE,IAAI,CAAC;MAC/G,MAAME,EAAE,GAAG/D,KAAK,CAAC4B,iBAAiB,CAAC,IAAIzC,QAAQ,CAAC0D,CAAC,CAACpD,UAAU,EAAEoD,CAAC,CAACnD,MAAM,CAAC,EAAE,CAAC,CAAC,2BAA2B,CAAC;MACvG,IAAIqE,EAAE,CAACtE,UAAU,GAAGA,UAAU,EAAE;QAC5B;MACJ;IACJ,CAAC,QAAQqE,CAAC,EAAE,GAAG,EAAE,IAAIrE,UAAU,GAAGqE,CAAC,GAAG9D,KAAK,CAACsC,YAAY,CAAC,CAAC;IAC1D,OAAOlB,MAAM,CAACW,IAAI,CAACV,eAAe,EAAEwB,CAAC,CAACpD,UAAU,EAAEoD,CAAC,CAACnD,MAAM,EAAEmD,CAAC,CAAClD,sBAAsB,CAAC;EACzF;EACA,OAAOqE,aAAaA,CAAChD,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAE;IACxC,MAAMI,SAAS,GAAGJ,MAAM,CAACI,SAAS;IAClC,MAAMyC,cAAc,GAAGnE,cAAc,CAAC2D,IAAI,CAACzC,MAAM,EAAEhB,KAAK,EAAEwB,SAAS,CAAC0C,wBAAwB,EAAE1C,SAAS,CAAC2C,oBAAoB,EAAE/C,MAAM,CAACgD,oCAAoC,EAAE,CAAC,EAAE,KAAK,CAAC;IACpL,MAAMnE,QAAQ,GAAGH,cAAc,CAAC2D,IAAI,CAACzC,MAAM,EAAEhB,KAAK,EAAEwB,SAAS,CAAC6C,kBAAkB,EAAE7C,SAAS,CAAC8C,cAAc,EAAElD,MAAM,CAACzB,sBAAsB,EAAE,CAAC,EAAE,KAAK,CAAC;IACpJ,OAAO,IAAIL,iBAAiB,CAAC,IAAIF,KAAK,CAAC6E,cAAc,CAACxE,UAAU,EAAEwE,cAAc,CAACvE,MAAM,EAAEuE,cAAc,CAACxE,UAAU,EAAEwE,cAAc,CAACvE,MAAM,CAAC,EAAE,CAAC,CAAC,iCAAiCuE,cAAc,CAACtE,sBAAsB,EAAE,IAAIR,QAAQ,CAACc,QAAQ,CAACR,UAAU,EAAEQ,QAAQ,CAACP,MAAM,CAAC,EAAEO,QAAQ,CAACN,sBAAsB,CAAC;EAC9S;EACA,OAAO4E,EAAEA,CAACvD,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAE+D,KAAK,EAAEc,oBAAoB,EAAE;IAC9F,OAAO,IAAI,CAAC1B,QAAQ,CAAC9B,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAEC,sBAAsB,EAAEF,UAAU,GAAGiE,KAAK,EAAEc,oBAAoB,EAAE,CAAC,CAAC,yCAAyC,CAAC;EAC1K;EACA,OAAOC,MAAMA,CAACzD,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAEwC,UAAU,EAAE;IAC9D,IAAIpE,UAAU,EAAEC,MAAM;IACtB,IAAI0B,MAAM,CAACG,YAAY,CAAC,CAAC,IAAI,CAACF,eAAe,EAAE;MAC3C;MACA5B,UAAU,GAAG2B,MAAM,CAACI,SAAS,CAACC,eAAe;MAC7C/B,MAAM,GAAG0B,MAAM,CAACI,SAAS,CAACE,WAAW;IACzC,CAAC,MACI;MACDjC,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;MACvCC,MAAM,GAAG0B,MAAM,CAACnB,QAAQ,CAACP,MAAM;IACnC;IACA,MAAMmD,CAAC,GAAG/C,cAAc,CAACyE,EAAE,CAACvD,MAAM,EAAEhB,KAAK,EAAEP,UAAU,EAAEC,MAAM,EAAE0B,MAAM,CAACzB,sBAAsB,EAAEkE,UAAU,EAAE,IAAI,CAAC;IAC/G,OAAOzC,MAAM,CAACW,IAAI,CAACV,eAAe,EAAEwB,CAAC,CAACpD,UAAU,EAAEoD,CAAC,CAACnD,MAAM,EAAEmD,CAAC,CAAClD,sBAAsB,CAAC;EACzF;EACA,OAAO+E,WAAWA,CAAC1D,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAE;IACtC,MAAMI,SAAS,GAAGJ,MAAM,CAACI,SAAS;IAClC,MAAMyC,cAAc,GAAGnE,cAAc,CAACyE,EAAE,CAACvD,MAAM,EAAEhB,KAAK,EAAEwB,SAAS,CAAC0C,wBAAwB,EAAE1C,SAAS,CAAC2C,oBAAoB,EAAE/C,MAAM,CAACgD,oCAAoC,EAAE,CAAC,EAAE,KAAK,CAAC;IAClL,MAAMnE,QAAQ,GAAGH,cAAc,CAACyE,EAAE,CAACvD,MAAM,EAAEhB,KAAK,EAAEwB,SAAS,CAAC6C,kBAAkB,EAAE7C,SAAS,CAAC8C,cAAc,EAAElD,MAAM,CAACzB,sBAAsB,EAAE,CAAC,EAAE,KAAK,CAAC;IAClJ,OAAO,IAAIL,iBAAiB,CAAC,IAAIF,KAAK,CAAC6E,cAAc,CAACxE,UAAU,EAAEwE,cAAc,CAACvE,MAAM,EAAEuE,cAAc,CAACxE,UAAU,EAAEwE,cAAc,CAACvE,MAAM,CAAC,EAAE,CAAC,CAAC,iCAAiCuE,cAAc,CAACtE,sBAAsB,EAAE,IAAIR,QAAQ,CAACc,QAAQ,CAACR,UAAU,EAAEQ,QAAQ,CAACP,MAAM,CAAC,EAAEO,QAAQ,CAACN,sBAAsB,CAAC;EAC9S;EACA,OAAOgF,YAAYA,CAAC3E,KAAK,EAAEP,UAAU,EAAE;IACnC,IAAIO,KAAK,CAAC4E,+BAA+B,CAACnF,UAAU,CAAC,KAAK,CAAC,EAAE;MACzD;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA,OAAOoF,mBAAmBA,CAAC7D,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE;IAC/D,IAAI5B,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;IAC3C;IACA,OAAOA,UAAU,GAAG,CAAC,IAAI,IAAI,CAACkF,YAAY,CAAC3E,KAAK,EAAEP,UAAU,CAAC,EAAE;MAC3DA,UAAU,EAAE;IAChB;IACA;IACA,OAAOA,UAAU,GAAG,CAAC,IAAI,CAAC,IAAI,CAACkF,YAAY,CAAC3E,KAAK,EAAEP,UAAU,CAAC,EAAE;MAC5DA,UAAU,EAAE;IAChB;IACA,OAAO2B,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAEO,KAAK,CAACE,gBAAgB,CAACT,UAAU,CAAC,EAAE,CAAC,CAAC;EAC1F;EACA,OAAOqF,mBAAmBA,CAAC9D,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE;IAC/D,MAAM8B,SAAS,GAAGnD,KAAK,CAACsC,YAAY,CAAC,CAAC;IACtC,IAAI7C,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;IAC3C;IACA,OAAOA,UAAU,GAAG0D,SAAS,IAAI,IAAI,CAACwB,YAAY,CAAC3E,KAAK,EAAEP,UAAU,CAAC,EAAE;MACnEA,UAAU,EAAE;IAChB;IACA;IACA,OAAOA,UAAU,GAAG0D,SAAS,IAAI,CAAC,IAAI,CAACwB,YAAY,CAAC3E,KAAK,EAAEP,UAAU,CAAC,EAAE;MACpEA,UAAU,EAAE;IAChB;IACA,OAAO2B,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAEO,KAAK,CAACE,gBAAgB,CAACT,UAAU,CAAC,EAAE,CAAC,CAAC;EAC1F;EACA,OAAOsF,qBAAqBA,CAAC/D,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE;IACjE,MAAM5B,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;IAC7C,MAAMkB,SAAS,GAAGX,KAAK,CAACE,gBAAgB,CAACT,UAAU,CAAC;IACpD,MAAMuF,mBAAmB,GAAGhF,KAAK,CAAC4E,+BAA+B,CAACnF,UAAU,CAAC,IAAIkB,SAAS;IAC1F,IAAIjB,MAAM;IACV,MAAMuF,oBAAoB,GAAG7D,MAAM,CAACnB,QAAQ,CAACP,MAAM;IACnD,IAAIuF,oBAAoB,KAAKD,mBAAmB,EAAE;MAC9CtF,MAAM,GAAGiB,SAAS;IACtB,CAAC,MACI;MACDjB,MAAM,GAAGsF,mBAAmB;IAChC;IACA,OAAO5D,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAEC,MAAM,EAAE,CAAC,CAAC;EAC9D;EACA,OAAOwF,eAAeA,CAAClE,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE8D,MAAM,EAAE;IACnE,MAAM1F,UAAU,GAAG2B,MAAM,CAACnB,QAAQ,CAACR,UAAU;IAC7C,MAAM2F,SAAS,GAAGpF,KAAK,CAACO,gBAAgB,CAACd,UAAU,CAAC;IACpD,OAAO2B,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE5B,UAAU,EAAE2F,SAAS,EAAED,MAAM,GAAG,UAAU,CAAC,yCAAyCC,SAAS,GAAG,CAAC,CAAC;EAC1I;EACA,OAAOC,uBAAuBA,CAACrE,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE;IACnE,OAAOD,MAAM,CAACW,IAAI,CAACV,eAAe,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChD;EACA,OAAOiE,iBAAiBA,CAACtE,MAAM,EAAEhB,KAAK,EAAEoB,MAAM,EAAEC,eAAe,EAAE;IAC7D,MAAMkE,cAAc,GAAGvF,KAAK,CAACsC,YAAY,CAAC,CAAC;IAC3C,MAAMkD,UAAU,GAAGxF,KAAK,CAACO,gBAAgB,CAACgF,cAAc,CAAC;IACzD,OAAOnE,MAAM,CAACW,IAAI,CAACV,eAAe,EAAEkE,cAAc,EAAEC,UAAU,EAAE,CAAC,CAAC;EACtE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}