{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n  let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n  for (const sep of USUAL_WORD_SEPARATORS) {\n    if (allowInWords.indexOf(sep) >= 0) {\n      continue;\n    }\n    source += '\\\\' + sep;\n  }\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  let result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      let flags = 'g';\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n  maxLen: 1000,\n  windowSize: 15,\n  timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n  // Ensure the regex has the 'g' flag, otherwise this will loop forever\n  wordDefinition = ensureValidWordDefinition(wordDefinition);\n  if (!config) {\n    config = Iterable.first(_defaultConfig);\n  }\n  if (text.length > config.maxLen) {\n    // don't throw strings that long at the regexp\n    // but use a sub-string in which a word must occur\n    let start = column - config.maxLen / 2;\n    if (start < 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n  const t1 = Date.now();\n  const pos = column - 1 - textOffset;\n  let prevRegexIndex = -1;\n  let match = null;\n  for (let i = 1;; i++) {\n    // check time budget\n    if (Date.now() - t1 >= config.timeBudget) {\n      break;\n    }\n    // reset the index at which the regexp should start matching, also know where it\n    // should stop so that subsequent search don't repeat previous searches\n    const regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n    if (!thisMatch && match) {\n      // stop: we have something\n      break;\n    }\n    match = thisMatch;\n    // stop: searched at start\n    if (regexIndex <= 0) {\n      break;\n    }\n    prevRegexIndex = regexIndex;\n  }\n  if (match) {\n    const result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n  return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  let match;\n  while (match = wordDefinition.exec(text)) {\n    const matchIndex = match.index || 0;\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return match;\n    } else if (stopPos > 0 && matchIndex > stopPos) {\n      return null;\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["Iterable","LinkedList","USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","unshift","maxLen","windowSize","timeBudget","getWordAtText","column","text","textOffset","config","first","length","start","substring","t1","Date","now","pos","prevRegexIndex","match","i","regexIndex","Math","max","thisMatch","_findRegexMatchEnclosingPosition","word","startColumn","index","endColumn","stopPos","exec","matchIndex"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}