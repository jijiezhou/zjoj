{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLowerAsciiLetter, isUpperAsciiLetter } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nexport class WordSelectionRangeProvider {\n  constructor(selectSubwords = true) {\n    this.selectSubwords = selectSubwords;\n  }\n  provideSelectionRanges(model, positions) {\n    const result = [];\n    for (const position of positions) {\n      const bucket = [];\n      result.push(bucket);\n      if (this.selectSubwords) {\n        this._addInWordRanges(bucket, model, position);\n      }\n      this._addWordRanges(bucket, model, position);\n      this._addWhitespaceLine(bucket, model, position);\n      bucket.push({\n        range: model.getFullModelRange()\n      });\n    }\n    return result;\n  }\n  _addInWordRanges(bucket, model, pos) {\n    const obj = model.getWordAtPosition(pos);\n    if (!obj) {\n      return;\n    }\n    const {\n      word,\n      startColumn\n    } = obj;\n    const offset = pos.column - startColumn;\n    let start = offset;\n    let end = offset;\n    let lastCh = 0;\n    // LEFT anchor (start)\n    for (; start >= 0; start--) {\n      const ch = word.charCodeAt(start);\n      if (start !== offset && (ch === 95 /* CharCode.Underline */ || ch === 45 /* CharCode.Dash */)) {\n        // foo-bar OR foo_bar\n        break;\n      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      }\n      lastCh = ch;\n    }\n    start += 1;\n    // RIGHT anchor (end)\n    for (; end < word.length; end++) {\n      const ch = word.charCodeAt(end);\n      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      } else if (ch === 95 /* CharCode.Underline */ || ch === 45 /* CharCode.Dash */) {\n        // foo-bar OR foo_bar\n        break;\n      }\n      lastCh = ch;\n    }\n    if (start < end) {\n      bucket.push({\n        range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end)\n      });\n    }\n  }\n  _addWordRanges(bucket, model, pos) {\n    const word = model.getWordAtPosition(pos);\n    if (word) {\n      bucket.push({\n        range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn)\n      });\n    }\n  }\n  _addWhitespaceLine(bucket, model, pos) {\n    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\n      bucket.push({\n        range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber))\n      });\n    }\n  }\n}","map":{"version":3,"names":["isLowerAsciiLetter","isUpperAsciiLetter","Range","WordSelectionRangeProvider","constructor","selectSubwords","provideSelectionRanges","model","positions","result","position","bucket","push","_addInWordRanges","_addWordRanges","_addWhitespaceLine","range","getFullModelRange","pos","obj","getWordAtPosition","word","startColumn","offset","column","start","end","lastCh","ch","charCodeAt","length","lineNumber","endColumn","getLineLength","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","getLineMaxColumn"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLowerAsciiLetter, isUpperAsciiLetter } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nexport class WordSelectionRangeProvider {\n    constructor(selectSubwords = true) {\n        this.selectSubwords = selectSubwords;\n    }\n    provideSelectionRanges(model, positions) {\n        const result = [];\n        for (const position of positions) {\n            const bucket = [];\n            result.push(bucket);\n            if (this.selectSubwords) {\n                this._addInWordRanges(bucket, model, position);\n            }\n            this._addWordRanges(bucket, model, position);\n            this._addWhitespaceLine(bucket, model, position);\n            bucket.push({ range: model.getFullModelRange() });\n        }\n        return result;\n    }\n    _addInWordRanges(bucket, model, pos) {\n        const obj = model.getWordAtPosition(pos);\n        if (!obj) {\n            return;\n        }\n        const { word, startColumn } = obj;\n        const offset = pos.column - startColumn;\n        let start = offset;\n        let end = offset;\n        let lastCh = 0;\n        // LEFT anchor (start)\n        for (; start >= 0; start--) {\n            const ch = word.charCodeAt(start);\n            if ((start !== offset) && (ch === 95 /* CharCode.Underline */ || ch === 45 /* CharCode.Dash */)) {\n                // foo-bar OR foo_bar\n                break;\n            }\n            else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\n                // fooBar\n                break;\n            }\n            lastCh = ch;\n        }\n        start += 1;\n        // RIGHT anchor (end)\n        for (; end < word.length; end++) {\n            const ch = word.charCodeAt(end);\n            if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\n                // fooBar\n                break;\n            }\n            else if (ch === 95 /* CharCode.Underline */ || ch === 45 /* CharCode.Dash */) {\n                // foo-bar OR foo_bar\n                break;\n            }\n            lastCh = ch;\n        }\n        if (start < end) {\n            bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });\n        }\n    }\n    _addWordRanges(bucket, model, pos) {\n        const word = model.getWordAtPosition(pos);\n        if (word) {\n            bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });\n        }\n    }\n    _addWhitespaceLine(bucket, model, pos) {\n        if (model.getLineLength(pos.lineNumber) > 0\n            && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0\n            && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\n            bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}