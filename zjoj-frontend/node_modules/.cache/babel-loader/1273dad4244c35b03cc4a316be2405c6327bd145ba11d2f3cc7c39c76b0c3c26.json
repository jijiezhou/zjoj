{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n  }\n  getLanguageConfiguration(languageId) {\n    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n  }\n  _computeIndentLevel(lineIndex) {\n    return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n  }\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    this.assertNotDisposed();\n    const lineCount = this.textModel.getLineCount();\n    if (lineNumber < 1 || lineNumber > lineCount) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let up_aboveContentLineIndent = -1;\n    let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let up_belowContentLineIndent = -1;\n    const up_resolveIndents = lineNumber => {\n      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n        up_aboveContentLineIndex = -1;\n        up_aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            up_aboveContentLineIndex = lineIndex;\n            up_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (up_belowContentLineIndex === -2) {\n        up_belowContentLineIndex = -1;\n        up_belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            up_belowContentLineIndex = lineIndex;\n            up_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n    let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let down_aboveContentLineIndent = -1;\n    let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let down_belowContentLineIndent = -1;\n    const down_resolveIndents = lineNumber => {\n      if (down_aboveContentLineIndex === -2) {\n        down_aboveContentLineIndex = -1;\n        down_aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            down_aboveContentLineIndex = lineIndex;\n            down_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n        down_belowContentLineIndex = -1;\n        down_belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            down_belowContentLineIndex = lineIndex;\n            down_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n    let startLineNumber = 0;\n    let goUp = true;\n    let endLineNumber = 0;\n    let goDown = true;\n    let indent = 0;\n    let initialIndent = 0;\n    for (let distance = 0; goUp || goDown; distance++) {\n      const upLineNumber = lineNumber - distance;\n      const downLineNumber = lineNumber + distance;\n      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n        goUp = false;\n      }\n      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n        goDown = false;\n      }\n      if (distance > 50000) {\n        // stop processing\n        goUp = false;\n        goDown = false;\n      }\n      let upLineIndentLevel = -1;\n      if (goUp && upLineNumber >= 1) {\n        // compute indent level going up\n        const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          up_belowContentLineIndex = upLineNumber - 1;\n          up_belowContentLineIndent = currentIndent;\n          upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n        } else {\n          up_resolveIndents(upLineNumber);\n          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n        }\n      }\n      let downLineIndentLevel = -1;\n      if (goDown && downLineNumber <= lineCount) {\n        // compute indent level going down\n        const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          down_aboveContentLineIndex = downLineNumber - 1;\n          down_aboveContentLineIndent = currentIndent;\n          downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n        } else {\n          down_resolveIndents(downLineNumber);\n          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n        }\n      }\n      if (distance === 0) {\n        initialIndent = upLineIndentLevel;\n        continue;\n      }\n      if (distance === 1) {\n        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n          // This is the beginning of a scope, we have special handling here, since we want the\n          // child scope indent to be active, not the parent scope\n          goUp = false;\n          startLineNumber = downLineNumber;\n          endLineNumber = downLineNumber;\n          indent = downLineIndentLevel;\n          continue;\n        }\n        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n          // This is the end of a scope, just like above\n          goDown = false;\n          startLineNumber = upLineNumber;\n          endLineNumber = upLineNumber;\n          indent = upLineIndentLevel;\n          continue;\n        }\n        startLineNumber = lineNumber;\n        endLineNumber = lineNumber;\n        indent = initialIndent;\n        if (indent === 0) {\n          // No need to continue\n          return {\n            startLineNumber,\n            endLineNumber,\n            indent\n          };\n        }\n      }\n      if (goUp) {\n        if (upLineIndentLevel >= indent) {\n          startLineNumber = upLineNumber;\n        } else {\n          goUp = false;\n        }\n      }\n      if (goDown) {\n        if (downLineIndentLevel >= indent) {\n          endLineNumber = downLineNumber;\n        } else {\n          goDown = false;\n        }\n      }\n    }\n    return {\n      startLineNumber,\n      endLineNumber,\n      indent\n    };\n  }\n  getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n    var _a;\n    const result = [];\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      result.push([]);\n    }\n    // If requested, this could be made configurable.\n    const includeSingleLinePairs = true;\n    const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n    let activeBracketPairRange = undefined;\n    if (activePosition && bracketPairs.length > 0) {\n      const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber\n      // We don't need to query the brackets again if the cursor is in the viewport\n      ? bracketPairs : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter(bp => Range.strictContainsPosition(bp.range, activePosition));\n      activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, i => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n    }\n    const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n    const colorProvider = new BracketPairGuidesClassNames();\n    for (const pair of bracketPairs) {\n      /*\n                {\n              |\n              }\n               {\n              |\n              ----}\n           ____{\n          |test\n          ----}\n           renderHorizontalEndLineAtTheBottom:\n              {\n              |\n              |x}\n              --\n          renderHorizontalEndLineAtTheBottom:\n          ____{\n          |test\n          | x }\n          ----\n      */\n      if (!pair.closingBracketRange) {\n        continue;\n      }\n      const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n      if (!isActive && !options.includeInactive) {\n        continue;\n      }\n      const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) + (options.highlightActive && isActive ? ' ' + colorProvider.activeClassName : '');\n      const start = pair.openingBracketRange.getStartPosition();\n      const end = pair.closingBracketRange.getStartPosition();\n      const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive;\n      if (pair.range.startLineNumber === pair.range.endLineNumber) {\n        if (includeSingleLinePairs && horizontalGuides) {\n          result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n        }\n        continue;\n      }\n      const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n      const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n      const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n      let renderHorizontalEndLineAtTheBottom = false;\n      const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n      const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n      if (hasTextBeforeClosingBracket) {\n        renderHorizontalEndLineAtTheBottom = true;\n      }\n      const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n      const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n      const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n      for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n        result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n      }\n      if (horizontalGuides) {\n        if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n          result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n        }\n        if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n          result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n        }\n      }\n    }\n    for (const guides of result) {\n      guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n    }\n    return result;\n  }\n  getVisibleColumnFromPosition(position) {\n    return CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;\n  }\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    this.assertNotDisposed();\n    const lineCount = this.textModel.getLineCount();\n    if (startLineNumber < 1 || startLineNumber > lineCount) {\n      throw new Error('Illegal value for startLineNumber');\n    }\n    if (endLineNumber < 1 || endLineNumber > lineCount) {\n      throw new Error('Illegal value for endLineNumber');\n    }\n    const options = this.textModel.getOptions();\n    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    const result = new Array(endLineNumber - startLineNumber + 1);\n    let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let aboveContentLineIndent = -1;\n    let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let belowContentLineIndent = -1;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const resultIndex = lineNumber - startLineNumber;\n      const currentIndent = this._computeIndentLevel(lineNumber - 1);\n      if (currentIndent >= 0) {\n        // This line has content (besides whitespace)\n        // Use the line's indent\n        aboveContentLineIndex = lineNumber - 1;\n        aboveContentLineIndent = currentIndent;\n        result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n        continue;\n      }\n      if (aboveContentLineIndex === -2) {\n        aboveContentLineIndex = -1;\n        aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            aboveContentLineIndex = lineIndex;\n            aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n        belowContentLineIndex = -1;\n        belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            belowContentLineIndex = lineIndex;\n            belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n    }\n    return result;\n  }\n  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n    const options = this.textModel.getOptions();\n    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n      // At the top or bottom of the file\n      return 0;\n    } else if (aboveContentLineIndent < belowContentLineIndent) {\n      // we are inside the region above\n      return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n    } else if (aboveContentLineIndent === belowContentLineIndent) {\n      // we are in between two regions\n      return Math.ceil(belowContentLineIndent / options.indentSize);\n    } else {\n      if (offSide) {\n        // same level as region below\n        return Math.ceil(belowContentLineIndent / options.indentSize);\n      } else {\n        // we are inside the region that ends below\n        return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n      }\n    }\n  }\n}\nexport class BracketPairGuidesClassNames {\n  constructor() {\n    this.activeClassName = 'indent-active';\n  }\n  getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n    return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n  }\n  getInlineClassNameOfLevel(level) {\n    // To support a dynamic amount of colors up to 6 colors,\n    // we use a number that is a lcm of all numbers from 1 to 6.\n    return `bracket-indent-guide lvl-${level % 30}`;\n  }\n}","map":{"version":3,"names":["findLast","strings","CursorColumns","Range","TextModelPart","computeIndentLevel","HorizontalGuidesState","IndentGuide","IndentGuideHorizontalLine","BugIndicatingError","GuidesTextModelPart","constructor","textModel","languageConfigurationService","getLanguageConfiguration","languageId","_computeIndentLevel","lineIndex","getLineContent","getOptions","tabSize","getActiveIndentGuide","lineNumber","minLineNumber","maxLineNumber","assertNotDisposed","lineCount","getLineCount","foldingRules","getLanguageId","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","startLineNumber","goUp","endLineNumber","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","Math","ceil","indentSize","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","options","_a","result","push","includeSingleLinePairs","bracketPairs","getBracketPairsInRangeWithMinIndentation","getLineMaxColumn","toArray","activeBracketPairRange","undefined","length","bracketsContainingActivePosition","getBracketPairsInRange","fromPositions","filter","bp","strictContainsPosition","range","i","independentColorPoolPerBracketType","bracketPairColorizationOptions","colorProvider","BracketPairGuidesClassNames","pair","closingBracketRange","isActive","equalsRange","includeInactive","className","getInlineClassName","nestingLevel","nestingLevelOfEqualBracketType","highlightActive","activeClassName","start","openingBracketRange","getStartPosition","end","horizontalGuides","Enabled","EnabledForActive","getEndPosition","column","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","min","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","firstNonWsIndex","firstNonWhitespaceIndex","hasTextBeforeClosingBracket","startColumn","visibleGuideStartLineNumber","max","visibleGuideEndLineNumber","offset","l","guides","sort","a","b","visibleColumn","position","visibleColumnFromColumn","getLinesIndentGuides","Error","Array","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","floor","getInlineClassNameOfLevel","level"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,oCAAoC;AAC7D,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,aAAa,QAAQ,0BAA0B;AACxD,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,kBAAkB,QAAQ,YAAY;AAC/C,SAASC,qBAAqB,EAAEC,WAAW,EAAEC,yBAAyB,QAAQ,uBAAuB;AACrG,SAASC,kBAAkB,QAAQ,gCAAgC;AACnE,OAAO,MAAMC,mBAAmB,SAASN,aAAa,CAAC;EACnDO,WAAWA,CAACC,SAAS,EAAEC,4BAA4B,EAAE;IACjD,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,4BAA4B,GAAGA,4BAA4B;EACpE;EACAC,wBAAwBA,CAACC,UAAU,EAAE;IACjC,OAAO,IAAI,CAACF,4BAA4B,CAACC,wBAAwB,CAACC,UAAU,CAAC;EACjF;EACAC,mBAAmBA,CAACC,SAAS,EAAE;IAC3B,OAAOZ,kBAAkB,CAAC,IAAI,CAACO,SAAS,CAACM,cAAc,CAACD,SAAS,GAAG,CAAC,CAAC,EAAE,IAAI,CAACL,SAAS,CAACO,UAAU,CAAC,CAAC,CAACC,OAAO,CAAC;EAChH;EACAC,oBAAoBA,CAACC,UAAU,EAAEC,aAAa,EAAEC,aAAa,EAAE;IAC3D,IAAI,CAACC,iBAAiB,CAAC,CAAC;IACxB,MAAMC,SAAS,GAAG,IAAI,CAACd,SAAS,CAACe,YAAY,CAAC,CAAC;IAC/C,IAAIL,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAGI,SAAS,EAAE;MAC1C,MAAM,IAAIjB,kBAAkB,CAAC,8BAA8B,CAAC;IAChE;IACA,MAAMmB,YAAY,GAAG,IAAI,CAACd,wBAAwB,CAAC,IAAI,CAACF,SAAS,CAACiB,aAAa,CAAC,CAAC,CAAC,CAACD,YAAY;IAC/F,MAAME,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAAO,CAAC;IAC7D,IAAIE,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAIC,yBAAyB,GAAG,CAAC,CAAC;IAClC,IAAIC,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAIC,yBAAyB,GAAG,CAAC,CAAC;IAClC,MAAMC,iBAAiB,GAAId,UAAU,IAAK;MACtC,IAAIU,wBAAwB,KAAK,CAAC,CAAC,KAC9BA,wBAAwB,KAAK,CAAC,CAAC,IAC5BA,wBAAwB,GAAGV,UAAU,GAAG,CAAC,CAAC,EAAE;QAChDU,wBAAwB,GAAG,CAAC,CAAC;QAC7BC,yBAAyB,GAAG,CAAC,CAAC;QAC9B;QACA,KAAK,IAAIhB,SAAS,GAAGK,UAAU,GAAG,CAAC,EAAEL,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACbL,wBAAwB,GAAGf,SAAS;YACpCgB,yBAAyB,GAAGI,MAAM;YAClC;UACJ;QACJ;MACJ;MACA,IAAIH,wBAAwB,KAAK,CAAC,CAAC,EAAE;QACjCA,wBAAwB,GAAG,CAAC,CAAC;QAC7BC,yBAAyB,GAAG,CAAC,CAAC;QAC9B;QACA,KAAK,IAAIlB,SAAS,GAAGK,UAAU,EAAEL,SAAS,GAAGS,SAAS,EAAET,SAAS,EAAE,EAAE;UACjE,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACbH,wBAAwB,GAAGjB,SAAS;YACpCkB,yBAAyB,GAAGE,MAAM;YAClC;UACJ;QACJ;MACJ;IACJ,CAAC;IACD,IAAIC,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;IACrC,IAAIC,2BAA2B,GAAG,CAAC,CAAC;IACpC,IAAIC,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;IACrC,IAAIC,2BAA2B,GAAG,CAAC,CAAC;IACpC,MAAMC,mBAAmB,GAAIpB,UAAU,IAAK;MACxC,IAAIgB,0BAA0B,KAAK,CAAC,CAAC,EAAE;QACnCA,0BAA0B,GAAG,CAAC,CAAC;QAC/BC,2BAA2B,GAAG,CAAC,CAAC;QAChC;QACA,KAAK,IAAItB,SAAS,GAAGK,UAAU,GAAG,CAAC,EAAEL,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACbC,0BAA0B,GAAGrB,SAAS;YACtCsB,2BAA2B,GAAGF,MAAM;YACpC;UACJ;QACJ;MACJ;MACA,IAAIG,0BAA0B,KAAK,CAAC,CAAC,KAChCA,0BAA0B,KAAK,CAAC,CAAC,IAC9BA,0BAA0B,GAAGlB,UAAU,GAAG,CAAC,CAAC,EAAE;QAClDkB,0BAA0B,GAAG,CAAC,CAAC;QAC/BC,2BAA2B,GAAG,CAAC,CAAC;QAChC;QACA,KAAK,IAAIxB,SAAS,GAAGK,UAAU,EAAEL,SAAS,GAAGS,SAAS,EAAET,SAAS,EAAE,EAAE;UACjE,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACbG,0BAA0B,GAAGvB,SAAS;YACtCwB,2BAA2B,GAAGJ,MAAM;YACpC;UACJ;QACJ;MACJ;IACJ,CAAC;IACD,IAAIM,eAAe,GAAG,CAAC;IACvB,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,aAAa,GAAG,CAAC;IACrB,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAIT,MAAM,GAAG,CAAC;IACd,IAAIU,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEJ,IAAI,IAAIE,MAAM,EAAEE,QAAQ,EAAE,EAAE;MAC/C,MAAMC,YAAY,GAAG3B,UAAU,GAAG0B,QAAQ;MAC1C,MAAME,cAAc,GAAG5B,UAAU,GAAG0B,QAAQ;MAC5C,IAAIA,QAAQ,GAAG,CAAC,KAAKC,YAAY,GAAG,CAAC,IAAIA,YAAY,GAAG1B,aAAa,CAAC,EAAE;QACpEqB,IAAI,GAAG,KAAK;MAChB;MACA,IAAII,QAAQ,GAAG,CAAC,KACXE,cAAc,GAAGxB,SAAS,IAAIwB,cAAc,GAAG1B,aAAa,CAAC,EAAE;QAChEsB,MAAM,GAAG,KAAK;MAClB;MACA,IAAIE,QAAQ,GAAG,KAAK,EAAE;QAClB;QACAJ,IAAI,GAAG,KAAK;QACZE,MAAM,GAAG,KAAK;MAClB;MACA,IAAIK,iBAAiB,GAAG,CAAC,CAAC;MAC1B,IAAIP,IAAI,IAAIK,YAAY,IAAI,CAAC,EAAE;QAC3B;QACA,MAAMG,aAAa,GAAG,IAAI,CAACpC,mBAAmB,CAACiC,YAAY,GAAG,CAAC,CAAC;QAChE,IAAIG,aAAa,IAAI,CAAC,EAAE;UACpB;UACA;UACAlB,wBAAwB,GAAGe,YAAY,GAAG,CAAC;UAC3Cd,yBAAyB,GAAGiB,aAAa;UACzCD,iBAAiB,GAAGE,IAAI,CAACC,IAAI,CAACF,aAAa,GAAG,IAAI,CAACxC,SAAS,CAACO,UAAU,CAAC,CAAC,CAACoC,UAAU,CAAC;QACzF,CAAC,MACI;UACDnB,iBAAiB,CAACa,YAAY,CAAC;UAC/BE,iBAAiB,GAAG,IAAI,CAACK,gCAAgC,CAAC1B,OAAO,EAAEG,yBAAyB,EAAEE,yBAAyB,CAAC;QAC5H;MACJ;MACA,IAAIsB,mBAAmB,GAAG,CAAC,CAAC;MAC5B,IAAIX,MAAM,IAAII,cAAc,IAAIxB,SAAS,EAAE;QACvC;QACA,MAAM0B,aAAa,GAAG,IAAI,CAACpC,mBAAmB,CAACkC,cAAc,GAAG,CAAC,CAAC;QAClE,IAAIE,aAAa,IAAI,CAAC,EAAE;UACpB;UACA;UACAd,0BAA0B,GAAGY,cAAc,GAAG,CAAC;UAC/CX,2BAA2B,GAAGa,aAAa;UAC3CK,mBAAmB,GAAGJ,IAAI,CAACC,IAAI,CAACF,aAAa,GAAG,IAAI,CAACxC,SAAS,CAACO,UAAU,CAAC,CAAC,CAACoC,UAAU,CAAC;QAC3F,CAAC,MACI;UACDb,mBAAmB,CAACQ,cAAc,CAAC;UACnCO,mBAAmB,GAAG,IAAI,CAACD,gCAAgC,CAAC1B,OAAO,EAAES,2BAA2B,EAAEE,2BAA2B,CAAC;QAClI;MACJ;MACA,IAAIO,QAAQ,KAAK,CAAC,EAAE;QAChBD,aAAa,GAAGI,iBAAiB;QACjC;MACJ;MACA,IAAIH,QAAQ,KAAK,CAAC,EAAE;QAChB,IAAIE,cAAc,IAAIxB,SAAS,IAC3B+B,mBAAmB,IAAI,CAAC,IACxBV,aAAa,GAAG,CAAC,KAAKU,mBAAmB,EAAE;UAC3C;UACA;UACAb,IAAI,GAAG,KAAK;UACZD,eAAe,GAAGO,cAAc;UAChCL,aAAa,GAAGK,cAAc;UAC9Bb,MAAM,GAAGoB,mBAAmB;UAC5B;QACJ;QACA,IAAIR,YAAY,IAAI,CAAC,IACjBE,iBAAiB,IAAI,CAAC,IACtBA,iBAAiB,GAAG,CAAC,KAAKJ,aAAa,EAAE;UACzC;UACAD,MAAM,GAAG,KAAK;UACdH,eAAe,GAAGM,YAAY;UAC9BJ,aAAa,GAAGI,YAAY;UAC5BZ,MAAM,GAAGc,iBAAiB;UAC1B;QACJ;QACAR,eAAe,GAAGrB,UAAU;QAC5BuB,aAAa,GAAGvB,UAAU;QAC1Be,MAAM,GAAGU,aAAa;QACtB,IAAIV,MAAM,KAAK,CAAC,EAAE;UACd;UACA,OAAO;YAAEM,eAAe;YAAEE,aAAa;YAAER;UAAO,CAAC;QACrD;MACJ;MACA,IAAIO,IAAI,EAAE;QACN,IAAIO,iBAAiB,IAAId,MAAM,EAAE;UAC7BM,eAAe,GAAGM,YAAY;QAClC,CAAC,MACI;UACDL,IAAI,GAAG,KAAK;QAChB;MACJ;MACA,IAAIE,MAAM,EAAE;QACR,IAAIW,mBAAmB,IAAIpB,MAAM,EAAE;UAC/BQ,aAAa,GAAGK,cAAc;QAClC,CAAC,MACI;UACDJ,MAAM,GAAG,KAAK;QAClB;MACJ;IACJ;IACA,OAAO;MAAEH,eAAe;MAAEE,aAAa;MAAER;IAAO,CAAC;EACrD;EACAqB,qBAAqBA,CAACf,eAAe,EAAEE,aAAa,EAAEc,cAAc,EAAEC,OAAO,EAAE;IAC3E,IAAIC,EAAE;IACN,MAAMC,MAAM,GAAG,EAAE;IACjB,KAAK,IAAIxC,UAAU,GAAGqB,eAAe,EAAErB,UAAU,IAAIuB,aAAa,EAAEvB,UAAU,EAAE,EAAE;MAC9EwC,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;IACnB;IACA;IACA,MAAMC,sBAAsB,GAAG,IAAI;IACnC,MAAMC,YAAY,GAAG,IAAI,CAACrD,SAAS,CAACqD,YAAY,CAACC,wCAAwC,CAAC,IAAI/D,KAAK,CAACwC,eAAe,EAAE,CAAC,EAAEE,aAAa,EAAE,IAAI,CAACjC,SAAS,CAACuD,gBAAgB,CAACtB,aAAa,CAAC,CAAC,CAAC,CAACuB,OAAO,CAAC,CAAC;IACjM,IAAIC,sBAAsB,GAAGC,SAAS;IACtC,IAAIX,cAAc,IAAIM,YAAY,CAACM,MAAM,GAAG,CAAC,EAAE;MAC3C,MAAMC,gCAAgC,GAAG,CAAC7B,eAAe,IAAIgB,cAAc,CAACrC,UAAU,IAClFqC,cAAc,CAACrC,UAAU,IAAIuB;MAC7B;MAAA,EACEoB,YAAY,GACZ,IAAI,CAACrD,SAAS,CAACqD,YAAY,CAACQ,sBAAsB,CAACtE,KAAK,CAACuE,aAAa,CAACf,cAAc,CAAC,CAAC,CAACS,OAAO,CAAC,CAAC,EAAEO,MAAM,CAAEC,EAAE,IAAKzE,KAAK,CAAC0E,sBAAsB,CAACD,EAAE,CAACE,KAAK,EAAEnB,cAAc,CAAC,CAAC;MAC/KU,sBAAsB,GAAG,CAACR,EAAE,GAAG7D,QAAQ,CAACwE,gCAAgC,EAAGO,CAAC,IAAKf,sBAAsB,IAAIe,CAAC,CAACD,KAAK,CAACnC,eAAe,KAAKoC,CAAC,CAACD,KAAK,CAACjC,aAAa,CAAC,MAAM,IAAI,IAAIgB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACiB,KAAK;IAChN;IACA,MAAME,kCAAkC,GAAG,IAAI,CAACpE,SAAS,CAACO,UAAU,CAAC,CAAC,CAAC8D,8BAA8B,CAACD,kCAAkC;IACxI,MAAME,aAAa,GAAG,IAAIC,2BAA2B,CAAC,CAAC;IACvD,KAAK,MAAMC,IAAI,IAAInB,YAAY,EAAE;MAC7B;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MAMY,IAAI,CAACmB,IAAI,CAACC,mBAAmB,EAAE;QAC3B;MACJ;MACA,MAAMC,QAAQ,GAAGjB,sBAAsB,IAAIe,IAAI,CAACN,KAAK,CAACS,WAAW,CAAClB,sBAAsB,CAAC;MACzF,IAAI,CAACiB,QAAQ,IAAI,CAAC1B,OAAO,CAAC4B,eAAe,EAAE;QACvC;MACJ;MACA,MAAMC,SAAS,GAAGP,aAAa,CAACQ,kBAAkB,CAACN,IAAI,CAACO,YAAY,EAAEP,IAAI,CAACQ,8BAA8B,EAAEZ,kCAAkC,CAAC,IACzIpB,OAAO,CAACiC,eAAe,IAAIP,QAAQ,GAC9B,GAAG,GAAGJ,aAAa,CAACY,eAAe,GACnC,EAAE,CAAC;MACb,MAAMC,KAAK,GAAGX,IAAI,CAACY,mBAAmB,CAACC,gBAAgB,CAAC,CAAC;MACzD,MAAMC,GAAG,GAAGd,IAAI,CAACC,mBAAmB,CAACY,gBAAgB,CAAC,CAAC;MACvD,MAAME,gBAAgB,GAAGvC,OAAO,CAACuC,gBAAgB,KAAK7F,qBAAqB,CAAC8F,OAAO,IAAKxC,OAAO,CAACuC,gBAAgB,KAAK7F,qBAAqB,CAAC+F,gBAAgB,IAAIf,QAAS;MACxK,IAAIF,IAAI,CAACN,KAAK,CAACnC,eAAe,KAAKyC,IAAI,CAACN,KAAK,CAACjC,aAAa,EAAE;QACzD,IAAImB,sBAAsB,IAAImC,gBAAgB,EAAE;UAC5CrC,MAAM,CAACsB,IAAI,CAACN,KAAK,CAACnC,eAAe,GAAGA,eAAe,CAAC,CAACoB,IAAI,CAAC,IAAIxD,WAAW,CAAC,CAAC,CAAC,EAAE6E,IAAI,CAACY,mBAAmB,CAACM,cAAc,CAAC,CAAC,CAACC,MAAM,EAAEd,SAAS,EAAE,IAAIjF,yBAAyB,CAAC,KAAK,EAAE0F,GAAG,CAACK,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACzM;QACA;MACJ;MACA,MAAMC,gBAAgB,GAAG,IAAI,CAACC,4BAA4B,CAACP,GAAG,CAAC;MAC/D,MAAMQ,kBAAkB,GAAG,IAAI,CAACD,4BAA4B,CAACrB,IAAI,CAACY,mBAAmB,CAACC,gBAAgB,CAAC,CAAC,CAAC;MACzG,MAAMU,kBAAkB,GAAGtD,IAAI,CAACuD,GAAG,CAACF,kBAAkB,EAAEF,gBAAgB,EAAEpB,IAAI,CAACyB,2BAA2B,GAAG,CAAC,CAAC;MAC/G,IAAIC,kCAAkC,GAAG,KAAK;MAC9C,MAAMC,eAAe,GAAG9G,OAAO,CAAC+G,uBAAuB,CAAC,IAAI,CAACpG,SAAS,CAACM,cAAc,CAACkE,IAAI,CAACC,mBAAmB,CAAC1C,eAAe,CAAC,CAAC;MAChI,MAAMsE,2BAA2B,GAAGF,eAAe,GAAG3B,IAAI,CAACC,mBAAmB,CAAC6B,WAAW,GAAG,CAAC;MAC9F,IAAID,2BAA2B,EAAE;QAC7BH,kCAAkC,GAAG,IAAI;MAC7C;MACA,MAAMK,2BAA2B,GAAG9D,IAAI,CAAC+D,GAAG,CAACrB,KAAK,CAACzE,UAAU,EAAEqB,eAAe,CAAC;MAC/E,MAAM0E,yBAAyB,GAAGhE,IAAI,CAACuD,GAAG,CAACV,GAAG,CAAC5E,UAAU,EAAEuB,aAAa,CAAC;MACzE,MAAMyE,MAAM,GAAGR,kCAAkC,GAAG,CAAC,GAAG,CAAC;MACzD,KAAK,IAAIS,CAAC,GAAGJ,2BAA2B,EAAEI,CAAC,GAAGF,yBAAyB,GAAGC,MAAM,EAAEC,CAAC,EAAE,EAAE;QACnFzD,MAAM,CAACyD,CAAC,GAAG5E,eAAe,CAAC,CAACoB,IAAI,CAAC,IAAIxD,WAAW,CAACoG,kBAAkB,EAAE,CAAC,CAAC,EAAElB,SAAS,EAAE,IAAI,EAAE8B,CAAC,KAAKxB,KAAK,CAACzE,UAAU,GAAGyE,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC,EAAEgB,CAAC,KAAKrB,GAAG,CAAC5E,UAAU,GAAG4E,GAAG,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;MAClL;MACA,IAAIJ,gBAAgB,EAAE;QAClB,IAAIJ,KAAK,CAACzE,UAAU,IAAIqB,eAAe,IAAI+D,kBAAkB,GAAGC,kBAAkB,EAAE;UAChF7C,MAAM,CAACiC,KAAK,CAACzE,UAAU,GAAGqB,eAAe,CAAC,CAACoB,IAAI,CAAC,IAAIxD,WAAW,CAACoG,kBAAkB,EAAE,CAAC,CAAC,EAAElB,SAAS,EAAE,IAAIjF,yBAAyB,CAAC,KAAK,EAAEuF,KAAK,CAACQ,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACnK;QACA,IAAIL,GAAG,CAAC5E,UAAU,IAAIuB,aAAa,IAAI2D,gBAAgB,GAAGG,kBAAkB,EAAE;UAC1E7C,MAAM,CAACoC,GAAG,CAAC5E,UAAU,GAAGqB,eAAe,CAAC,CAACoB,IAAI,CAAC,IAAIxD,WAAW,CAACoG,kBAAkB,EAAE,CAAC,CAAC,EAAElB,SAAS,EAAE,IAAIjF,yBAAyB,CAAC,CAACsG,kCAAkC,EAAEZ,GAAG,CAACK,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7L;MACJ;IACJ;IACA,KAAK,MAAMiB,MAAM,IAAI1D,MAAM,EAAE;MACzB0D,MAAM,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,aAAa,GAAGD,CAAC,CAACC,aAAa,CAAC;IAC5D;IACA,OAAO9D,MAAM;EACjB;EACA2C,4BAA4BA,CAACoB,QAAQ,EAAE;IACnC,OAAQ3H,aAAa,CAAC4H,uBAAuB,CAAC,IAAI,CAAClH,SAAS,CAACM,cAAc,CAAC2G,QAAQ,CAACvG,UAAU,CAAC,EAAEuG,QAAQ,CAACtB,MAAM,EAAE,IAAI,CAAC3F,SAAS,CAACO,UAAU,CAAC,CAAC,CAACC,OAAO,CAAC,GAAG,CAAC;EAC/J;EACA2G,oBAAoBA,CAACpF,eAAe,EAAEE,aAAa,EAAE;IACjD,IAAI,CAACpB,iBAAiB,CAAC,CAAC;IACxB,MAAMC,SAAS,GAAG,IAAI,CAACd,SAAS,CAACe,YAAY,CAAC,CAAC;IAC/C,IAAIgB,eAAe,GAAG,CAAC,IAAIA,eAAe,GAAGjB,SAAS,EAAE;MACpD,MAAM,IAAIsG,KAAK,CAAC,mCAAmC,CAAC;IACxD;IACA,IAAInF,aAAa,GAAG,CAAC,IAAIA,aAAa,GAAGnB,SAAS,EAAE;MAChD,MAAM,IAAIsG,KAAK,CAAC,iCAAiC,CAAC;IACtD;IACA,MAAMpE,OAAO,GAAG,IAAI,CAAChD,SAAS,CAACO,UAAU,CAAC,CAAC;IAC3C,MAAMS,YAAY,GAAG,IAAI,CAACd,wBAAwB,CAAC,IAAI,CAACF,SAAS,CAACiB,aAAa,CAAC,CAAC,CAAC,CAACD,YAAY;IAC/F,MAAME,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAAO,CAAC;IAC7D,MAAMgC,MAAM,GAAG,IAAImE,KAAK,CAACpF,aAAa,GAAGF,eAAe,GAAG,CAAC,CAAC;IAC7D,IAAIuF,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;IAChC,IAAIC,sBAAsB,GAAG,CAAC,CAAC;IAC/B,IAAIC,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;IAChC,IAAIC,sBAAsB,GAAG,CAAC,CAAC;IAC/B,KAAK,IAAI/G,UAAU,GAAGqB,eAAe,EAAErB,UAAU,IAAIuB,aAAa,EAAEvB,UAAU,EAAE,EAAE;MAC9E,MAAMgH,WAAW,GAAGhH,UAAU,GAAGqB,eAAe;MAChD,MAAMS,aAAa,GAAG,IAAI,CAACpC,mBAAmB,CAACM,UAAU,GAAG,CAAC,CAAC;MAC9D,IAAI8B,aAAa,IAAI,CAAC,EAAE;QACpB;QACA;QACA8E,qBAAqB,GAAG5G,UAAU,GAAG,CAAC;QACtC6G,sBAAsB,GAAG/E,aAAa;QACtCU,MAAM,CAACwE,WAAW,CAAC,GAAGjF,IAAI,CAACC,IAAI,CAACF,aAAa,GAAGQ,OAAO,CAACL,UAAU,CAAC;QACnE;MACJ;MACA,IAAI2E,qBAAqB,KAAK,CAAC,CAAC,EAAE;QAC9BA,qBAAqB,GAAG,CAAC,CAAC;QAC1BC,sBAAsB,GAAG,CAAC,CAAC;QAC3B;QACA,KAAK,IAAIlH,SAAS,GAAGK,UAAU,GAAG,CAAC,EAAEL,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACb6F,qBAAqB,GAAGjH,SAAS;YACjCkH,sBAAsB,GAAG9F,MAAM;YAC/B;UACJ;QACJ;MACJ;MACA,IAAI+F,qBAAqB,KAAK,CAAC,CAAC,KAC3BA,qBAAqB,KAAK,CAAC,CAAC,IAAIA,qBAAqB,GAAG9G,UAAU,GAAG,CAAC,CAAC,EAAE;QAC1E8G,qBAAqB,GAAG,CAAC,CAAC;QAC1BC,sBAAsB,GAAG,CAAC,CAAC;QAC3B;QACA,KAAK,IAAIpH,SAAS,GAAGK,UAAU,EAAEL,SAAS,GAAGS,SAAS,EAAET,SAAS,EAAE,EAAE;UACjE,MAAMoB,MAAM,GAAG,IAAI,CAACrB,mBAAmB,CAACC,SAAS,CAAC;UAClD,IAAIoB,MAAM,IAAI,CAAC,EAAE;YACb+F,qBAAqB,GAAGnH,SAAS;YACjCoH,sBAAsB,GAAGhG,MAAM;YAC/B;UACJ;QACJ;MACJ;MACAyB,MAAM,CAACwE,WAAW,CAAC,GAAG,IAAI,CAAC9E,gCAAgC,CAAC1B,OAAO,EAAEqG,sBAAsB,EAAEE,sBAAsB,CAAC;IACxH;IACA,OAAOvE,MAAM;EACjB;EACAN,gCAAgCA,CAAC1B,OAAO,EAAEqG,sBAAsB,EAAEE,sBAAsB,EAAE;IACtF,MAAMzE,OAAO,GAAG,IAAI,CAAChD,SAAS,CAACO,UAAU,CAAC,CAAC;IAC3C,IAAIgH,sBAAsB,KAAK,CAAC,CAAC,IAAIE,sBAAsB,KAAK,CAAC,CAAC,EAAE;MAChE;MACA,OAAO,CAAC;IACZ,CAAC,MACI,IAAIF,sBAAsB,GAAGE,sBAAsB,EAAE;MACtD;MACA,OAAO,CAAC,GAAGhF,IAAI,CAACkF,KAAK,CAACJ,sBAAsB,GAAGvE,OAAO,CAACL,UAAU,CAAC;IACtE,CAAC,MACI,IAAI4E,sBAAsB,KAAKE,sBAAsB,EAAE;MACxD;MACA,OAAOhF,IAAI,CAACC,IAAI,CAAC+E,sBAAsB,GAAGzE,OAAO,CAACL,UAAU,CAAC;IACjE,CAAC,MACI;MACD,IAAIzB,OAAO,EAAE;QACT;QACA,OAAOuB,IAAI,CAACC,IAAI,CAAC+E,sBAAsB,GAAGzE,OAAO,CAACL,UAAU,CAAC;MACjE,CAAC,MACI;QACD;QACA,OAAO,CAAC,GAAGF,IAAI,CAACkF,KAAK,CAACF,sBAAsB,GAAGzE,OAAO,CAACL,UAAU,CAAC;MACtE;IACJ;EACJ;AACJ;AACA,OAAO,MAAM4B,2BAA2B,CAAC;EACrCxE,WAAWA,CAAA,EAAG;IACV,IAAI,CAACmF,eAAe,GAAG,eAAe;EAC1C;EACAJ,kBAAkBA,CAACC,YAAY,EAAEC,8BAA8B,EAAEZ,kCAAkC,EAAE;IACjG,OAAO,IAAI,CAACwD,yBAAyB,CAACxD,kCAAkC,GAAGY,8BAA8B,GAAGD,YAAY,CAAC;EAC7H;EACA6C,yBAAyBA,CAACC,KAAK,EAAE;IAC7B;IACA;IACA,OAAQ,4BAA2BA,KAAK,GAAG,EAAG,EAAC;EACnD;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}