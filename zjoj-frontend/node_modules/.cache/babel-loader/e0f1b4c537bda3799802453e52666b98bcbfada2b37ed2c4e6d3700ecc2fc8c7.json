{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Range } from '../../../common/core/range.js';\nimport { countEOL } from '../../../common/core/eolCounter.js';\nexport class HiddenRangeModel {\n  get onDidChange() {\n    return this._updateEventEmitter.event;\n  }\n  get hiddenRanges() {\n    return this._hiddenRanges;\n  }\n  constructor(model) {\n    this._updateEventEmitter = new Emitter();\n    this._hasLineChanges = false;\n    this._foldingModel = model;\n    this._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n    this._hiddenRanges = [];\n    if (model.regions.length) {\n      this.updateHiddenRanges();\n    }\n  }\n  notifyChangeModelContent(e) {\n    if (this._hiddenRanges.length && !this._hasLineChanges) {\n      this._hasLineChanges = e.changes.some(change => {\n        return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n      });\n    }\n  }\n  updateHiddenRanges() {\n    let updateHiddenAreas = false;\n    const newHiddenAreas = [];\n    let i = 0; // index into hidden\n    let k = 0;\n    let lastCollapsedStart = Number.MAX_VALUE;\n    let lastCollapsedEnd = -1;\n    const ranges = this._foldingModel.regions;\n    for (; i < ranges.length; i++) {\n      if (!ranges.isCollapsed(i)) {\n        continue;\n      }\n      const startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n      const endLineNumber = ranges.getEndLineNumber(i);\n      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n        // ignore ranges contained in collapsed regions\n        continue;\n      }\n      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n        // reuse the old ranges\n        newHiddenAreas.push(this._hiddenRanges[k]);\n        k++;\n      } else {\n        updateHiddenAreas = true;\n        newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n      }\n      lastCollapsedStart = startLineNumber;\n      lastCollapsedEnd = endLineNumber;\n    }\n    if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n      this.applyHiddenRanges(newHiddenAreas);\n    }\n  }\n  applyHiddenRanges(newHiddenAreas) {\n    this._hiddenRanges = newHiddenAreas;\n    this._hasLineChanges = false;\n    this._updateEventEmitter.fire(newHiddenAreas);\n  }\n  hasRanges() {\n    return this._hiddenRanges.length > 0;\n  }\n  isHidden(line) {\n    return findRange(this._hiddenRanges, line) !== null;\n  }\n  adjustSelections(selections) {\n    let hasChanges = false;\n    const editorModel = this._foldingModel.textModel;\n    let lastRange = null;\n    const adjustLine = line => {\n      if (!lastRange || !isInside(line, lastRange)) {\n        lastRange = findRange(this._hiddenRanges, line);\n      }\n      if (lastRange) {\n        return lastRange.startLineNumber - 1;\n      }\n      return null;\n    };\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let selection = selections[i];\n      const adjustedStartLine = adjustLine(selection.startLineNumber);\n      if (adjustedStartLine) {\n        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n        hasChanges = true;\n      }\n      const adjustedEndLine = adjustLine(selection.endLineNumber);\n      if (adjustedEndLine) {\n        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n        hasChanges = true;\n      }\n      selections[i] = selection;\n    }\n    return hasChanges;\n  }\n  dispose() {\n    if (this.hiddenRanges.length > 0) {\n      this._hiddenRanges = [];\n      this._updateEventEmitter.fire(this._hiddenRanges);\n    }\n    if (this._foldingModelListener) {\n      this._foldingModelListener.dispose();\n      this._foldingModelListener = null;\n    }\n  }\n}\nfunction isInside(line, range) {\n  return line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges, line) {\n  const i = findFirstIdxMonotonousOrArrLen(ranges, r => line < r.startLineNumber) - 1;\n  if (i >= 0 && ranges[i].endLineNumber >= line) {\n    return ranges[i];\n  }\n  return null;\n}","map":{"version":3,"names":["findFirstIdxMonotonousOrArrLen","Emitter","Range","countEOL","HiddenRangeModel","onDidChange","_updateEventEmitter","event","hiddenRanges","_hiddenRanges","constructor","model","_hasLineChanges","_foldingModel","_foldingModelListener","_","updateHiddenRanges","regions","length","notifyChangeModelContent","e","changes","some","change","range","endLineNumber","startLineNumber","text","updateHiddenAreas","newHiddenAreas","i","k","lastCollapsedStart","Number","MAX_VALUE","lastCollapsedEnd","ranges","isCollapsed","getStartLineNumber","getEndLineNumber","push","applyHiddenRanges","fire","hasRanges","isHidden","line","findRange","adjustSelections","selections","hasChanges","editorModel","textModel","lastRange","adjustLine","isInside","len","selection","adjustedStartLine","setStartPosition","getLineMaxColumn","adjustedEndLine","setEndPosition","dispose","r"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Range } from '../../../common/core/range.js';\nimport { countEOL } from '../../../common/core/eolCounter.js';\nexport class HiddenRangeModel {\n    get onDidChange() { return this._updateEventEmitter.event; }\n    get hiddenRanges() { return this._hiddenRanges; }\n    constructor(model) {\n        this._updateEventEmitter = new Emitter();\n        this._hasLineChanges = false;\n        this._foldingModel = model;\n        this._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n        this._hiddenRanges = [];\n        if (model.regions.length) {\n            this.updateHiddenRanges();\n        }\n    }\n    notifyChangeModelContent(e) {\n        if (this._hiddenRanges.length && !this._hasLineChanges) {\n            this._hasLineChanges = e.changes.some(change => {\n                return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n            });\n        }\n    }\n    updateHiddenRanges() {\n        let updateHiddenAreas = false;\n        const newHiddenAreas = [];\n        let i = 0; // index into hidden\n        let k = 0;\n        let lastCollapsedStart = Number.MAX_VALUE;\n        let lastCollapsedEnd = -1;\n        const ranges = this._foldingModel.regions;\n        for (; i < ranges.length; i++) {\n            if (!ranges.isCollapsed(i)) {\n                continue;\n            }\n            const startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n            const endLineNumber = ranges.getEndLineNumber(i);\n            if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n                // ignore ranges contained in collapsed regions\n                continue;\n            }\n            if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n                // reuse the old ranges\n                newHiddenAreas.push(this._hiddenRanges[k]);\n                k++;\n            }\n            else {\n                updateHiddenAreas = true;\n                newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            }\n            lastCollapsedStart = startLineNumber;\n            lastCollapsedEnd = endLineNumber;\n        }\n        if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n            this.applyHiddenRanges(newHiddenAreas);\n        }\n    }\n    applyHiddenRanges(newHiddenAreas) {\n        this._hiddenRanges = newHiddenAreas;\n        this._hasLineChanges = false;\n        this._updateEventEmitter.fire(newHiddenAreas);\n    }\n    hasRanges() {\n        return this._hiddenRanges.length > 0;\n    }\n    isHidden(line) {\n        return findRange(this._hiddenRanges, line) !== null;\n    }\n    adjustSelections(selections) {\n        let hasChanges = false;\n        const editorModel = this._foldingModel.textModel;\n        let lastRange = null;\n        const adjustLine = (line) => {\n            if (!lastRange || !isInside(line, lastRange)) {\n                lastRange = findRange(this._hiddenRanges, line);\n            }\n            if (lastRange) {\n                return lastRange.startLineNumber - 1;\n            }\n            return null;\n        };\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let selection = selections[i];\n            const adjustedStartLine = adjustLine(selection.startLineNumber);\n            if (adjustedStartLine) {\n                selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n                hasChanges = true;\n            }\n            const adjustedEndLine = adjustLine(selection.endLineNumber);\n            if (adjustedEndLine) {\n                selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n                hasChanges = true;\n            }\n            selections[i] = selection;\n        }\n        return hasChanges;\n    }\n    dispose() {\n        if (this.hiddenRanges.length > 0) {\n            this._hiddenRanges = [];\n            this._updateEventEmitter.fire(this._hiddenRanges);\n        }\n        if (this._foldingModelListener) {\n            this._foldingModelListener.dispose();\n            this._foldingModelListener = null;\n        }\n    }\n}\nfunction isInside(line, range) {\n    return line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges, line) {\n    const i = findFirstIdxMonotonousOrArrLen(ranges, r => line < r.startLineNumber) - 1;\n    if (i >= 0 && ranges[i].endLineNumber >= line) {\n        return ranges[i];\n    }\n    return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}