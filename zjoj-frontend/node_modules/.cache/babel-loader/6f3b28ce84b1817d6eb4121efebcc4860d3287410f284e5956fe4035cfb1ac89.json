{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport class AbstractKeybindingService extends Disposable {\n  get onDidUpdateKeybindings() {\n    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n  }\n  get inChordMode() {\n    return this._currentChords.length > 0;\n  }\n  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    super();\n    this._contextKeyService = _contextKeyService;\n    this._commandService = _commandService;\n    this._telemetryService = _telemetryService;\n    this._notificationService = _notificationService;\n    this._logService = _logService;\n    this._onDidUpdateKeybindings = this._register(new Emitter());\n    this._currentChords = [];\n    this._currentChordChecker = new IntervalTimer();\n    this._currentChordStatusMessage = null;\n    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n    this._currentSingleModifier = null;\n    this._currentSingleModifierClearTimeout = new TimeoutTimer();\n    this._logging = false;\n  }\n  dispose() {\n    super.dispose();\n  }\n  _log(str) {\n    if (this._logging) {\n      this._logService.info(`[KeybindingService]: ${str}`);\n    }\n  }\n  getKeybindings() {\n    return this._getResolver().getKeybindings();\n  }\n  lookupKeybinding(commandId, context) {\n    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n    if (!result) {\n      return undefined;\n    }\n    return result.resolvedKeybinding;\n  }\n  dispatchEvent(e, target) {\n    return this._dispatch(e, target);\n  }\n  // TODO@ulugbekna: update namings to align with `_doDispatch`\n  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n  softDispatch(e, target) {\n    this._log(`/ Soft dispatching keyboard event`);\n    const keybinding = this.resolveKeyboardEvent(e);\n    if (keybinding.hasMultipleChords()) {\n      console.warn('keyboard event should not be mapped to multiple chords');\n      return NoMatchingKb;\n    }\n    const [firstChord] = keybinding.getDispatchChords();\n    if (firstChord === null) {\n      // cannot be dispatched, probably only modifier keys\n      this._log(`\\\\ Keyboard event cannot be dispatched`);\n      return NoMatchingKb;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const currentChords = this._currentChords.map(({\n      keypress\n    }) => keypress);\n    return this._getResolver().resolve(contextValue, currentChords, firstChord);\n  }\n  _scheduleLeaveChordMode() {\n    const chordLastInteractedTime = Date.now();\n    this._currentChordChecker.cancelAndSet(() => {\n      if (!this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        this._leaveChordMode();\n        return;\n      }\n      if (Date.now() - chordLastInteractedTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        this._leaveChordMode();\n      }\n    }, 500);\n  }\n  _expectAnotherChord(firstChord, keypressLabel) {\n    this._currentChords.push({\n      keypress: firstChord,\n      label: keypressLabel\n    });\n    switch (this._currentChords.length) {\n      case 0:\n        throw illegalState('impossible');\n      case 1:\n        // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n        break;\n      default:\n        {\n          const fullKeypressLabel = this._currentChords.map(({\n            label\n          }) => label).join(', ');\n          this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n        }\n    }\n    this._scheduleLeaveChordMode();\n    if (IME.enabled) {\n      IME.disable();\n    }\n  }\n  _leaveChordMode() {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n      this._currentChordStatusMessage = null;\n    }\n    this._currentChordChecker.cancel();\n    this._currentChords = [];\n    IME.enable();\n  }\n  _dispatch(e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/false);\n  }\n  _singleModifierDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n    const [singleModifier] = keybinding.getSingleModifierDispatchChords();\n    if (singleModifier) {\n      if (this._ignoreSingleModifiers.has(singleModifier)) {\n        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n      }\n      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n      if (this._currentSingleModifier === null) {\n        // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n        this._currentSingleModifier = singleModifier;\n        this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n          this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n          this._currentSingleModifier = null;\n        }, 300);\n        return false;\n      }\n      if (singleModifier === this._currentSingleModifier) {\n        // bingo!\n        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return this._doDispatch(keybinding, target, /*isSingleModiferChord*/true);\n      }\n      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n      this._currentSingleModifierClearTimeout.cancel();\n      this._currentSingleModifier = null;\n      return false;\n    }\n    // When pressing a modifier and holding it pressed with any other modifier or key combination,\n    // the pressed modifiers should no longer be considered for single modifier dispatch.\n    const [firstChord] = keybinding.getChords();\n    this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n    if (this._currentSingleModifier !== null) {\n      this._log(`+ Clearing single modifier due to other key up.`);\n    }\n    this._currentSingleModifierClearTimeout.cancel();\n    this._currentSingleModifier = null;\n    return false;\n  }\n  _doDispatch(userKeypress, target, isSingleModiferChord = false) {\n    var _a;\n    let shouldPreventDefault = false;\n    if (userKeypress.hasMultipleChords()) {\n      // warn - because user can press a single chord at a time\n      console.warn('Unexpected keyboard event mapped to multiple chords');\n      return false;\n    }\n    let userPressedChord = null;\n    let currentChords = null;\n    if (isSingleModiferChord) {\n      // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n      // A single modifier can only occur when the same modifier is pressed in short sequence,\n      // hence we disregard `_currentChord` and use the same modifier instead.\n      const [dispatchKeyname] = userKeypress.getSingleModifierDispatchChords();\n      userPressedChord = dispatchKeyname;\n      currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n    } else {\n      [userPressedChord] = userKeypress.getDispatchChords();\n      currentChords = this._currentChords.map(({\n        keypress\n      }) => keypress);\n    }\n    if (userPressedChord === null) {\n      this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n      // cannot be dispatched, probably only modifier keys\n      return shouldPreventDefault;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const keypressLabel = userKeypress.getLabel();\n    const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n    switch (resolveResult.kind) {\n      case 0 /* ResultKind.NoMatchingKb */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ No matching keybinding ]`);\n          if (this.inChordMode) {\n            const currentChordsLabel = this._currentChords.map(({\n              label\n            }) => label).join(', ');\n            this._log(`+ Leaving multi-chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n            this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), {\n              hideAfter: 10 * 1000 /* 10s */\n            });\n            this._leaveChordMode();\n            shouldPreventDefault = true;\n          }\n          return shouldPreventDefault;\n        }\n      case 1 /* ResultKind.MoreChordsNeeded */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Several keybindings match - more chords needed ]`);\n          shouldPreventDefault = true;\n          this._expectAnotherChord(userPressedChord, keypressLabel);\n          this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);\n          return shouldPreventDefault;\n        }\n      case 2 /* ResultKind.KbFound */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);\n          if (resolveResult.commandId === null || resolveResult.commandId === '') {\n            if (this.inChordMode) {\n              const currentChordsLabel = this._currentChords.map(({\n                label\n              }) => label).join(', ');\n              this._log(`+ Leaving chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n              this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), {\n                hideAfter: 10 * 1000 /* 10s */\n              });\n              this._leaveChordMode();\n              shouldPreventDefault = true;\n            }\n          } else {\n            if (this.inChordMode) {\n              this._leaveChordMode();\n            }\n            if (!resolveResult.isBubble) {\n              shouldPreventDefault = true;\n            }\n            this._log(`+ Invoking command ${resolveResult.commandId}.`);\n            if (typeof resolveResult.commandArgs === 'undefined') {\n              this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n            } else {\n              this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n            }\n            if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n              this._telemetryService.publicLog2('workbenchActionExecuted', {\n                id: resolveResult.commandId,\n                from: 'keybinding',\n                detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined\n              });\n            }\n          }\n          return shouldPreventDefault;\n        }\n    }\n  }\n  mightProducePrintableCharacter(event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    }\n    // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n    if (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */ || event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */) {\n      return true;\n    }\n    return false;\n  }\n}\nclass KeybindingModifierSet {\n  constructor(source) {\n    this._ctrlKey = source ? source.ctrlKey : false;\n    this._shiftKey = source ? source.shiftKey : false;\n    this._altKey = source ? source.altKey : false;\n    this._metaKey = source ? source.metaKey : false;\n  }\n  has(modifier) {\n    switch (modifier) {\n      case 'ctrl':\n        return this._ctrlKey;\n      case 'shift':\n        return this._shiftKey;\n      case 'alt':\n        return this._altKey;\n      case 'meta':\n        return this._metaKey;\n    }\n  }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);","map":{"version":3,"names":["IntervalTimer","TimeoutTimer","illegalState","Emitter","Event","IME","Disposable","nls","NoMatchingKb","HIGH_FREQ_COMMANDS","AbstractKeybindingService","onDidUpdateKeybindings","_onDidUpdateKeybindings","event","None","inChordMode","_currentChords","length","constructor","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_register","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","EMPTY","_currentSingleModifier","_currentSingleModifierClearTimeout","_logging","dispose","_log","str","info","getKeybindings","_getResolver","lookupKeybinding","commandId","context","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","hasMultipleChords","console","warn","firstChord","getDispatchChords","contextValue","getContext","currentChords","map","keypress","resolve","_scheduleLeaveChordMode","chordLastInteractedTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","_expectAnotherChord","keypressLabel","push","label","status","localize","fullKeypressLabel","join","enabled","disable","cancel","enable","_doDispatch","_singleModifierDispatch","singleModifier","getSingleModifierDispatchChords","has","getChords","userKeypress","isSingleModiferChord","_a","shouldPreventDefault","userPressedChord","dispatchKeyname","getLabel","resolveResult","kind","trace","currentChordsLabel","hideAfter","isBubble","commandArgs","executeCommand","then","err","test","publicLog2","id","from","detail","getUserSettingsLabel","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode","source","_ctrlKey","_shiftKey","shiftKey","_altKey","altKey","_metaKey","modifier"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport class AbstractKeybindingService extends Disposable {\n    get onDidUpdateKeybindings() {\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n    get inChordMode() {\n        return this._currentChords.length > 0;\n    }\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._commandService = _commandService;\n        this._telemetryService = _telemetryService;\n        this._notificationService = _notificationService;\n        this._logService = _logService;\n        this._onDidUpdateKeybindings = this._register(new Emitter());\n        this._currentChords = [];\n        this._currentChordChecker = new IntervalTimer();\n        this._currentChordStatusMessage = null;\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifier = null;\n        this._currentSingleModifierClearTimeout = new TimeoutTimer();\n        this._logging = false;\n    }\n    dispose() {\n        super.dispose();\n    }\n    _log(str) {\n        if (this._logging) {\n            this._logService.info(`[KeybindingService]: ${str}`);\n        }\n    }\n    getKeybindings() {\n        return this._getResolver().getKeybindings();\n    }\n    lookupKeybinding(commandId, context) {\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n        if (!result) {\n            return undefined;\n        }\n        return result.resolvedKeybinding;\n    }\n    dispatchEvent(e, target) {\n        return this._dispatch(e, target);\n    }\n    // TODO@ulugbekna: update namings to align with `_doDispatch`\n    // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n    softDispatch(e, target) {\n        this._log(`/ Soft dispatching keyboard event`);\n        const keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.hasMultipleChords()) {\n            console.warn('keyboard event should not be mapped to multiple chords');\n            return NoMatchingKb;\n        }\n        const [firstChord,] = keybinding.getDispatchChords();\n        if (firstChord === null) {\n            // cannot be dispatched, probably only modifier keys\n            this._log(`\\\\ Keyboard event cannot be dispatched`);\n            return NoMatchingKb;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const currentChords = this._currentChords.map((({ keypress }) => keypress));\n        return this._getResolver().resolve(contextValue, currentChords, firstChord);\n    }\n    _scheduleLeaveChordMode() {\n        const chordLastInteractedTime = Date.now();\n        this._currentChordChecker.cancelAndSet(() => {\n            if (!this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordLastInteractedTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                this._leaveChordMode();\n            }\n        }, 500);\n    }\n    _expectAnotherChord(firstChord, keypressLabel) {\n        this._currentChords.push({ keypress: firstChord, label: keypressLabel });\n        switch (this._currentChords.length) {\n            case 0:\n                throw illegalState('impossible');\n            case 1:\n                // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n                break;\n            default: {\n                const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(', ');\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n            }\n        }\n        this._scheduleLeaveChordMode();\n        if (IME.enabled) {\n            IME.disable();\n        }\n    }\n    _leaveChordMode() {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChords = [];\n        IME.enable();\n    }\n    _dispatch(e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);\n    }\n    _singleModifierDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        const [singleModifier,] = keybinding.getSingleModifierDispatchChords();\n        if (singleModifier) {\n            if (this._ignoreSingleModifiers.has(singleModifier)) {\n                this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n                this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return false;\n            }\n            this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n            if (this._currentSingleModifier === null) {\n                // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n                this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n                this._currentSingleModifier = singleModifier;\n                this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n                    this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n                    this._currentSingleModifier = null;\n                }, 300);\n                return false;\n            }\n            if (singleModifier === this._currentSingleModifier) {\n                // bingo!\n                this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return this._doDispatch(keybinding, target, /*isSingleModiferChord*/ true);\n            }\n            this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n            this._currentSingleModifierClearTimeout.cancel();\n            this._currentSingleModifier = null;\n            return false;\n        }\n        // When pressing a modifier and holding it pressed with any other modifier or key combination,\n        // the pressed modifiers should no longer be considered for single modifier dispatch.\n        const [firstChord,] = keybinding.getChords();\n        this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n        if (this._currentSingleModifier !== null) {\n            this._log(`+ Clearing single modifier due to other key up.`);\n        }\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n    }\n    _doDispatch(userKeypress, target, isSingleModiferChord = false) {\n        var _a;\n        let shouldPreventDefault = false;\n        if (userKeypress.hasMultipleChords()) { // warn - because user can press a single chord at a time\n            console.warn('Unexpected keyboard event mapped to multiple chords');\n            return false;\n        }\n        let userPressedChord = null;\n        let currentChords = null;\n        if (isSingleModiferChord) {\n            // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n            // A single modifier can only occur when the same modifier is pressed in short sequence,\n            // hence we disregard `_currentChord` and use the same modifier instead.\n            const [dispatchKeyname,] = userKeypress.getSingleModifierDispatchChords();\n            userPressedChord = dispatchKeyname;\n            currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n        }\n        else {\n            [userPressedChord,] = userKeypress.getDispatchChords();\n            currentChords = this._currentChords.map(({ keypress }) => keypress);\n        }\n        if (userPressedChord === null) {\n            this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const keypressLabel = userKeypress.getLabel();\n        const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n        switch (resolveResult.kind) {\n            case 0 /* ResultKind.NoMatchingKb */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ No matching keybinding ]`);\n                if (this.inChordMode) {\n                    const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                    this._log(`+ Leaving multi-chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                    this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                    this._leaveChordMode();\n                    shouldPreventDefault = true;\n                }\n                return shouldPreventDefault;\n            }\n            case 1 /* ResultKind.MoreChordsNeeded */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Several keybindings match - more chords needed ]`);\n                shouldPreventDefault = true;\n                this._expectAnotherChord(userPressedChord, keypressLabel);\n                this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);\n                return shouldPreventDefault;\n            }\n            case 2 /* ResultKind.KbFound */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);\n                if (resolveResult.commandId === null || resolveResult.commandId === '') {\n                    if (this.inChordMode) {\n                        const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                        this._log(`+ Leaving chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                        this._leaveChordMode();\n                        shouldPreventDefault = true;\n                    }\n                }\n                else {\n                    if (this.inChordMode) {\n                        this._leaveChordMode();\n                    }\n                    if (!resolveResult.isBubble) {\n                        shouldPreventDefault = true;\n                    }\n                    this._log(`+ Invoking command ${resolveResult.commandId}.`);\n                    if (typeof resolveResult.commandArgs === 'undefined') {\n                        this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n                    }\n                    else {\n                        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n                    }\n                    if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                        this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding', detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined });\n                    }\n                }\n                return shouldPreventDefault;\n            }\n        }\n    }\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)) {\n            return true;\n        }\n        return false;\n    }\n}\nclass KeybindingModifierSet {\n    constructor(source) {\n        this._ctrlKey = source ? source.ctrlKey : false;\n        this._shiftKey = source ? source.shiftKey : false;\n        this._altKey = source ? source.altKey : false;\n        this._metaKey = source ? source.metaKey : false;\n    }\n    has(modifier) {\n        switch (modifier) {\n            case 'ctrl': return this._ctrlKey;\n            case 'shift': return this._shiftKey;\n            case 'alt': return this._altKey;\n            case 'meta': return this._metaKey;\n        }\n    }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}