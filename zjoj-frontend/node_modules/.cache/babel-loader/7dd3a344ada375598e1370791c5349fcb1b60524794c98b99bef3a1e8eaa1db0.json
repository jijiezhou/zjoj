{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport { defaultSchema } from './schema.js';\nconst own = {}.hasOwnProperty;\n\n/** @type {NodeSchema} */\nconst nodeSchema = {\n  root: {\n    children: all\n  },\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {\n    value: handleValue\n  },\n  '*': {\n    data: allow,\n    position: allow\n  }\n};\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {\n    type: 'root',\n    children: []\n  };\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(Object.assign({}, defaultSchema, schema || {}), node, []);\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0];\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace;\n        }\n      } else {\n        ctx = replace;\n      }\n    }\n  }\n  return ctx;\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  const type = node && node.type;\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  const replacement = {\n    type: node.type\n  };\n  /** @type {boolean | undefined} */\n  let replace;\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type];\n    if (typeof definition === 'function') {\n      definition = definition(schema, node);\n    }\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*']);\n      /** @type {string} */\n      let key;\n      replace = true;\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack);\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined;\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key];\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result;\n          }\n        }\n      }\n    }\n  }\n  if (replace) {\n    return replacement;\n  }\n  return replacement.type === 'element' && schema.strip && !schema.strip.includes(replacement.tagName) ? replacement.children : undefined;\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = [];\n  if (Array.isArray(children)) {\n    let index = -1;\n    if (node.type === 'element') {\n      stack.push(node.tagName);\n    }\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value);\n        } else {\n          results.push(value);\n        }\n      }\n    }\n    if (node.type === 'element') {\n      stack.pop();\n    }\n  }\n  return results;\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {\n    name: handleDoctypeName\n  } : undefined;\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {\n    value: handleCommentValue\n  } : undefined;\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack);\n  /* c8 ignore next */\n  const attrs = schema.attributes || {};\n  /* c8 ignore next */\n  const reqs = schema.required || {};\n  const props = properties || {};\n  const allowed = Object.assign({}, toPropertyValueMap(attrs['*']), toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : []));\n  /** @type {Properties} */\n  const result = {};\n  /** @type {string} */\n  let key;\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key];\n      /** @type {AttributeClean[string]} */\n      let definition;\n      if (own.call(allowed, key)) {\n        definition = allowed[key];\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*'];\n      } else {\n        continue;\n      }\n      value = Array.isArray(value) ? handlePropertyValues(schema, value, key, definition) : handlePropertyValue(schema, value, key, definition);\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n  }\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html';\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : '';\n  let index = -1;\n  if (!name || name === '*' || schema.tagNames && !schema.tagNames.includes(name)) {\n    return false;\n  }\n\n  // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name;\n      }\n    }\n    return false;\n  }\n  return name;\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : '';\n  const index = result.indexOf('-->');\n  return index < 0 ? result : result.slice(0, index);\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : '';\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value;\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1;\n  /** @type {Array<string | number>} */\n  const result = [];\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition);\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if ((typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') && safeProtocol(schema, value, prop) && (definition.length === 0 || definition.some(allowed => allowed && typeof allowed === 'object' && 'flags' in allowed ? allowed.test(String(value)) : allowed === value))) {\n    return schema.clobberPrefix && schema.clobber && schema.clobber.includes(prop) ? schema.clobberPrefix + value : value;\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value);\n  const colon = url.indexOf(':');\n  const questionMark = url.indexOf('?');\n  const numberSign = url.indexOf('#');\n  const slash = url.indexOf('/');\n  const protocols = schema.protocols && own.call(schema.protocols, prop) ? schema.protocols[prop].concat() : [];\n  let index = -1;\n  if (protocols.length === 0 || colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  while (++index < protocols.length) {\n    if (colon === protocols[index].length && url.slice(0, protocols[index].length) === protocols[index]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {};\n  let index = -1;\n  while (++index < values.length) {\n    const value = values[index];\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1);\n    } else {\n      result[value] = [];\n    }\n  }\n  return result;\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data';\n}","map":{"version":3,"names":["defaultSchema","own","hasOwnProperty","nodeSchema","root","children","all","doctype","handleDoctype","comment","handleComment","element","tagName","handleTagName","properties","handleProperties","text","value","handleValue","data","allow","position","sanitize","node","schema","ctx","type","replace","one","Object","assign","Array","isArray","length","stack","replacement","call","definition","allowed","key","result","undefined","strip","includes","results","index","push","pop","allowDoctypes","name","handleDoctypeName","allowComments","handleCommentValue","attrs","attributes","reqs","required","props","toPropertyValueMap","handlePropertyValues","handlePropertyValue","_","tagNames","ancestors","indexOf","slice","values","prop","safeProtocol","some","test","String","clobberPrefix","clobber","url","colon","questionMark","numberSign","slash","protocols","concat","toLowerCase"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/hast-util-sanitize/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {NodeSchema} */\nconst nodeSchema = {\n  root: {children: all},\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {value: handleValue},\n  '*': {data: allow, position: allow}\n}\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {type: 'root', children: []}\n\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(\n      Object.assign({}, defaultSchema, schema || {}),\n      node,\n      []\n    )\n\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0]\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace\n        }\n      } else {\n        ctx = replace\n      }\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  const type = node && node.type\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  const replacement = {type: node.type}\n  /** @type {boolean | undefined} */\n  let replace\n\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type]\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node)\n    }\n\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*'])\n      /** @type {string} */\n      let key\n\n      replace = true\n\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack)\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key]\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result\n          }\n        }\n      }\n    }\n  }\n\n  if (replace) {\n    return replacement\n  }\n\n  return replacement.type === 'element' &&\n    schema.strip &&\n    !schema.strip.includes(replacement.tagName)\n    ? replacement.children\n    : undefined\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    let index = -1\n\n    if (node.type === 'element') {\n      stack.push(node.tagName)\n    }\n\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack)\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      stack.pop()\n    }\n  }\n\n  return results\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {name: handleDoctypeName} : undefined\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {value: handleCommentValue} : undefined\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack)\n  /* c8 ignore next */\n  const attrs = schema.attributes || {}\n  /* c8 ignore next */\n  const reqs = schema.required || {}\n  const props = properties || {}\n  const allowed = Object.assign(\n    {},\n    toPropertyValueMap(attrs['*']),\n    toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : [])\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key]\n      /** @type {AttributeClean[string]} */\n      let definition\n\n      if (own.call(allowed, key)) {\n        definition = allowed[key]\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*']\n      } else {\n        continue\n      }\n\n      value = Array.isArray(value)\n        ? handlePropertyValues(schema, value, key, definition)\n        : handlePropertyValue(schema, value, key, definition)\n\n      if (value !== undefined && value !== null) {\n        result[key] = value\n      }\n    }\n  }\n\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html'\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : ''\n  let index = -1\n\n  if (\n    !name ||\n    name === '*' ||\n    (schema.tagNames && !schema.tagNames.includes(name))\n  ) {\n    return false\n  }\n\n  // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name\n      }\n    }\n\n    return false\n  }\n\n  return name\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : ''\n  const index = result.indexOf('-->')\n  return index < 0 ? result : result.slice(0, index)\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : ''\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1\n  /** @type {Array<string | number>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition)\n\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (\n    (typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string') &&\n    safeProtocol(schema, value, prop) &&\n    (definition.length === 0 ||\n      definition.some((allowed) =>\n        allowed && typeof allowed === 'object' && 'flags' in allowed\n          ? allowed.test(String(value))\n          : allowed === value\n      ))\n  ) {\n    return schema.clobberPrefix &&\n      schema.clobber &&\n      schema.clobber.includes(prop)\n      ? schema.clobberPrefix + value\n      : value\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n  const protocols =\n    schema.protocols && own.call(schema.protocols, prop)\n      ? schema.protocols[prop].concat()\n      : []\n  let index = -1\n\n  if (\n    protocols.length === 0 ||\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  while (++index < protocols.length) {\n    if (\n      colon === protocols[index].length &&\n      url.slice(0, protocols[index].length) === protocols[index]\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1)\n    } else {\n      result[value] = []\n    }\n  }\n\n  return result\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data'\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}