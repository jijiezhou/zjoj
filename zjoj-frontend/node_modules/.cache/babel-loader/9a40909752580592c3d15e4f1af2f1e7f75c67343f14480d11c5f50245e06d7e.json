{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n  _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n  _derived = derived;\n}\nexport class ConvenientObservable {\n  get TChange() {\n    return null;\n  }\n  reportChanges() {\n    this.get();\n  }\n  /** @sealed */\n  read(reader) {\n    if (reader) {\n      return reader.readObservable(this);\n    } else {\n      return this.get();\n    }\n  }\n  map(fnOrOwner, fnOrUndefined) {\n    const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n    const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n    return _derived({\n      owner,\n      debugName: () => {\n        const name = getFunctionName(fn);\n        if (name !== undefined) {\n          return name;\n        }\n        // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n        const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n        const match = regexp.exec(fn.toString());\n        if (match) {\n          return `${this.debugName}.${match[2]}`;\n        }\n        if (!owner) {\n          return `${this.debugName} (mapped)`;\n        }\n        return undefined;\n      }\n    }, reader => fn(this.read(reader), reader));\n  }\n  recomputeInitiallyAndOnChange(store, handleValue) {\n    store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n    return this;\n  }\n}\nexport class BaseObservable extends ConvenientObservable {\n  constructor() {\n    super(...arguments);\n    this.observers = new Set();\n  }\n  addObserver(observer) {\n    const len = this.observers.size;\n    this.observers.add(observer);\n    if (len === 0) {\n      this.onFirstObserverAdded();\n    }\n  }\n  removeObserver(observer) {\n    const deleted = this.observers.delete(observer);\n    if (deleted && this.observers.size === 0) {\n      this.onLastObserverRemoved();\n    }\n  }\n  onFirstObserverAdded() {}\n  onLastObserverRemoved() {}\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n  if (_globalTransaction) {\n    fn(_globalTransaction);\n  } else {\n    const tx = new TransactionImpl(fn, undefined);\n    _globalTransaction = tx;\n    try {\n      fn(tx);\n    } finally {\n      tx.finish(); // During finish, more actions might be added to the transaction.\n      // Which is why we only clear the global transaction after finish.\n      _globalTransaction = undefined;\n    }\n  }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    await fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n  if (!tx) {\n    transaction(fn, getDebugName);\n  } else {\n    fn(tx);\n  }\n}\nexport class TransactionImpl {\n  constructor(_fn, _getDebugName) {\n    var _a;\n    this._fn = _fn;\n    this._getDebugName = _getDebugName;\n    this.updatingObservers = [];\n    (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleBeginTransaction(this);\n  }\n  getDebugName() {\n    if (this._getDebugName) {\n      return this._getDebugName();\n    }\n    return getFunctionName(this._fn);\n  }\n  updateObserver(observer, observable) {\n    // When this gets called while finish is active, they will still get considered\n    this.updatingObservers.push({\n      observer,\n      observable\n    });\n    observer.beginUpdate(observable);\n  }\n  finish() {\n    var _a;\n    const updatingObservers = this.updatingObservers;\n    for (let i = 0; i < updatingObservers.length; i++) {\n      const {\n        observer,\n        observable\n      } = updatingObservers[i];\n      observer.endUpdate(observable);\n    }\n    // Prevent anyone from updating observers from now on.\n    this.updatingObservers = null;\n    (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleEndTransaction();\n  }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(obj, debugNameFn, fn, owner, self) {\n  var _a;\n  const cached = cachedDebugName.get(obj);\n  if (cached) {\n    return cached;\n  }\n  const dbgName = computeDebugName(obj, debugNameFn, fn, owner, self);\n  if (dbgName) {\n    let count = (_a = countPerName.get(dbgName)) !== null && _a !== void 0 ? _a : 0;\n    count++;\n    countPerName.set(dbgName, count);\n    const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n    cachedDebugName.set(obj, result);\n    return result;\n  }\n  return undefined;\n}\nfunction computeDebugName(obj, debugNameFn, fn, owner, self) {\n  const cached = cachedDebugName.get(obj);\n  if (cached) {\n    return cached;\n  }\n  const ownerStr = owner ? formatOwner(owner) + `.` : '';\n  let result;\n  if (debugNameFn !== undefined) {\n    if (typeof debugNameFn === 'function') {\n      result = debugNameFn();\n      if (result !== undefined) {\n        return ownerStr + result;\n      }\n    } else {\n      return ownerStr + debugNameFn;\n    }\n  }\n  if (fn !== undefined) {\n    result = getFunctionName(fn);\n    if (result !== undefined) {\n      return ownerStr + result;\n    }\n  }\n  if (owner !== undefined) {\n    for (const key in owner) {\n      if (owner[key] === self) {\n        return ownerStr + key;\n      }\n    }\n  }\n  return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n  var _a;\n  const id = ownerId.get(owner);\n  if (id) {\n    return id;\n  }\n  const className = getClassName(owner);\n  let count = (_a = countPerClassName.get(className)) !== null && _a !== void 0 ? _a : 0;\n  count++;\n  countPerClassName.set(className, count);\n  const result = count === 1 ? className : `${className}#${count}`;\n  ownerId.set(owner, result);\n  return result;\n}\nfunction getClassName(obj) {\n  const ctor = obj.constructor;\n  if (ctor) {\n    return ctor.name;\n  }\n  return 'Object';\n}\nexport function getFunctionName(fn) {\n  const fnSrc = fn.toString();\n  // Pattern: /** @description ... */\n  const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n  const match = regexp.exec(fnSrc);\n  const result = match ? match[1] : undefined;\n  return result === null || result === void 0 ? void 0 : result.trim();\n}\nexport function observableValue(nameOrOwner, initialValue) {\n  if (typeof nameOrOwner === 'string') {\n    return new ObservableValue(undefined, nameOrOwner, initialValue);\n  } else {\n    return new ObservableValue(nameOrOwner, undefined, initialValue);\n  }\n}\nexport class ObservableValue extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = getDebugName(this, this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'ObservableValue';\n  }\n  constructor(_owner, _debugName, initialValue) {\n    super();\n    this._owner = _owner;\n    this._debugName = _debugName;\n    this._value = initialValue;\n  }\n  get() {\n    return this._value;\n  }\n  set(value, tx, change) {\n    var _a;\n    if (this._value === value) {\n      return;\n    }\n    let _tx;\n    if (!tx) {\n      tx = _tx = new TransactionImpl(() => {}, () => `Setting ${this.debugName}`);\n    }\n    try {\n      const oldValue = this._value;\n      this._setValue(value);\n      (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleObservableChanged(this, {\n        oldValue,\n        newValue: value,\n        change,\n        didChange: true,\n        hadValue: true\n      });\n      for (const observer of this.observers) {\n        tx.updateObserver(observer, this);\n        observer.handleChange(this, change);\n      }\n    } finally {\n      if (_tx) {\n        _tx.finish();\n      }\n    }\n  }\n  toString() {\n    return `${this.debugName}: ${this._value}`;\n  }\n  _setValue(newValue) {\n    this._value = newValue;\n  }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n  if (typeof nameOrOwner === 'string') {\n    return new DisposableObservableValue(undefined, nameOrOwner, initialValue);\n  } else {\n    return new DisposableObservableValue(nameOrOwner, undefined, initialValue);\n  }\n}\nexport class DisposableObservableValue extends ObservableValue {\n  _setValue(newValue) {\n    if (this._value === newValue) {\n      return;\n    }\n    if (this._value) {\n      this._value.dispose();\n    }\n    this._value = newValue;\n  }\n  dispose() {\n    var _a;\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n}","map":{"version":3,"names":["getLogger","_recomputeInitiallyAndOnChange","_setRecomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_derived","_setDerivedOpts","derived","ConvenientObservable","TChange","reportChanges","get","read","reader","readObservable","map","fnOrOwner","fnOrUndefined","owner","undefined","fn","debugName","name","getFunctionName","regexp","match","exec","toString","store","handleValue","add","BaseObservable","constructor","arguments","observers","Set","addObserver","observer","len","size","onFirstObserverAdded","removeObserver","deleted","delete","onLastObserverRemoved","transaction","getDebugName","tx","TransactionImpl","finish","_globalTransaction","globalTransaction","asyncTransaction","subtransaction","_fn","_getDebugName","_a","updatingObservers","handleBeginTransaction","updateObserver","observable","push","beginUpdate","i","length","endUpdate","handleEndTransaction","countPerName","Map","cachedDebugName","WeakMap","obj","debugNameFn","self","cached","dbgName","computeDebugName","count","set","result","ownerStr","formatOwner","key","countPerClassName","ownerId","id","className","getClassName","ctor","fnSrc","trim","observableValue","nameOrOwner","initialValue","ObservableValue","_debugName","_owner","_value","value","change","_tx","oldValue","_setValue","handleObservableChanged","newValue","didChange","hadValue","handleChange","disposableObservableValue","DisposableObservableValue","dispose"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        var _a;\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        var _a;\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleEndTransaction();\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(obj, debugNameFn, fn, owner, self) {\n    var _a;\n    const cached = cachedDebugName.get(obj);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(obj, debugNameFn, fn, owner, self);\n    if (dbgName) {\n        let count = (_a = countPerName.get(dbgName)) !== null && _a !== void 0 ? _a : 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(obj, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(obj, debugNameFn, fn, owner, self) {\n    const cached = cachedDebugName.get(obj);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = owner ? formatOwner(owner) + `.` : '';\n    let result;\n    if (debugNameFn !== undefined) {\n        if (typeof debugNameFn === 'function') {\n            result = debugNameFn();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameFn;\n        }\n    }\n    if (fn !== undefined) {\n        result = getFunctionName(fn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (owner !== undefined) {\n        for (const key in owner) {\n            if (owner[key] === self) {\n                return ownerStr + key;\n            }\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    var _a;\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = (_a = countPerClassName.get(className)) !== null && _a !== void 0 ? _a : 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result === null || result === void 0 ? void 0 : result.trim();\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    if (typeof nameOrOwner === 'string') {\n        return new ObservableValue(undefined, nameOrOwner, initialValue);\n    }\n    else {\n        return new ObservableValue(nameOrOwner, undefined, initialValue);\n    }\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = getDebugName(this, this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'ObservableValue';\n    }\n    constructor(_owner, _debugName, initialValue) {\n        super();\n        this._owner = _owner;\n        this._debugName = _debugName;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        var _a;\n        if (this._value === value) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    if (typeof nameOrOwner === 'string') {\n        return new DisposableObservableValue(undefined, nameOrOwner, initialValue);\n    }\n    else {\n        return new DisposableObservableValue(nameOrOwner, undefined, initialValue);\n    }\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        var _a;\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,cAAc;AACxC,IAAIC,8BAA8B;AAClC,OAAO,SAASC,iCAAiCA,CAACC,6BAA6B,EAAE;EAC7EF,8BAA8B,GAAGE,6BAA6B;AAClE;AACA,IAAIC,QAAQ;AACZ;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,OAAO,EAAE;EACrCF,QAAQ,GAAGE,OAAO;AACtB;AACA,OAAO,MAAMC,oBAAoB,CAAC;EAC9B,IAAIC,OAAOA,CAAA,EAAG;IAAE,OAAO,IAAI;EAAE;EAC7BC,aAAaA,CAAA,EAAG;IACZ,IAAI,CAACC,GAAG,CAAC,CAAC;EACd;EACA;EACAC,IAAIA,CAACC,MAAM,EAAE;IACT,IAAIA,MAAM,EAAE;MACR,OAAOA,MAAM,CAACC,cAAc,CAAC,IAAI,CAAC;IACtC,CAAC,MACI;MACD,OAAO,IAAI,CAACH,GAAG,CAAC,CAAC;IACrB;EACJ;EACAI,GAAGA,CAACC,SAAS,EAAEC,aAAa,EAAE;IAC1B,MAAMC,KAAK,GAAGD,aAAa,KAAKE,SAAS,GAAGA,SAAS,GAAGH,SAAS;IACjE,MAAMI,EAAE,GAAGH,aAAa,KAAKE,SAAS,GAAGH,SAAS,GAAGC,aAAa;IAClE,OAAOZ,QAAQ,CAAC;MACZa,KAAK;MACLG,SAAS,EAAEA,CAAA,KAAM;QACb,MAAMC,IAAI,GAAGC,eAAe,CAACH,EAAE,CAAC;QAChC,IAAIE,IAAI,KAAKH,SAAS,EAAE;UACpB,OAAOG,IAAI;QACf;QACA;QACA,MAAME,MAAM,GAAG,6FAA6F;QAC5G,MAAMC,KAAK,GAAGD,MAAM,CAACE,IAAI,CAACN,EAAE,CAACO,QAAQ,CAAC,CAAC,CAAC;QACxC,IAAIF,KAAK,EAAE;UACP,OAAQ,GAAE,IAAI,CAACJ,SAAU,IAAGI,KAAK,CAAC,CAAC,CAAE,EAAC;QAC1C;QACA,IAAI,CAACP,KAAK,EAAE;UACR,OAAQ,GAAE,IAAI,CAACG,SAAU,WAAU;QACvC;QACA,OAAOF,SAAS;MACpB;IACJ,CAAC,EAAGN,MAAM,IAAKO,EAAE,CAAC,IAAI,CAACR,IAAI,CAACC,MAAM,CAAC,EAAEA,MAAM,CAAC,CAAC;EACjD;EACAT,6BAA6BA,CAACwB,KAAK,EAAEC,WAAW,EAAE;IAC9CD,KAAK,CAACE,GAAG,CAAC5B,8BAA8B,CAAC,IAAI,EAAE2B,WAAW,CAAC,CAAC;IAC5D,OAAO,IAAI;EACf;AACJ;AACA,OAAO,MAAME,cAAc,SAASvB,oBAAoB,CAAC;EACrDwB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC9B;EACAC,WAAWA,CAACC,QAAQ,EAAE;IAClB,MAAMC,GAAG,GAAG,IAAI,CAACJ,SAAS,CAACK,IAAI;IAC/B,IAAI,CAACL,SAAS,CAACJ,GAAG,CAACO,QAAQ,CAAC;IAC5B,IAAIC,GAAG,KAAK,CAAC,EAAE;MACX,IAAI,CAACE,oBAAoB,CAAC,CAAC;IAC/B;EACJ;EACAC,cAAcA,CAACJ,QAAQ,EAAE;IACrB,MAAMK,OAAO,GAAG,IAAI,CAACR,SAAS,CAACS,MAAM,CAACN,QAAQ,CAAC;IAC/C,IAAIK,OAAO,IAAI,IAAI,CAACR,SAAS,CAACK,IAAI,KAAK,CAAC,EAAE;MACtC,IAAI,CAACK,qBAAqB,CAAC,CAAC;IAChC;EACJ;EACAJ,oBAAoBA,CAAA,EAAG,CAAE;EACzBI,qBAAqBA,CAAA,EAAG,CAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACzB,EAAE,EAAE0B,YAAY,EAAE;EAC1C,MAAMC,EAAE,GAAG,IAAIC,eAAe,CAAC5B,EAAE,EAAE0B,YAAY,CAAC;EAChD,IAAI;IACA1B,EAAE,CAAC2B,EAAE,CAAC;EACV,CAAC,SACO;IACJA,EAAE,CAACE,MAAM,CAAC,CAAC;EACf;AACJ;AACA,IAAIC,kBAAkB,GAAG/B,SAAS;AAClC,OAAO,SAASgC,iBAAiBA,CAAC/B,EAAE,EAAE;EAClC,IAAI8B,kBAAkB,EAAE;IACpB9B,EAAE,CAAC8B,kBAAkB,CAAC;EAC1B,CAAC,MACI;IACD,MAAMH,EAAE,GAAG,IAAIC,eAAe,CAAC5B,EAAE,EAAED,SAAS,CAAC;IAC7C+B,kBAAkB,GAAGH,EAAE;IACvB,IAAI;MACA3B,EAAE,CAAC2B,EAAE,CAAC;IACV,CAAC,SACO;MACJA,EAAE,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC;MACb;MACAC,kBAAkB,GAAG/B,SAAS;IAClC;EACJ;AACJ;AACA,OAAO,eAAeiC,gBAAgBA,CAAChC,EAAE,EAAE0B,YAAY,EAAE;EACrD,MAAMC,EAAE,GAAG,IAAIC,eAAe,CAAC5B,EAAE,EAAE0B,YAAY,CAAC;EAChD,IAAI;IACA,MAAM1B,EAAE,CAAC2B,EAAE,CAAC;EAChB,CAAC,SACO;IACJA,EAAE,CAACE,MAAM,CAAC,CAAC;EACf;AACJ;AACA;AACA;AACA;AACA,OAAO,SAASI,cAAcA,CAACN,EAAE,EAAE3B,EAAE,EAAE0B,YAAY,EAAE;EACjD,IAAI,CAACC,EAAE,EAAE;IACLF,WAAW,CAACzB,EAAE,EAAE0B,YAAY,CAAC;EACjC,CAAC,MACI;IACD1B,EAAE,CAAC2B,EAAE,CAAC;EACV;AACJ;AACA,OAAO,MAAMC,eAAe,CAAC;EACzBhB,WAAWA,CAACsB,GAAG,EAAEC,aAAa,EAAE;IAC5B,IAAIC,EAAE;IACN,IAAI,CAACF,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACE,iBAAiB,GAAG,EAAE;IAC3B,CAACD,EAAE,GAAGvD,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIuD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,sBAAsB,CAAC,IAAI,CAAC;EAC3F;EACAZ,YAAYA,CAAA,EAAG;IACX,IAAI,IAAI,CAACS,aAAa,EAAE;MACpB,OAAO,IAAI,CAACA,aAAa,CAAC,CAAC;IAC/B;IACA,OAAOhC,eAAe,CAAC,IAAI,CAAC+B,GAAG,CAAC;EACpC;EACAK,cAAcA,CAACtB,QAAQ,EAAEuB,UAAU,EAAE;IACjC;IACA,IAAI,CAACH,iBAAiB,CAACI,IAAI,CAAC;MAAExB,QAAQ;MAAEuB;IAAW,CAAC,CAAC;IACrDvB,QAAQ,CAACyB,WAAW,CAACF,UAAU,CAAC;EACpC;EACAX,MAAMA,CAAA,EAAG;IACL,IAAIO,EAAE;IACN,MAAMC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB;IAChD,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,iBAAiB,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAM;QAAE1B,QAAQ;QAAEuB;MAAW,CAAC,GAAGH,iBAAiB,CAACM,CAAC,CAAC;MACrD1B,QAAQ,CAAC4B,SAAS,CAACL,UAAU,CAAC;IAClC;IACA;IACA,IAAI,CAACH,iBAAiB,GAAG,IAAI;IAC7B,CAACD,EAAE,GAAGvD,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIuD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACU,oBAAoB,CAAC,CAAC;EACrF;AACJ;AACA,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC9B,MAAMC,eAAe,GAAG,IAAIC,OAAO,CAAC,CAAC;AACrC,OAAO,SAASxB,YAAYA,CAACyB,GAAG,EAAEC,WAAW,EAAEpD,EAAE,EAAEF,KAAK,EAAEuD,IAAI,EAAE;EAC5D,IAAIjB,EAAE;EACN,MAAMkB,MAAM,GAAGL,eAAe,CAAC1D,GAAG,CAAC4D,GAAG,CAAC;EACvC,IAAIG,MAAM,EAAE;IACR,OAAOA,MAAM;EACjB;EACA,MAAMC,OAAO,GAAGC,gBAAgB,CAACL,GAAG,EAAEC,WAAW,EAAEpD,EAAE,EAAEF,KAAK,EAAEuD,IAAI,CAAC;EACnE,IAAIE,OAAO,EAAE;IACT,IAAIE,KAAK,GAAG,CAACrB,EAAE,GAAGW,YAAY,CAACxD,GAAG,CAACgE,OAAO,CAAC,MAAM,IAAI,IAAInB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;IAC/EqB,KAAK,EAAE;IACPV,YAAY,CAACW,GAAG,CAACH,OAAO,EAAEE,KAAK,CAAC;IAChC,MAAME,MAAM,GAAGF,KAAK,KAAK,CAAC,GAAGF,OAAO,GAAI,GAAEA,OAAQ,IAAGE,KAAM,EAAC;IAC5DR,eAAe,CAACS,GAAG,CAACP,GAAG,EAAEQ,MAAM,CAAC;IAChC,OAAOA,MAAM;EACjB;EACA,OAAO5D,SAAS;AACpB;AACA,SAASyD,gBAAgBA,CAACL,GAAG,EAAEC,WAAW,EAAEpD,EAAE,EAAEF,KAAK,EAAEuD,IAAI,EAAE;EACzD,MAAMC,MAAM,GAAGL,eAAe,CAAC1D,GAAG,CAAC4D,GAAG,CAAC;EACvC,IAAIG,MAAM,EAAE;IACR,OAAOA,MAAM;EACjB;EACA,MAAMM,QAAQ,GAAG9D,KAAK,GAAG+D,WAAW,CAAC/D,KAAK,CAAC,GAAI,GAAE,GAAG,EAAE;EACtD,IAAI6D,MAAM;EACV,IAAIP,WAAW,KAAKrD,SAAS,EAAE;IAC3B,IAAI,OAAOqD,WAAW,KAAK,UAAU,EAAE;MACnCO,MAAM,GAAGP,WAAW,CAAC,CAAC;MACtB,IAAIO,MAAM,KAAK5D,SAAS,EAAE;QACtB,OAAO6D,QAAQ,GAAGD,MAAM;MAC5B;IACJ,CAAC,MACI;MACD,OAAOC,QAAQ,GAAGR,WAAW;IACjC;EACJ;EACA,IAAIpD,EAAE,KAAKD,SAAS,EAAE;IAClB4D,MAAM,GAAGxD,eAAe,CAACH,EAAE,CAAC;IAC5B,IAAI2D,MAAM,KAAK5D,SAAS,EAAE;MACtB,OAAO6D,QAAQ,GAAGD,MAAM;IAC5B;EACJ;EACA,IAAI7D,KAAK,KAAKC,SAAS,EAAE;IACrB,KAAK,MAAM+D,GAAG,IAAIhE,KAAK,EAAE;MACrB,IAAIA,KAAK,CAACgE,GAAG,CAAC,KAAKT,IAAI,EAAE;QACrB,OAAOO,QAAQ,GAAGE,GAAG;MACzB;IACJ;EACJ;EACA,OAAO/D,SAAS;AACpB;AACA,MAAMgE,iBAAiB,GAAG,IAAIf,GAAG,CAAC,CAAC;AACnC,MAAMgB,OAAO,GAAG,IAAId,OAAO,CAAC,CAAC;AAC7B,SAASW,WAAWA,CAAC/D,KAAK,EAAE;EACxB,IAAIsC,EAAE;EACN,MAAM6B,EAAE,GAAGD,OAAO,CAACzE,GAAG,CAACO,KAAK,CAAC;EAC7B,IAAImE,EAAE,EAAE;IACJ,OAAOA,EAAE;EACb;EACA,MAAMC,SAAS,GAAGC,YAAY,CAACrE,KAAK,CAAC;EACrC,IAAI2D,KAAK,GAAG,CAACrB,EAAE,GAAG2B,iBAAiB,CAACxE,GAAG,CAAC2E,SAAS,CAAC,MAAM,IAAI,IAAI9B,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;EACtFqB,KAAK,EAAE;EACPM,iBAAiB,CAACL,GAAG,CAACQ,SAAS,EAAET,KAAK,CAAC;EACvC,MAAME,MAAM,GAAGF,KAAK,KAAK,CAAC,GAAGS,SAAS,GAAI,GAAEA,SAAU,IAAGT,KAAM,EAAC;EAChEO,OAAO,CAACN,GAAG,CAAC5D,KAAK,EAAE6D,MAAM,CAAC;EAC1B,OAAOA,MAAM;AACjB;AACA,SAASQ,YAAYA,CAAChB,GAAG,EAAE;EACvB,MAAMiB,IAAI,GAAGjB,GAAG,CAACvC,WAAW;EAC5B,IAAIwD,IAAI,EAAE;IACN,OAAOA,IAAI,CAAClE,IAAI;EACpB;EACA,OAAO,QAAQ;AACnB;AACA,OAAO,SAASC,eAAeA,CAACH,EAAE,EAAE;EAChC,MAAMqE,KAAK,GAAGrE,EAAE,CAACO,QAAQ,CAAC,CAAC;EAC3B;EACA,MAAMH,MAAM,GAAG,qCAAqC;EACpD,MAAMC,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC+D,KAAK,CAAC;EAChC,MAAMV,MAAM,GAAGtD,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGN,SAAS;EAC3C,OAAO4D,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACW,IAAI,CAAC,CAAC;AACxE;AACA,OAAO,SAASC,eAAeA,CAACC,WAAW,EAAEC,YAAY,EAAE;EACvD,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE;IACjC,OAAO,IAAIE,eAAe,CAAC3E,SAAS,EAAEyE,WAAW,EAAEC,YAAY,CAAC;EACpE,CAAC,MACI;IACD,OAAO,IAAIC,eAAe,CAACF,WAAW,EAAEzE,SAAS,EAAE0E,YAAY,CAAC;EACpE;AACJ;AACA,OAAO,MAAMC,eAAe,SAAS/D,cAAc,CAAC;EAChD,IAAIV,SAASA,CAAA,EAAG;IACZ,IAAImC,EAAE;IACN,OAAO,CAACA,EAAE,GAAGV,YAAY,CAAC,IAAI,EAAE,IAAI,CAACiD,UAAU,EAAE5E,SAAS,EAAE,IAAI,CAAC6E,MAAM,EAAE,IAAI,CAAC,MAAM,IAAI,IAAIxC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,iBAAiB;EACtI;EACAxB,WAAWA,CAACgE,MAAM,EAAED,UAAU,EAAEF,YAAY,EAAE;IAC1C,KAAK,CAAC,CAAC;IACP,IAAI,CAACG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACD,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACE,MAAM,GAAGJ,YAAY;EAC9B;EACAlF,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACsF,MAAM;EACtB;EACAnB,GAAGA,CAACoB,KAAK,EAAEnD,EAAE,EAAEoD,MAAM,EAAE;IACnB,IAAI3C,EAAE;IACN,IAAI,IAAI,CAACyC,MAAM,KAAKC,KAAK,EAAE;MACvB;IACJ;IACA,IAAIE,GAAG;IACP,IAAI,CAACrD,EAAE,EAAE;MACLA,EAAE,GAAGqD,GAAG,GAAG,IAAIpD,eAAe,CAAC,MAAM,CAAE,CAAC,EAAE,MAAO,WAAU,IAAI,CAAC3B,SAAU,EAAC,CAAC;IAChF;IACA,IAAI;MACA,MAAMgF,QAAQ,GAAG,IAAI,CAACJ,MAAM;MAC5B,IAAI,CAACK,SAAS,CAACJ,KAAK,CAAC;MACrB,CAAC1C,EAAE,GAAGvD,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIuD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC+C,uBAAuB,CAAC,IAAI,EAAE;QAAEF,QAAQ;QAAEG,QAAQ,EAAEN,KAAK;QAAEC,MAAM;QAAEM,SAAS,EAAE,IAAI;QAAEC,QAAQ,EAAE;MAAK,CAAC,CAAC;MAChK,KAAK,MAAMrE,QAAQ,IAAI,IAAI,CAACH,SAAS,EAAE;QACnCa,EAAE,CAACY,cAAc,CAACtB,QAAQ,EAAE,IAAI,CAAC;QACjCA,QAAQ,CAACsE,YAAY,CAAC,IAAI,EAAER,MAAM,CAAC;MACvC;IACJ,CAAC,SACO;MACJ,IAAIC,GAAG,EAAE;QACLA,GAAG,CAACnD,MAAM,CAAC,CAAC;MAChB;IACJ;EACJ;EACAtB,QAAQA,CAAA,EAAG;IACP,OAAQ,GAAE,IAAI,CAACN,SAAU,KAAI,IAAI,CAAC4E,MAAO,EAAC;EAC9C;EACAK,SAASA,CAACE,QAAQ,EAAE;IAChB,IAAI,CAACP,MAAM,GAAGO,QAAQ;EAC1B;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,yBAAyBA,CAAChB,WAAW,EAAEC,YAAY,EAAE;EACjE,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE;IACjC,OAAO,IAAIiB,yBAAyB,CAAC1F,SAAS,EAAEyE,WAAW,EAAEC,YAAY,CAAC;EAC9E,CAAC,MACI;IACD,OAAO,IAAIgB,yBAAyB,CAACjB,WAAW,EAAEzE,SAAS,EAAE0E,YAAY,CAAC;EAC9E;AACJ;AACA,OAAO,MAAMgB,yBAAyB,SAASf,eAAe,CAAC;EAC3DQ,SAASA,CAACE,QAAQ,EAAE;IAChB,IAAI,IAAI,CAACP,MAAM,KAAKO,QAAQ,EAAE;MAC1B;IACJ;IACA,IAAI,IAAI,CAACP,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACa,OAAO,CAAC,CAAC;IACzB;IACA,IAAI,CAACb,MAAM,GAAGO,QAAQ;EAC1B;EACAM,OAAOA,CAAA,EAAG;IACN,IAAItD,EAAE;IACN,CAACA,EAAE,GAAG,IAAI,CAACyC,MAAM,MAAM,IAAI,IAAIzC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACsD,OAAO,CAAC,CAAC;EACxE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}