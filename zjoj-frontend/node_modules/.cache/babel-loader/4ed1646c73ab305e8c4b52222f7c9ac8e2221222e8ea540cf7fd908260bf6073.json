{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate, fromIdx) {\n  const idx = findLastIdx(array, predicate);\n  if (idx === -1) {\n    return undefined;\n  }\n  return array[idx];\n}\nexport function findLastIdx(array, predicate, fromIndex = array.length - 1) {\n  for (let i = fromIndex; i >= 0; i--) {\n    const element = array[i];\n    if (predicate(element)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n  const idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray {\n  constructor(_array) {\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  findLastMonotonous(predicate) {\n    if (MonotonousArray.assertInvariants) {\n      if (this._prevFindLastPredicate) {\n        for (const item of this._array) {\n          if (this._prevFindLastPredicate(item) && !predicate(item)) {\n            throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n          }\n        }\n      }\n      this._prevFindLastPredicate = predicate;\n    }\n    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n    this._findLastMonotonousLastIdx = idx + 1;\n    return idx === -1 ? undefined : this._array[idx];\n  }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMaxBy(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, max) > 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, max) >= 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMinBy(array, comparator) {\n  return findFirstMaxBy(array, (a, b) => -comparator(a, b));\n}\nexport function findMaxIdxBy(array, comparator) {\n  if (array.length === 0) {\n    return -1;\n  }\n  let maxIdx = 0;\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, array[maxIdx]) > 0) {\n      maxIdx = i;\n    }\n  }\n  return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n  for (const value of items) {\n    const mapped = mapFn(value);\n    if (mapped !== undefined) {\n      return mapped;\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["findLast","array","predicate","fromIdx","idx","findLastIdx","undefined","fromIndex","length","i","element","findLastMonotonous","findLastIdxMonotonous","startIdx","endIdxEx","j","k","Math","floor","findFirstMonotonous","findFirstIdxMonotonousOrArrLen","MonotonousArray","constructor","_array","_findLastMonotonousLastIdx","assertInvariants","_prevFindLastPredicate","item","Error","findFirstMaxBy","comparator","max","findLastMaxBy","findFirstMinBy","a","b","findMaxIdxBy","maxIdx","mapFindFirst","items","mapFn","value","mapped"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate, fromIdx) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nexport function findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray {\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMaxBy(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMinBy(array, comparator) {\n    return findFirstMaxBy(array, (a, b) => -comparator(a, b));\n}\nexport function findMaxIdxBy(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}