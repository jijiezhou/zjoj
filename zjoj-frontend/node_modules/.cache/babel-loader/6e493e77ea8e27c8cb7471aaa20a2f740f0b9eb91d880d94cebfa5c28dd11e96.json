{"ast":null,"code":"/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last value.\n * The key must be JSON serializable.\n*/\nexport class LRUCachedFunction {\n  constructor(fn) {\n    this.fn = fn;\n    this.lastCache = undefined;\n    this.lastArgKey = undefined;\n  }\n  get(arg) {\n    const key = JSON.stringify(arg);\n    if (this.lastArgKey !== key) {\n      this.lastArgKey = key;\n      this.lastCache = this.fn(arg);\n    }\n    return this.lastCache;\n  }\n}\n/**\n * Uses an unbounded cache (referential equality) to memoize the results of the given function.\n*/\nexport class CachedFunction {\n  get cachedValues() {\n    return this._map;\n  }\n  constructor(fn) {\n    this.fn = fn;\n    this._map = new Map();\n  }\n  get(arg) {\n    if (this._map.has(arg)) {\n      return this._map.get(arg);\n    }\n    const value = this.fn(arg);\n    this._map.set(arg, value);\n    return value;\n  }\n}","map":{"version":3,"names":["LRUCachedFunction","constructor","fn","lastCache","undefined","lastArgKey","get","arg","key","JSON","stringify","CachedFunction","cachedValues","_map","Map","has","value","set"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/cache.js"],"sourcesContent":["/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last value.\n * The key must be JSON serializable.\n*/\nexport class LRUCachedFunction {\n    constructor(fn) {\n        this.fn = fn;\n        this.lastCache = undefined;\n        this.lastArgKey = undefined;\n    }\n    get(arg) {\n        const key = JSON.stringify(arg);\n        if (this.lastArgKey !== key) {\n            this.lastArgKey = key;\n            this.lastCache = this.fn(arg);\n        }\n        return this.lastCache;\n    }\n}\n/**\n * Uses an unbounded cache (referential equality) to memoize the results of the given function.\n*/\nexport class CachedFunction {\n    get cachedValues() {\n        return this._map;\n    }\n    constructor(fn) {\n        this.fn = fn;\n        this._map = new Map();\n    }\n    get(arg) {\n        if (this._map.has(arg)) {\n            return this._map.get(arg);\n        }\n        const value = this.fn(arg);\n        this._map.set(arg, value);\n        return value;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,iBAAiB,CAAC;EAC3BC,WAAWA,CAACC,EAAE,EAAE;IACZ,IAAI,CAACA,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,SAAS,GAAGC,SAAS;IAC1B,IAAI,CAACC,UAAU,GAAGD,SAAS;EAC/B;EACAE,GAAGA,CAACC,GAAG,EAAE;IACL,MAAMC,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACH,GAAG,CAAC;IAC/B,IAAI,IAAI,CAACF,UAAU,KAAKG,GAAG,EAAE;MACzB,IAAI,CAACH,UAAU,GAAGG,GAAG;MACrB,IAAI,CAACL,SAAS,GAAG,IAAI,CAACD,EAAE,CAACK,GAAG,CAAC;IACjC;IACA,OAAO,IAAI,CAACJ,SAAS;EACzB;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMQ,cAAc,CAAC;EACxB,IAAIC,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACC,IAAI;EACpB;EACAZ,WAAWA,CAACC,EAAE,EAAE;IACZ,IAAI,CAACA,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACW,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB;EACAR,GAAGA,CAACC,GAAG,EAAE;IACL,IAAI,IAAI,CAACM,IAAI,CAACE,GAAG,CAACR,GAAG,CAAC,EAAE;MACpB,OAAO,IAAI,CAACM,IAAI,CAACP,GAAG,CAACC,GAAG,CAAC;IAC7B;IACA,MAAMS,KAAK,GAAG,IAAI,CAACd,EAAE,CAACK,GAAG,CAAC;IAC1B,IAAI,CAACM,IAAI,CAACI,GAAG,CAACV,GAAG,EAAES,KAAK,CAAC;IACzB,OAAOA,KAAK;EAChB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}