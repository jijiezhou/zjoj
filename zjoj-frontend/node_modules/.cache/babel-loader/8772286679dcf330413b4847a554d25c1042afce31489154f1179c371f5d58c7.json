{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n  // Score: multiple inputs\n  const preparedQuery = query;\n  if (preparedQuery.values && preparedQuery.values.length > 1) {\n    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n  }\n  // Score: single input\n  return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n  let totalScore = 0;\n  const totalMatches = [];\n  for (const queryPiece of query) {\n    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n    if (typeof score !== 'number') {\n      // if a single query value does not match, return with\n      // no score entirely, we require all queries to match\n      return NO_SCORE2;\n    }\n    totalScore += score;\n    totalMatches.push(...matches);\n  }\n  // if we have a score, ensure that the positions are\n  // sorted in ascending order and distinct\n  return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, {\n    firstMatchCanBeWeak: true,\n    boostFullMatch: true\n  });\n  if (!score) {\n    return NO_SCORE2;\n  }\n  return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({\n  score: 0\n});\nfunction normalizeMatches(matches) {\n  // sort matches by start to be able to normalize\n  const sortedMatches = matches.sort((matchA, matchB) => {\n    return matchA.start - matchB.start;\n  });\n  // merge matches that overlap\n  const normalizedMatches = [];\n  let currentMatch = undefined;\n  for (const match of sortedMatches) {\n    // if we have no current match or the matches\n    // do not overlap, we take it as is and remember\n    // it for future merging\n    if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n      currentMatch = match;\n      normalizedMatches.push(match);\n    }\n    // otherwise we merge the matches\n    else {\n      currentMatch.start = Math.min(currentMatch.start, match.start);\n      currentMatch.end = Math.max(currentMatch.end, match.end);\n    }\n  }\n  return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n  if (matchA.end < matchB.start) {\n    return false; // A ends before B starts\n  }\n  if (matchB.end < matchA.start) {\n    return false; // B ends before A starts\n  }\n  return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n  return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n  if (typeof original !== 'string') {\n    original = '';\n  }\n  const originalLowercase = original.toLowerCase();\n  const {\n    pathNormalized,\n    normalized,\n    normalizedLowercase\n  } = normalizeQuery(original);\n  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n  const expectExactMatch = queryExpectsExactMatch(original);\n  let values = undefined;\n  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n  if (originalSplit.length > 1) {\n    for (const originalPiece of originalSplit) {\n      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n      const {\n        pathNormalized: pathNormalizedPiece,\n        normalized: normalizedPiece,\n        normalizedLowercase: normalizedLowercasePiece\n      } = normalizeQuery(originalPiece);\n      if (normalizedPiece) {\n        if (!values) {\n          values = [];\n        }\n        values.push({\n          original: originalPiece,\n          originalLowercase: originalPiece.toLowerCase(),\n          pathNormalized: pathNormalizedPiece,\n          normalized: normalizedPiece,\n          normalizedLowercase: normalizedLowercasePiece,\n          expectContiguousMatch: expectExactMatchPiece\n        });\n      }\n    }\n  }\n  return {\n    original,\n    originalLowercase,\n    pathNormalized,\n    normalized,\n    normalizedLowercase,\n    values,\n    containsPathSeparator,\n    expectContiguousMatch: expectExactMatch\n  };\n}\nfunction normalizeQuery(original) {\n  let pathNormalized;\n  if (isWindows) {\n    pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n  } else {\n    pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n  }\n  // we remove quotes here because quotes are used for exact match search\n  const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n  return {\n    pathNormalized,\n    normalized,\n    normalizedLowercase: normalized.toLowerCase()\n  };\n}\nexport function pieceToQuery(arg1) {\n  if (Array.isArray(arg1)) {\n    return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n  }\n  return prepareQuery(arg1.original);\n}\n//#endregion","map":{"version":3,"names":["createMatches","createFuzzyMatches","fuzzyScore","sep","isWindows","stripWildcards","NO_SCORE2","undefined","scoreFuzzy2","target","query","patternStart","wordStart","preparedQuery","values","length","doScoreFuzzy2Multiple","doScoreFuzzy2Single","totalScore","totalMatches","queryPiece","score","matches","push","normalizeMatches","original","originalLowercase","toLowerCase","firstMatchCanBeWeak","boostFullMatch","NO_ITEM_SCORE","Object","freeze","sortedMatches","sort","matchA","matchB","start","normalizedMatches","currentMatch","match","matchOverlaps","Math","min","end","max","queryExpectsExactMatch","startsWith","endsWith","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","pathNormalized","normalized","normalizedLowercase","normalizeQuery","containsPathSeparator","indexOf","expectExactMatch","originalSplit","split","originalPiece","expectExactMatchPiece","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","expectContiguousMatch","replace","pieceToQuery","arg1","Array","isArray","map","piece","join"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js"],"sourcesContent":["import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n    // Score: multiple inputs\n    const preparedQuery = query;\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n    }\n    // Score: single input\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n    let totalScore = 0;\n    const totalMatches = [];\n    for (const queryPiece of query) {\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n        if (typeof score !== 'number') {\n            // if a single query value does not match, return with\n            // no score entirely, we require all queries to match\n            return NO_SCORE2;\n        }\n        totalScore += score;\n        totalMatches.push(...matches);\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n    return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    if (!score) {\n        return NO_SCORE2;\n    }\n    return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({ score: 0 });\nfunction normalizeMatches(matches) {\n    // sort matches by start to be able to normalize\n    const sortedMatches = matches.sort((matchA, matchB) => {\n        return matchA.start - matchB.start;\n    });\n    // merge matches that overlap\n    const normalizedMatches = [];\n    let currentMatch = undefined;\n    for (const match of sortedMatches) {\n        // if we have no current match or the matches\n        // do not overlap, we take it as is and remember\n        // it for future merging\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n            currentMatch = match;\n            normalizedMatches.push(match);\n        }\n        // otherwise we merge the matches\n        else {\n            currentMatch.start = Math.min(currentMatch.start, match.start);\n            currentMatch.end = Math.max(currentMatch.end, match.end);\n        }\n    }\n    return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n    if (matchA.end < matchB.start) {\n        return false; // A ends before B starts\n    }\n    if (matchB.end < matchA.start) {\n        return false; // B ends before A starts\n    }\n    return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n    return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n    if (typeof original !== 'string') {\n        original = '';\n    }\n    const originalLowercase = original.toLowerCase();\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n    const expectExactMatch = queryExpectsExactMatch(original);\n    let values = undefined;\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n    if (originalSplit.length > 1) {\n        for (const originalPiece of originalSplit) {\n            const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\n            if (normalizedPiece) {\n                if (!values) {\n                    values = [];\n                }\n                values.push({\n                    original: originalPiece,\n                    originalLowercase: originalPiece.toLowerCase(),\n                    pathNormalized: pathNormalizedPiece,\n                    normalized: normalizedPiece,\n                    normalizedLowercase: normalizedLowercasePiece,\n                    expectContiguousMatch: expectExactMatchPiece\n                });\n            }\n        }\n    }\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\nfunction normalizeQuery(original) {\n    let pathNormalized;\n    if (isWindows) {\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n    }\n    else {\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n    }\n    // we remove quotes here because quotes are used for exact match search\n    const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n    return {\n        pathNormalized,\n        normalized,\n        normalizedLowercase: normalized.toLowerCase()\n    };\n}\nexport function pieceToQuery(arg1) {\n    if (Array.isArray(arg1)) {\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n    }\n    return prepareQuery(arg1.original);\n}\n//#endregion\n"],"mappings":";AAAA,SAASA,aAAa,IAAIC,kBAAkB,EAAEC,UAAU,QAAQ,cAAc;AAC9E,SAASC,GAAG,QAAQ,WAAW;AAC/B,SAASC,SAAS,QAAQ,eAAe;AACzC,SAASC,cAAc,QAAQ,cAAc;AAC7C,MAAMC,SAAS,GAAG,CAACC,SAAS,EAAE,EAAE,CAAC;AACjC,OAAO,SAASC,WAAWA,CAACC,MAAM,EAAEC,KAAK,EAAEC,YAAY,GAAG,CAAC,EAAEC,SAAS,GAAG,CAAC,EAAE;EACxE;EACA,MAAMC,aAAa,GAAGH,KAAK;EAC3B,IAAIG,aAAa,CAACC,MAAM,IAAID,aAAa,CAACC,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;IACzD,OAAOC,qBAAqB,CAACP,MAAM,EAAEI,aAAa,CAACC,MAAM,EAAEH,YAAY,EAAEC,SAAS,CAAC;EACvF;EACA;EACA,OAAOK,mBAAmB,CAACR,MAAM,EAAEC,KAAK,EAAEC,YAAY,EAAEC,SAAS,CAAC;AACtE;AACA,SAASI,qBAAqBA,CAACP,MAAM,EAAEC,KAAK,EAAEC,YAAY,EAAEC,SAAS,EAAE;EACnE,IAAIM,UAAU,GAAG,CAAC;EAClB,MAAMC,YAAY,GAAG,EAAE;EACvB,KAAK,MAAMC,UAAU,IAAIV,KAAK,EAAE;IAC5B,MAAM,CAACW,KAAK,EAAEC,OAAO,CAAC,GAAGL,mBAAmB,CAACR,MAAM,EAAEW,UAAU,EAAET,YAAY,EAAEC,SAAS,CAAC;IACzF,IAAI,OAAOS,KAAK,KAAK,QAAQ,EAAE;MAC3B;MACA;MACA,OAAOf,SAAS;IACpB;IACAY,UAAU,IAAIG,KAAK;IACnBF,YAAY,CAACI,IAAI,CAAC,GAAGD,OAAO,CAAC;EACjC;EACA;EACA;EACA,OAAO,CAACJ,UAAU,EAAEM,gBAAgB,CAACL,YAAY,CAAC,CAAC;AACvD;AACA,SAASF,mBAAmBA,CAACR,MAAM,EAAEC,KAAK,EAAEC,YAAY,EAAEC,SAAS,EAAE;EACjE,MAAMS,KAAK,GAAGnB,UAAU,CAACQ,KAAK,CAACe,QAAQ,EAAEf,KAAK,CAACgB,iBAAiB,EAAEf,YAAY,EAAEF,MAAM,EAAEA,MAAM,CAACkB,WAAW,CAAC,CAAC,EAAEf,SAAS,EAAE;IAAEgB,mBAAmB,EAAE,IAAI;IAAEC,cAAc,EAAE;EAAK,CAAC,CAAC;EAC7K,IAAI,CAACR,KAAK,EAAE;IACR,OAAOf,SAAS;EACpB;EACA,OAAO,CAACe,KAAK,CAAC,CAAC,CAAC,EAAEpB,kBAAkB,CAACoB,KAAK,CAAC,CAAC;AAChD;AACA,MAAMS,aAAa,GAAGC,MAAM,CAACC,MAAM,CAAC;EAAEX,KAAK,EAAE;AAAE,CAAC,CAAC;AACjD,SAASG,gBAAgBA,CAACF,OAAO,EAAE;EAC/B;EACA,MAAMW,aAAa,GAAGX,OAAO,CAACY,IAAI,CAAC,CAACC,MAAM,EAAEC,MAAM,KAAK;IACnD,OAAOD,MAAM,CAACE,KAAK,GAAGD,MAAM,CAACC,KAAK;EACtC,CAAC,CAAC;EACF;EACA,MAAMC,iBAAiB,GAAG,EAAE;EAC5B,IAAIC,YAAY,GAAGhC,SAAS;EAC5B,KAAK,MAAMiC,KAAK,IAAIP,aAAa,EAAE;IAC/B;IACA;IACA;IACA,IAAI,CAACM,YAAY,IAAI,CAACE,aAAa,CAACF,YAAY,EAAEC,KAAK,CAAC,EAAE;MACtDD,YAAY,GAAGC,KAAK;MACpBF,iBAAiB,CAACf,IAAI,CAACiB,KAAK,CAAC;IACjC;IACA;IAAA,KACK;MACDD,YAAY,CAACF,KAAK,GAAGK,IAAI,CAACC,GAAG,CAACJ,YAAY,CAACF,KAAK,EAAEG,KAAK,CAACH,KAAK,CAAC;MAC9DE,YAAY,CAACK,GAAG,GAAGF,IAAI,CAACG,GAAG,CAACN,YAAY,CAACK,GAAG,EAAEJ,KAAK,CAACI,GAAG,CAAC;IAC5D;EACJ;EACA,OAAON,iBAAiB;AAC5B;AACA,SAASG,aAAaA,CAACN,MAAM,EAAEC,MAAM,EAAE;EACnC,IAAID,MAAM,CAACS,GAAG,GAAGR,MAAM,CAACC,KAAK,EAAE;IAC3B,OAAO,KAAK,CAAC,CAAC;EAClB;EACA,IAAID,MAAM,CAACQ,GAAG,GAAGT,MAAM,CAACE,KAAK,EAAE;IAC3B,OAAO,KAAK,CAAC,CAAC;EAClB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,SAASS,sBAAsBA,CAACpC,KAAK,EAAE;EACnC,OAAOA,KAAK,CAACqC,UAAU,CAAC,GAAG,CAAC,IAAIrC,KAAK,CAACsC,QAAQ,CAAC,GAAG,CAAC;AACvD;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAG,GAAG;AAC3C,OAAO,SAASC,YAAYA,CAACzB,QAAQ,EAAE;EACnC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAC9BA,QAAQ,GAAG,EAAE;EACjB;EACA,MAAMC,iBAAiB,GAAGD,QAAQ,CAACE,WAAW,CAAC,CAAC;EAChD,MAAM;IAAEwB,cAAc;IAAEC,UAAU;IAAEC;EAAoB,CAAC,GAAGC,cAAc,CAAC7B,QAAQ,CAAC;EACpF,MAAM8B,qBAAqB,GAAGJ,cAAc,CAACK,OAAO,CAACrD,GAAG,CAAC,IAAI,CAAC;EAC9D,MAAMsD,gBAAgB,GAAGX,sBAAsB,CAACrB,QAAQ,CAAC;EACzD,IAAIX,MAAM,GAAGP,SAAS;EACtB,MAAMmD,aAAa,GAAGjC,QAAQ,CAACkC,KAAK,CAACV,+BAA+B,CAAC;EACrE,IAAIS,aAAa,CAAC3C,MAAM,GAAG,CAAC,EAAE;IAC1B,KAAK,MAAM6C,aAAa,IAAIF,aAAa,EAAE;MACvC,MAAMG,qBAAqB,GAAGf,sBAAsB,CAACc,aAAa,CAAC;MACnE,MAAM;QAAET,cAAc,EAAEW,mBAAmB;QAAEV,UAAU,EAAEW,eAAe;QAAEV,mBAAmB,EAAEW;MAAyB,CAAC,GAAGV,cAAc,CAACM,aAAa,CAAC;MACzJ,IAAIG,eAAe,EAAE;QACjB,IAAI,CAACjD,MAAM,EAAE;UACTA,MAAM,GAAG,EAAE;QACf;QACAA,MAAM,CAACS,IAAI,CAAC;UACRE,QAAQ,EAAEmC,aAAa;UACvBlC,iBAAiB,EAAEkC,aAAa,CAACjC,WAAW,CAAC,CAAC;UAC9CwB,cAAc,EAAEW,mBAAmB;UACnCV,UAAU,EAAEW,eAAe;UAC3BV,mBAAmB,EAAEW,wBAAwB;UAC7CC,qBAAqB,EAAEJ;QAC3B,CAAC,CAAC;MACN;IACJ;EACJ;EACA,OAAO;IAAEpC,QAAQ;IAAEC,iBAAiB;IAAEyB,cAAc;IAAEC,UAAU;IAAEC,mBAAmB;IAAEvC,MAAM;IAAEyC,qBAAqB;IAAEU,qBAAqB,EAAER;EAAiB,CAAC;AACnK;AACA,SAASH,cAAcA,CAAC7B,QAAQ,EAAE;EAC9B,IAAI0B,cAAc;EAClB,IAAI/C,SAAS,EAAE;IACX+C,cAAc,GAAG1B,QAAQ,CAACyC,OAAO,CAAC,KAAK,EAAE/D,GAAG,CAAC,CAAC,CAAC;EACnD,CAAC,MACI;IACDgD,cAAc,GAAG1B,QAAQ,CAACyC,OAAO,CAAC,KAAK,EAAE/D,GAAG,CAAC,CAAC,CAAC;EACnD;EACA;EACA,MAAMiD,UAAU,GAAG/C,cAAc,CAAC8C,cAAc,CAAC,CAACe,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;EACtE,OAAO;IACHf,cAAc;IACdC,UAAU;IACVC,mBAAmB,EAAED,UAAU,CAACzB,WAAW,CAAC;EAChD,CAAC;AACL;AACA,OAAO,SAASwC,YAAYA,CAACC,IAAI,EAAE;EAC/B,IAAIC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IACrB,OAAOlB,YAAY,CAACkB,IAAI,CAACG,GAAG,CAACC,KAAK,IAAIA,KAAK,CAAC/C,QAAQ,CAAC,CAACgD,IAAI,CAACxB,+BAA+B,CAAC,CAAC;EAChG;EACA,OAAOC,YAAY,CAACkB,IAAI,CAAC3C,QAAQ,CAAC;AACtC;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}