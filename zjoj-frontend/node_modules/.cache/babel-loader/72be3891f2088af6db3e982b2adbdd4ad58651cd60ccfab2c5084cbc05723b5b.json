{"ast":null,"code":"import \"core-js/modules/es.array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n  static deleteRight(prevEditOperationType, config, model, selections) {\n    const commands = [];\n    let shouldPushStackElementBefore = prevEditOperationType !== 3 /* EditOperationType.DeletingRight */;\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      let deleteSelection = selection;\n      if (deleteSelection.isEmpty()) {\n        const position = selection.getPosition();\n        const rightOfPosition = MoveOperations.right(config, model, position);\n        deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n      }\n      if (deleteSelection.isEmpty()) {\n        // Probably at end of file => ignore\n        commands[i] = null;\n        continue;\n      }\n      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n    return [shouldPushStackElementBefore, commands];\n  }\n  static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n    if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n      return false;\n    }\n    if (autoClosingDelete === 'never') {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      if (!selection.isEmpty()) {\n        return false;\n      }\n      const lineText = model.getLineContent(position.lineNumber);\n      if (position.column < 2 || position.column >= lineText.length + 1) {\n        return false;\n      }\n      const character = lineText.charAt(position.column - 2);\n      const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n      if (!autoClosingPairCandidates) {\n        return false;\n      }\n      if (isQuote(character)) {\n        if (autoClosingQuotes === 'never') {\n          return false;\n        }\n      } else {\n        if (autoClosingBrackets === 'never') {\n          return false;\n        }\n      }\n      const afterCharacter = lineText.charAt(position.column - 1);\n      let foundAutoClosingPair = false;\n      for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n        if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n          foundAutoClosingPair = true;\n        }\n      }\n      if (!foundAutoClosingPair) {\n        return false;\n      }\n      // Must delete the pair only if it was automatically inserted by the editor\n      if (autoClosingDelete === 'auto') {\n        let found = false;\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  static _runAutoClosingPairDelete(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const position = selections[i].getPosition();\n      const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n    return [true, commands];\n  }\n  static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n    if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n      return this._runAutoClosingPairDelete(config, model, selections);\n    }\n    const commands = [];\n    let shouldPushStackElementBefore = prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */;\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n      // Ignore empty delete ranges, as they have no effect\n      // They happen if the cursor is at the beginning of the file.\n      if (deleteRange.isEmpty()) {\n        commands[i] = null;\n        continue;\n      }\n      if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n      commands[i] = new ReplaceCommand(deleteRange, '');\n    }\n    return [shouldPushStackElementBefore, commands];\n  }\n  static getDeleteRange(selection, model, config) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = selection.getPosition();\n    // Unintend when using tab stops and cursor is within indentation\n    if (config.useTabStops && position.column > 1) {\n      const lineContent = model.getLineContent(position.lineNumber);\n      const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      const lastIndentationColumn = firstNonWhitespaceIndex === -1 ? /* entire string is whitespace */lineContent.length + 1 : firstNonWhitespaceIndex + 1;\n      if (position.column <= lastIndentationColumn) {\n        const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n        const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n        const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n        return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n      }\n    }\n    return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n  }\n  static getPositionAfterDeleteLeft(position, model) {\n    if (position.column > 1) {\n      // Convert 1-based columns to 0-based offsets and back.\n      const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n      return position.with(undefined, idx + 1);\n    } else if (position.lineNumber > 1) {\n      const newLine = position.lineNumber - 1;\n      return new Position(newLine, model.getLineMaxColumn(newLine));\n    } else {\n      return position;\n    }\n  }\n  static cut(config, model, selections) {\n    const commands = [];\n    let lastCutRange = null;\n    selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (selection.isEmpty()) {\n        if (config.emptySelectionClipboard) {\n          // This is a full line cut\n          const position = selection.getPosition();\n          let startLineNumber, startColumn, endLineNumber, endColumn;\n          if (position.lineNumber < model.getLineCount()) {\n            // Cutting a line in the middle of the model\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber + 1;\n            endColumn = 1;\n          } else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n            // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n            startLineNumber = position.lineNumber - 1;\n            startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          } else {\n            // Cutting the single line that the model contains\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          }\n          const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n          lastCutRange = deleteSelection;\n          if (!deleteSelection.isEmpty()) {\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n          } else {\n            commands[i] = null;\n          }\n        } else {\n          // Cannot cut empty selection\n          commands[i] = null;\n        }\n      } else {\n        commands[i] = new ReplaceCommand(selection, '');\n      }\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n}","map":{"version":3,"names":["strings","ReplaceCommand","EditOperationResult","isQuote","CursorColumns","MoveOperations","Range","Position","DeleteOperations","deleteRight","prevEditOperationType","config","model","selections","commands","shouldPushStackElementBefore","i","len","length","selection","deleteSelection","isEmpty","position","getPosition","rightOfPosition","right","lineNumber","column","startLineNumber","endLineNumber","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","autoClosedCharacters","lineText","getLineContent","character","charAt","autoClosingPairCandidates","get","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","open","close","found","j","lenJ","autoClosedCharacter","startColumn","_runAutoClosingPairDelete","deleteLeft","autoClosingPairs","autoClosingPairsOpenByEnd","deleteRange","getDeleteRange","useTabStops","lineContent","firstNonWhitespaceIndex","lastIndentationColumn","fromVisibleColumn","visibleColumnFromColumn","toVisibleColumn","prevIndentTabStop","indentSize","toColumn","columnFromVisibleColumn","fromPositions","getPositionAfterDeleteLeft","idx","getLeftDeleteOffset","with","undefined","newLine","getLineMaxColumn","cut","lastCutRange","sort","a","b","compare","getStartPosition","getEndPosition","emptySelectionClipboard","endColumn","getLineCount","shouldPushStackElementAfter"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}