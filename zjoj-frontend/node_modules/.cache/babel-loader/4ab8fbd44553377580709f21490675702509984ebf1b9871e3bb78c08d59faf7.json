{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Scanner {\n  constructor() {\n    this.value = '';\n    this.pos = 0;\n  }\n  static isDigitCharacter(ch) {\n    return ch >= 48 /* CharCode.Digit0 */ && ch <= 57 /* CharCode.Digit9 */;\n  }\n  static isVariableCharacter(ch) {\n    return ch === 95 /* CharCode.Underline */ || ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */ || ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */;\n  }\n  text(value) {\n    this.value = value;\n    this.pos = 0;\n  }\n  tokenText(token) {\n    return this.value.substr(token.pos, token.len);\n  }\n  next() {\n    if (this.pos >= this.value.length) {\n      return {\n        type: 14 /* TokenType.EOF */,\n        pos: this.pos,\n        len: 0\n      };\n    }\n    const pos = this.pos;\n    let len = 0;\n    let ch = this.value.charCodeAt(pos);\n    let type;\n    // static types\n    type = Scanner._table[ch];\n    if (typeof type === 'number') {\n      this.pos += 1;\n      return {\n        type,\n        pos,\n        len: 1\n      };\n    }\n    // number\n    if (Scanner.isDigitCharacter(ch)) {\n      type = 8 /* TokenType.Int */;\n      do {\n        len += 1;\n        ch = this.value.charCodeAt(pos + len);\n      } while (Scanner.isDigitCharacter(ch));\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    }\n    // variable name\n    if (Scanner.isVariableCharacter(ch)) {\n      type = 9 /* TokenType.VariableName */;\n      do {\n        ch = this.value.charCodeAt(pos + ++len);\n      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    }\n    // format\n    type = 10 /* TokenType.Format */;\n    do {\n      len += 1;\n      ch = this.value.charCodeAt(pos + len);\n    } while (!isNaN(ch) && typeof Scanner._table[ch] === 'undefined' // not static token\n    && !Scanner.isDigitCharacter(ch) // not number\n    && !Scanner.isVariableCharacter(ch) // not variable\n    );\n    this.pos += len;\n    return {\n      type,\n      pos,\n      len\n    };\n  }\n}\nScanner._table = {\n  [36 /* CharCode.DollarSign */]: 0 /* TokenType.Dollar */,\n  [58 /* CharCode.Colon */]: 1 /* TokenType.Colon */,\n  [44 /* CharCode.Comma */]: 2 /* TokenType.Comma */,\n  [123 /* CharCode.OpenCurlyBrace */]: 3 /* TokenType.CurlyOpen */,\n  [125 /* CharCode.CloseCurlyBrace */]: 4 /* TokenType.CurlyClose */,\n  [92 /* CharCode.Backslash */]: 5 /* TokenType.Backslash */,\n  [47 /* CharCode.Slash */]: 6 /* TokenType.Forwardslash */,\n  [124 /* CharCode.Pipe */]: 7 /* TokenType.Pipe */,\n  [43 /* CharCode.Plus */]: 11 /* TokenType.Plus */,\n  [45 /* CharCode.Dash */]: 12 /* TokenType.Dash */,\n  [63 /* CharCode.QuestionMark */]: 13 /* TokenType.QuestionMark */\n};\nexport class Marker {\n  constructor() {\n    this._children = [];\n  }\n  appendChild(child) {\n    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n      // this and previous child are text -> merge them\n      this._children[this._children.length - 1].value += child.value;\n    } else {\n      // normal adoption of child\n      child.parent = this;\n      this._children.push(child);\n    }\n    return this;\n  }\n  replace(child, others) {\n    const {\n      parent\n    } = child;\n    const idx = parent.children.indexOf(child);\n    const newChildren = parent.children.slice(0);\n    newChildren.splice(idx, 1, ...others);\n    parent._children = newChildren;\n    (function _fixParent(children, parent) {\n      for (const child of children) {\n        child.parent = parent;\n        _fixParent(child.children, child);\n      }\n    })(others, parent);\n  }\n  get children() {\n    return this._children;\n  }\n  get rightMostDescendant() {\n    if (this._children.length > 0) {\n      return this._children[this._children.length - 1].rightMostDescendant;\n    }\n    return this;\n  }\n  get snippet() {\n    let candidate = this;\n    while (true) {\n      if (!candidate) {\n        return undefined;\n      }\n      if (candidate instanceof TextmateSnippet) {\n        return candidate;\n      }\n      candidate = candidate.parent;\n    }\n  }\n  toString() {\n    return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n  }\n  len() {\n    return 0;\n  }\n}\nexport class Text extends Marker {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return this.value;\n  }\n  len() {\n    return this.value.length;\n  }\n  clone() {\n    return new Text(this.value);\n  }\n}\nexport class TransformableMarker extends Marker {}\nexport class Placeholder extends TransformableMarker {\n  static compareByIndex(a, b) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.isFinalTabstop) {\n      return 1;\n    } else if (b.isFinalTabstop) {\n      return -1;\n    } else if (a.index < b.index) {\n      return -1;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n  get isFinalTabstop() {\n    return this.index === 0;\n  }\n  get choice() {\n    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : undefined;\n  }\n  clone() {\n    const ret = new Placeholder(this.index);\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nexport class Choice extends Marker {\n  constructor() {\n    super(...arguments);\n    this.options = [];\n  }\n  appendChild(marker) {\n    if (marker instanceof Text) {\n      marker.parent = this;\n      this.options.push(marker);\n    }\n    return this;\n  }\n  toString() {\n    return this.options[0].value;\n  }\n  len() {\n    return this.options[0].len();\n  }\n  clone() {\n    const ret = new Choice();\n    this.options.forEach(ret.appendChild, ret);\n    return ret;\n  }\n}\nexport class Transform extends Marker {\n  constructor() {\n    super(...arguments);\n    this.regexp = new RegExp('');\n  }\n  resolve(value) {\n    const _this = this;\n    let didMatch = false;\n    let ret = value.replace(this.regexp, function () {\n      didMatch = true;\n      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n    });\n    // when the regex didn't match and when the transform has\n    // else branches, then run those\n    if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n      ret = this._replace([]);\n    }\n    return ret;\n  }\n  _replace(groups) {\n    let ret = '';\n    for (const marker of this._children) {\n      if (marker instanceof FormatString) {\n        let value = groups[marker.index] || '';\n        value = marker.resolve(value);\n        ret += value;\n      } else {\n        ret += marker.toString();\n      }\n    }\n    return ret;\n  }\n  toString() {\n    return '';\n  }\n  clone() {\n    const ret = new Transform();\n    ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nexport class FormatString extends Marker {\n  constructor(index, shorthandName, ifValue, elseValue) {\n    super();\n    this.index = index;\n    this.shorthandName = shorthandName;\n    this.ifValue = ifValue;\n    this.elseValue = elseValue;\n  }\n  resolve(value) {\n    if (this.shorthandName === 'upcase') {\n      return !value ? '' : value.toLocaleUpperCase();\n    } else if (this.shorthandName === 'downcase') {\n      return !value ? '' : value.toLocaleLowerCase();\n    } else if (this.shorthandName === 'capitalize') {\n      return !value ? '' : value[0].toLocaleUpperCase() + value.substr(1);\n    } else if (this.shorthandName === 'pascalcase') {\n      return !value ? '' : this._toPascalCase(value);\n    } else if (this.shorthandName === 'camelcase') {\n      return !value ? '' : this._toCamelCase(value);\n    } else if (Boolean(value) && typeof this.ifValue === 'string') {\n      return this.ifValue;\n    } else if (!Boolean(value) && typeof this.elseValue === 'string') {\n      return this.elseValue;\n    } else {\n      return value || '';\n    }\n  }\n  _toPascalCase(value) {\n    const match = value.match(/[a-z0-9]+/gi);\n    if (!match) {\n      return value;\n    }\n    return match.map(word => {\n      return word.charAt(0).toUpperCase() + word.substr(1);\n    }).join('');\n  }\n  _toCamelCase(value) {\n    const match = value.match(/[a-z0-9]+/gi);\n    if (!match) {\n      return value;\n    }\n    return match.map((word, index) => {\n      if (index === 0) {\n        return word.charAt(0).toLowerCase() + word.substr(1);\n      }\n      return word.charAt(0).toUpperCase() + word.substr(1);\n    }).join('');\n  }\n  clone() {\n    const ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n    return ret;\n  }\n}\nexport class Variable extends TransformableMarker {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  resolve(resolver) {\n    let value = resolver.resolve(this);\n    if (this.transform) {\n      value = this.transform.resolve(value || '');\n    }\n    if (value !== undefined) {\n      this._children = [new Text(value)];\n      return true;\n    }\n    return false;\n  }\n  clone() {\n    const ret = new Variable(this.name);\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nfunction walk(marker, visitor) {\n  const stack = [...marker];\n  while (stack.length > 0) {\n    const marker = stack.shift();\n    const recurse = visitor(marker);\n    if (!recurse) {\n      break;\n    }\n    stack.unshift(...marker.children);\n  }\n}\nexport class TextmateSnippet extends Marker {\n  get placeholderInfo() {\n    if (!this._placeholders) {\n      // fill in placeholders\n      const all = [];\n      let last;\n      this.walk(function (candidate) {\n        if (candidate instanceof Placeholder) {\n          all.push(candidate);\n          last = !last || last.index < candidate.index ? candidate : last;\n        }\n        return true;\n      });\n      this._placeholders = {\n        all,\n        last\n      };\n    }\n    return this._placeholders;\n  }\n  get placeholders() {\n    const {\n      all\n    } = this.placeholderInfo;\n    return all;\n  }\n  offset(marker) {\n    let pos = 0;\n    let found = false;\n    this.walk(candidate => {\n      if (candidate === marker) {\n        found = true;\n        return false;\n      }\n      pos += candidate.len();\n      return true;\n    });\n    if (!found) {\n      return -1;\n    }\n    return pos;\n  }\n  fullLen(marker) {\n    let ret = 0;\n    walk([marker], marker => {\n      ret += marker.len();\n      return true;\n    });\n    return ret;\n  }\n  enclosingPlaceholders(placeholder) {\n    const ret = [];\n    let {\n      parent\n    } = placeholder;\n    while (parent) {\n      if (parent instanceof Placeholder) {\n        ret.push(parent);\n      }\n      parent = parent.parent;\n    }\n    return ret;\n  }\n  resolveVariables(resolver) {\n    this.walk(candidate => {\n      if (candidate instanceof Variable) {\n        if (candidate.resolve(resolver)) {\n          this._placeholders = undefined;\n        }\n      }\n      return true;\n    });\n    return this;\n  }\n  appendChild(child) {\n    this._placeholders = undefined;\n    return super.appendChild(child);\n  }\n  replace(child, others) {\n    this._placeholders = undefined;\n    return super.replace(child, others);\n  }\n  clone() {\n    const ret = new TextmateSnippet();\n    this._children = this.children.map(child => child.clone());\n    return ret;\n  }\n  walk(visitor) {\n    walk(this.children, visitor);\n  }\n}\nexport class SnippetParser {\n  constructor() {\n    this._scanner = new Scanner();\n    this._token = {\n      type: 14 /* TokenType.EOF */,\n      pos: 0,\n      len: 0\n    };\n  }\n  static escape(value) {\n    return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n  }\n  static guessNeedsClipboard(template) {\n    return /\\${?CLIPBOARD/.test(template);\n  }\n  parse(value, insertFinalTabstop, enforceFinalTabstop) {\n    const snippet = new TextmateSnippet();\n    this.parseFragment(value, snippet);\n    this.ensureFinalTabstop(snippet, enforceFinalTabstop !== null && enforceFinalTabstop !== void 0 ? enforceFinalTabstop : false, insertFinalTabstop !== null && insertFinalTabstop !== void 0 ? insertFinalTabstop : false);\n    return snippet;\n  }\n  parseFragment(value, snippet) {\n    const offset = snippet.children.length;\n    this._scanner.text(value);\n    this._token = this._scanner.next();\n    while (this._parse(snippet)) {\n      // nothing\n    }\n    // fill in values for placeholders. the first placeholder of an index\n    // that has a value defines the value for all placeholders with that index\n    const placeholderDefaultValues = new Map();\n    const incompletePlaceholders = [];\n    snippet.walk(marker => {\n      if (marker instanceof Placeholder) {\n        if (marker.isFinalTabstop) {\n          placeholderDefaultValues.set(0, undefined);\n        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n          placeholderDefaultValues.set(marker.index, marker.children);\n        } else {\n          incompletePlaceholders.push(marker);\n        }\n      }\n      return true;\n    });\n    const fillInIncompletePlaceholder = (placeholder, stack) => {\n      const defaultValues = placeholderDefaultValues.get(placeholder.index);\n      if (!defaultValues) {\n        return;\n      }\n      const clone = new Placeholder(placeholder.index);\n      clone.transform = placeholder.transform;\n      for (const child of defaultValues) {\n        const newChild = child.clone();\n        clone.appendChild(newChild);\n        // \"recurse\" on children that are again placeholders\n        if (newChild instanceof Placeholder && placeholderDefaultValues.has(newChild.index) && !stack.has(newChild.index)) {\n          stack.add(newChild.index);\n          fillInIncompletePlaceholder(newChild, stack);\n          stack.delete(newChild.index);\n        }\n      }\n      snippet.replace(placeholder, [clone]);\n    };\n    const stack = new Set();\n    for (const placeholder of incompletePlaceholders) {\n      fillInIncompletePlaceholder(placeholder, stack);\n    }\n    return snippet.children.slice(offset);\n  }\n  ensureFinalTabstop(snippet, enforceFinalTabstop, insertFinalTabstop) {\n    if (enforceFinalTabstop || insertFinalTabstop && snippet.placeholders.length > 0) {\n      const finalTabstop = snippet.placeholders.find(p => p.index === 0);\n      if (!finalTabstop) {\n        // the snippet uses placeholders but has no\n        // final tabstop defined -> insert at the end\n        snippet.appendChild(new Placeholder(0));\n      }\n    }\n  }\n  _accept(type, value) {\n    if (type === undefined || this._token.type === type) {\n      const ret = !value ? true : this._scanner.tokenText(this._token);\n      this._token = this._scanner.next();\n      return ret;\n    }\n    return false;\n  }\n  _backTo(token) {\n    this._scanner.pos = token.pos + token.len;\n    this._token = token;\n    return false;\n  }\n  _until(type) {\n    const start = this._token;\n    while (this._token.type !== type) {\n      if (this._token.type === 14 /* TokenType.EOF */) {\n        return false;\n      } else if (this._token.type === 5 /* TokenType.Backslash */) {\n        const nextToken = this._scanner.next();\n        if (nextToken.type !== 0 /* TokenType.Dollar */ && nextToken.type !== 4 /* TokenType.CurlyClose */ && nextToken.type !== 5 /* TokenType.Backslash */) {\n          return false;\n        }\n      }\n      this._token = this._scanner.next();\n    }\n    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\n    this._token = this._scanner.next();\n    return value;\n  }\n  _parse(marker) {\n    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);\n  }\n  // \\$, \\\\, \\} -> just text\n  _parseEscaped(marker) {\n    let value;\n    if (value = this._accept(5 /* TokenType.Backslash */, true)) {\n      // saw a backslash, append escaped token or that backslash\n      value = this._accept(0 /* TokenType.Dollar */, true) || this._accept(4 /* TokenType.CurlyClose */, true) || this._accept(5 /* TokenType.Backslash */, true) || value;\n      marker.appendChild(new Text(value));\n      return true;\n    }\n    return false;\n  }\n  // $foo -> variable, $1 -> tabstop\n  _parseTabstopOrVariableName(parent) {\n    let value;\n    const token = this._token;\n    const match = this._accept(0 /* TokenType.Dollar */) && (value = this._accept(9 /* TokenType.VariableName */, true) || this._accept(8 /* TokenType.Int */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    parent.appendChild(/^\\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));\n    return true;\n  }\n  // ${1:<children>}, ${1} -> placeholder\n  _parseComplexPlaceholder(parent) {\n    let index;\n    const token = this._token;\n    const match = this._accept(0 /* TokenType.Dollar */) && this._accept(3 /* TokenType.CurlyOpen */) && (index = this._accept(8 /* TokenType.Int */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    const placeholder = new Placeholder(Number(index));\n    if (this._accept(1 /* TokenType.Colon */)) {\n      // ${1:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4 /* TokenType.CurlyClose */)) {\n          parent.appendChild(placeholder);\n          return true;\n        }\n        if (this._parse(placeholder)) {\n          continue;\n        }\n        // fallback\n        parent.appendChild(new Text('${' + index + ':'));\n        placeholder.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (placeholder.index > 0 && this._accept(7 /* TokenType.Pipe */)) {\n      // ${1|one,two,three|}\n      const choice = new Choice();\n      while (true) {\n        if (this._parseChoiceElement(choice)) {\n          if (this._accept(2 /* TokenType.Comma */)) {\n            // opt, -> more\n            continue;\n          }\n          if (this._accept(7 /* TokenType.Pipe */)) {\n            placeholder.appendChild(choice);\n            if (this._accept(4 /* TokenType.CurlyClose */)) {\n              // ..|} -> done\n              parent.appendChild(placeholder);\n              return true;\n            }\n          }\n        }\n        this._backTo(token);\n        return false;\n      }\n    } else if (this._accept(6 /* TokenType.Forwardslash */)) {\n      // ${1/<regex>/<format>/<options>}\n      if (this._parseTransform(placeholder)) {\n        parent.appendChild(placeholder);\n        return true;\n      }\n      this._backTo(token);\n      return false;\n    } else if (this._accept(4 /* TokenType.CurlyClose */)) {\n      // ${1}\n      parent.appendChild(placeholder);\n      return true;\n    } else {\n      // ${1 <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n  _parseChoiceElement(parent) {\n    const token = this._token;\n    const values = [];\n    while (true) {\n      if (this._token.type === 2 /* TokenType.Comma */ || this._token.type === 7 /* TokenType.Pipe */) {\n        break;\n      }\n      let value;\n      if (value = this._accept(5 /* TokenType.Backslash */, true)) {\n        // \\, \\|, or \\\\\n        value = this._accept(2 /* TokenType.Comma */, true) || this._accept(7 /* TokenType.Pipe */, true) || this._accept(5 /* TokenType.Backslash */, true) || value;\n      } else {\n        value = this._accept(undefined, true);\n      }\n      if (!value) {\n        // EOF\n        this._backTo(token);\n        return false;\n      }\n      values.push(value);\n    }\n    if (values.length === 0) {\n      this._backTo(token);\n      return false;\n    }\n    parent.appendChild(new Text(values.join('')));\n    return true;\n  }\n  // ${foo:<children>}, ${foo} -> variable\n  _parseComplexVariable(parent) {\n    let name;\n    const token = this._token;\n    const match = this._accept(0 /* TokenType.Dollar */) && this._accept(3 /* TokenType.CurlyOpen */) && (name = this._accept(9 /* TokenType.VariableName */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    const variable = new Variable(name);\n    if (this._accept(1 /* TokenType.Colon */)) {\n      // ${foo:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4 /* TokenType.CurlyClose */)) {\n          parent.appendChild(variable);\n          return true;\n        }\n        if (this._parse(variable)) {\n          continue;\n        }\n        // fallback\n        parent.appendChild(new Text('${' + name + ':'));\n        variable.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (this._accept(6 /* TokenType.Forwardslash */)) {\n      // ${foo/<regex>/<format>/<options>}\n      if (this._parseTransform(variable)) {\n        parent.appendChild(variable);\n        return true;\n      }\n      this._backTo(token);\n      return false;\n    } else if (this._accept(4 /* TokenType.CurlyClose */)) {\n      // ${foo}\n      parent.appendChild(variable);\n      return true;\n    } else {\n      // ${foo <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n  _parseTransform(parent) {\n    // ...<regex>/<format>/<options>}\n    const transform = new Transform();\n    let regexValue = '';\n    let regexOptions = '';\n    // (1) /regex\n    while (true) {\n      if (this._accept(6 /* TokenType.Forwardslash */)) {\n        break;\n      }\n      let escaped;\n      if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {\n        escaped = this._accept(6 /* TokenType.Forwardslash */, true) || escaped;\n        regexValue += escaped;\n        continue;\n      }\n      if (this._token.type !== 14 /* TokenType.EOF */) {\n        regexValue += this._accept(undefined, true);\n        continue;\n      }\n      return false;\n    }\n    // (2) /format\n    while (true) {\n      if (this._accept(6 /* TokenType.Forwardslash */)) {\n        break;\n      }\n      let escaped;\n      if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {\n        escaped = this._accept(5 /* TokenType.Backslash */, true) || this._accept(6 /* TokenType.Forwardslash */, true) || escaped;\n        transform.appendChild(new Text(escaped));\n        continue;\n      }\n      if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n        continue;\n      }\n      return false;\n    }\n    // (3) /option\n    while (true) {\n      if (this._accept(4 /* TokenType.CurlyClose */)) {\n        break;\n      }\n      if (this._token.type !== 14 /* TokenType.EOF */) {\n        regexOptions += this._accept(undefined, true);\n        continue;\n      }\n      return false;\n    }\n    try {\n      transform.regexp = new RegExp(regexValue, regexOptions);\n    } catch (e) {\n      // invalid regexp\n      return false;\n    }\n    parent.transform = transform;\n    return true;\n  }\n  _parseFormatString(parent) {\n    const token = this._token;\n    if (!this._accept(0 /* TokenType.Dollar */)) {\n      return false;\n    }\n    let complex = false;\n    if (this._accept(3 /* TokenType.CurlyOpen */)) {\n      complex = true;\n    }\n    const index = this._accept(8 /* TokenType.Int */, true);\n    if (!index) {\n      this._backTo(token);\n      return false;\n    } else if (!complex) {\n      // $1\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (this._accept(4 /* TokenType.CurlyClose */)) {\n      // ${1}\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (!this._accept(1 /* TokenType.Colon */)) {\n      this._backTo(token);\n      return false;\n    }\n    if (this._accept(6 /* TokenType.Forwardslash */)) {\n      // ${1:/upcase}\n      const shorthand = this._accept(9 /* TokenType.VariableName */, true);\n      if (!shorthand || !this._accept(4 /* TokenType.CurlyClose */)) {\n        this._backTo(token);\n        return false;\n      } else {\n        parent.appendChild(new FormatString(Number(index), shorthand));\n        return true;\n      }\n    } else if (this._accept(11 /* TokenType.Plus */)) {\n      // ${1:+<if>}\n      const ifValue = this._until(4 /* TokenType.CurlyClose */);\n      if (ifValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n        return true;\n      }\n    } else if (this._accept(12 /* TokenType.Dash */)) {\n      // ${2:-<else>}\n      const elseValue = this._until(4 /* TokenType.CurlyClose */);\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    } else if (this._accept(13 /* TokenType.QuestionMark */)) {\n      // ${2:?<if>:<else>}\n      const ifValue = this._until(1 /* TokenType.Colon */);\n      if (ifValue) {\n        const elseValue = this._until(4 /* TokenType.CurlyClose */);\n        if (elseValue) {\n          parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n          return true;\n        }\n      }\n    } else {\n      // ${1:<else>}\n      const elseValue = this._until(4 /* TokenType.CurlyClose */);\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    }\n    this._backTo(token);\n    return false;\n  }\n  _parseAnything(marker) {\n    if (this._token.type !== 14 /* TokenType.EOF */) {\n      marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n      this._accept(undefined);\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["Scanner","constructor","value","pos","isDigitCharacter","ch","isVariableCharacter","text","tokenText","token","substr","len","next","length","type","charCodeAt","_table","isNaN","Marker","_children","appendChild","child","Text","parent","push","replace","others","idx","children","indexOf","newChildren","slice","splice","_fixParent","rightMostDescendant","snippet","candidate","undefined","TextmateSnippet","toString","reduce","prev","cur","clone","TransformableMarker","Placeholder","compareByIndex","a","b","index","isFinalTabstop","choice","Choice","ret","transform","map","arguments","options","marker","forEach","Transform","regexp","RegExp","resolve","_this","didMatch","_replace","Array","prototype","call","some","FormatString","Boolean","elseValue","groups","source","ignoreCase","global","shorthandName","ifValue","toLocaleUpperCase","toLocaleLowerCase","_toPascalCase","_toCamelCase","match","word","charAt","toUpperCase","join","toLowerCase","Variable","name","resolver","walk","visitor","stack","shift","recurse","unshift","placeholderInfo","_placeholders","all","last","placeholders","offset","found","fullLen","enclosingPlaceholders","placeholder","resolveVariables","SnippetParser","_scanner","_token","escape","guessNeedsClipboard","template","test","parse","insertFinalTabstop","enforceFinalTabstop","parseFragment","ensureFinalTabstop","_parse","placeholderDefaultValues","Map","incompletePlaceholders","set","has","fillInIncompletePlaceholder","defaultValues","get","newChild","add","delete","Set","finalTabstop","find","p","_accept","_backTo","_until","start","nextToken","substring","_parseEscaped","_parseTabstopOrVariableName","_parseComplexPlaceholder","_parseComplexVariable","_parseAnything","Number","_parseChoiceElement","_parseTransform","values","variable","regexValue","regexOptions","escaped","_parseFormatString","e","complex","shorthand"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Scanner {\n    constructor() {\n        this.value = '';\n        this.pos = 0;\n    }\n    static isDigitCharacter(ch) {\n        return ch >= 48 /* CharCode.Digit0 */ && ch <= 57 /* CharCode.Digit9 */;\n    }\n    static isVariableCharacter(ch) {\n        return ch === 95 /* CharCode.Underline */\n            || (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */)\n            || (ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */);\n    }\n    text(value) {\n        this.value = value;\n        this.pos = 0;\n    }\n    tokenText(token) {\n        return this.value.substr(token.pos, token.len);\n    }\n    next() {\n        if (this.pos >= this.value.length) {\n            return { type: 14 /* TokenType.EOF */, pos: this.pos, len: 0 };\n        }\n        const pos = this.pos;\n        let len = 0;\n        let ch = this.value.charCodeAt(pos);\n        let type;\n        // static types\n        type = Scanner._table[ch];\n        if (typeof type === 'number') {\n            this.pos += 1;\n            return { type, pos, len: 1 };\n        }\n        // number\n        if (Scanner.isDigitCharacter(ch)) {\n            type = 8 /* TokenType.Int */;\n            do {\n                len += 1;\n                ch = this.value.charCodeAt(pos + len);\n            } while (Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // variable name\n        if (Scanner.isVariableCharacter(ch)) {\n            type = 9 /* TokenType.VariableName */;\n            do {\n                ch = this.value.charCodeAt(pos + (++len));\n            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // format\n        type = 10 /* TokenType.Format */;\n        do {\n            len += 1;\n            ch = this.value.charCodeAt(pos + len);\n        } while (!isNaN(ch)\n            && typeof Scanner._table[ch] === 'undefined' // not static token\n            && !Scanner.isDigitCharacter(ch) // not number\n            && !Scanner.isVariableCharacter(ch) // not variable\n        );\n        this.pos += len;\n        return { type, pos, len };\n    }\n}\nScanner._table = {\n    [36 /* CharCode.DollarSign */]: 0 /* TokenType.Dollar */,\n    [58 /* CharCode.Colon */]: 1 /* TokenType.Colon */,\n    [44 /* CharCode.Comma */]: 2 /* TokenType.Comma */,\n    [123 /* CharCode.OpenCurlyBrace */]: 3 /* TokenType.CurlyOpen */,\n    [125 /* CharCode.CloseCurlyBrace */]: 4 /* TokenType.CurlyClose */,\n    [92 /* CharCode.Backslash */]: 5 /* TokenType.Backslash */,\n    [47 /* CharCode.Slash */]: 6 /* TokenType.Forwardslash */,\n    [124 /* CharCode.Pipe */]: 7 /* TokenType.Pipe */,\n    [43 /* CharCode.Plus */]: 11 /* TokenType.Plus */,\n    [45 /* CharCode.Dash */]: 12 /* TokenType.Dash */,\n    [63 /* CharCode.QuestionMark */]: 13 /* TokenType.QuestionMark */,\n};\nexport class Marker {\n    constructor() {\n        this._children = [];\n    }\n    appendChild(child) {\n        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n            // this and previous child are text -> merge them\n            this._children[this._children.length - 1].value += child.value;\n        }\n        else {\n            // normal adoption of child\n            child.parent = this;\n            this._children.push(child);\n        }\n        return this;\n    }\n    replace(child, others) {\n        const { parent } = child;\n        const idx = parent.children.indexOf(child);\n        const newChildren = parent.children.slice(0);\n        newChildren.splice(idx, 1, ...others);\n        parent._children = newChildren;\n        (function _fixParent(children, parent) {\n            for (const child of children) {\n                child.parent = parent;\n                _fixParent(child.children, child);\n            }\n        })(others, parent);\n    }\n    get children() {\n        return this._children;\n    }\n    get rightMostDescendant() {\n        if (this._children.length > 0) {\n            return this._children[this._children.length - 1].rightMostDescendant;\n        }\n        return this;\n    }\n    get snippet() {\n        let candidate = this;\n        while (true) {\n            if (!candidate) {\n                return undefined;\n            }\n            if (candidate instanceof TextmateSnippet) {\n                return candidate;\n            }\n            candidate = candidate.parent;\n        }\n    }\n    toString() {\n        return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n    }\n    len() {\n        return 0;\n    }\n}\nexport class Text extends Marker {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    len() {\n        return this.value.length;\n    }\n    clone() {\n        return new Text(this.value);\n    }\n}\nexport class TransformableMarker extends Marker {\n}\nexport class Placeholder extends TransformableMarker {\n    static compareByIndex(a, b) {\n        if (a.index === b.index) {\n            return 0;\n        }\n        else if (a.isFinalTabstop) {\n            return 1;\n        }\n        else if (b.isFinalTabstop) {\n            return -1;\n        }\n        else if (a.index < b.index) {\n            return -1;\n        }\n        else if (a.index > b.index) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    constructor(index) {\n        super();\n        this.index = index;\n    }\n    get isFinalTabstop() {\n        return this.index === 0;\n    }\n    get choice() {\n        return this._children.length === 1 && this._children[0] instanceof Choice\n            ? this._children[0]\n            : undefined;\n    }\n    clone() {\n        const ret = new Placeholder(this.index);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexport class Choice extends Marker {\n    constructor() {\n        super(...arguments);\n        this.options = [];\n    }\n    appendChild(marker) {\n        if (marker instanceof Text) {\n            marker.parent = this;\n            this.options.push(marker);\n        }\n        return this;\n    }\n    toString() {\n        return this.options[0].value;\n    }\n    len() {\n        return this.options[0].len();\n    }\n    clone() {\n        const ret = new Choice();\n        this.options.forEach(ret.appendChild, ret);\n        return ret;\n    }\n}\nexport class Transform extends Marker {\n    constructor() {\n        super(...arguments);\n        this.regexp = new RegExp('');\n    }\n    resolve(value) {\n        const _this = this;\n        let didMatch = false;\n        let ret = value.replace(this.regexp, function () {\n            didMatch = true;\n            return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n        });\n        // when the regex didn't match and when the transform has\n        // else branches, then run those\n        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n            ret = this._replace([]);\n        }\n        return ret;\n    }\n    _replace(groups) {\n        let ret = '';\n        for (const marker of this._children) {\n            if (marker instanceof FormatString) {\n                let value = groups[marker.index] || '';\n                value = marker.resolve(value);\n                ret += value;\n            }\n            else {\n                ret += marker.toString();\n            }\n        }\n        return ret;\n    }\n    toString() {\n        return '';\n    }\n    clone() {\n        const ret = new Transform();\n        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexport class FormatString extends Marker {\n    constructor(index, shorthandName, ifValue, elseValue) {\n        super();\n        this.index = index;\n        this.shorthandName = shorthandName;\n        this.ifValue = ifValue;\n        this.elseValue = elseValue;\n    }\n    resolve(value) {\n        if (this.shorthandName === 'upcase') {\n            return !value ? '' : value.toLocaleUpperCase();\n        }\n        else if (this.shorthandName === 'downcase') {\n            return !value ? '' : value.toLocaleLowerCase();\n        }\n        else if (this.shorthandName === 'capitalize') {\n            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));\n        }\n        else if (this.shorthandName === 'pascalcase') {\n            return !value ? '' : this._toPascalCase(value);\n        }\n        else if (this.shorthandName === 'camelcase') {\n            return !value ? '' : this._toCamelCase(value);\n        }\n        else if (Boolean(value) && typeof this.ifValue === 'string') {\n            return this.ifValue;\n        }\n        else if (!Boolean(value) && typeof this.elseValue === 'string') {\n            return this.elseValue;\n        }\n        else {\n            return value || '';\n        }\n    }\n    _toPascalCase(value) {\n        const match = value.match(/[a-z0-9]+/gi);\n        if (!match) {\n            return value;\n        }\n        return match.map(word => {\n            return word.charAt(0).toUpperCase() + word.substr(1);\n        })\n            .join('');\n    }\n    _toCamelCase(value) {\n        const match = value.match(/[a-z0-9]+/gi);\n        if (!match) {\n            return value;\n        }\n        return match.map((word, index) => {\n            if (index === 0) {\n                return word.charAt(0).toLowerCase() + word.substr(1);\n            }\n            return word.charAt(0).toUpperCase() + word.substr(1);\n        })\n            .join('');\n    }\n    clone() {\n        const ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n        return ret;\n    }\n}\nexport class Variable extends TransformableMarker {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    resolve(resolver) {\n        let value = resolver.resolve(this);\n        if (this.transform) {\n            value = this.transform.resolve(value || '');\n        }\n        if (value !== undefined) {\n            this._children = [new Text(value)];\n            return true;\n        }\n        return false;\n    }\n    clone() {\n        const ret = new Variable(this.name);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nfunction walk(marker, visitor) {\n    const stack = [...marker];\n    while (stack.length > 0) {\n        const marker = stack.shift();\n        const recurse = visitor(marker);\n        if (!recurse) {\n            break;\n        }\n        stack.unshift(...marker.children);\n    }\n}\nexport class TextmateSnippet extends Marker {\n    get placeholderInfo() {\n        if (!this._placeholders) {\n            // fill in placeholders\n            const all = [];\n            let last;\n            this.walk(function (candidate) {\n                if (candidate instanceof Placeholder) {\n                    all.push(candidate);\n                    last = !last || last.index < candidate.index ? candidate : last;\n                }\n                return true;\n            });\n            this._placeholders = { all, last };\n        }\n        return this._placeholders;\n    }\n    get placeholders() {\n        const { all } = this.placeholderInfo;\n        return all;\n    }\n    offset(marker) {\n        let pos = 0;\n        let found = false;\n        this.walk(candidate => {\n            if (candidate === marker) {\n                found = true;\n                return false;\n            }\n            pos += candidate.len();\n            return true;\n        });\n        if (!found) {\n            return -1;\n        }\n        return pos;\n    }\n    fullLen(marker) {\n        let ret = 0;\n        walk([marker], marker => {\n            ret += marker.len();\n            return true;\n        });\n        return ret;\n    }\n    enclosingPlaceholders(placeholder) {\n        const ret = [];\n        let { parent } = placeholder;\n        while (parent) {\n            if (parent instanceof Placeholder) {\n                ret.push(parent);\n            }\n            parent = parent.parent;\n        }\n        return ret;\n    }\n    resolveVariables(resolver) {\n        this.walk(candidate => {\n            if (candidate instanceof Variable) {\n                if (candidate.resolve(resolver)) {\n                    this._placeholders = undefined;\n                }\n            }\n            return true;\n        });\n        return this;\n    }\n    appendChild(child) {\n        this._placeholders = undefined;\n        return super.appendChild(child);\n    }\n    replace(child, others) {\n        this._placeholders = undefined;\n        return super.replace(child, others);\n    }\n    clone() {\n        const ret = new TextmateSnippet();\n        this._children = this.children.map(child => child.clone());\n        return ret;\n    }\n    walk(visitor) {\n        walk(this.children, visitor);\n    }\n}\nexport class SnippetParser {\n    constructor() {\n        this._scanner = new Scanner();\n        this._token = { type: 14 /* TokenType.EOF */, pos: 0, len: 0 };\n    }\n    static escape(value) {\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n    }\n    static guessNeedsClipboard(template) {\n        return /\\${?CLIPBOARD/.test(template);\n    }\n    parse(value, insertFinalTabstop, enforceFinalTabstop) {\n        const snippet = new TextmateSnippet();\n        this.parseFragment(value, snippet);\n        this.ensureFinalTabstop(snippet, enforceFinalTabstop !== null && enforceFinalTabstop !== void 0 ? enforceFinalTabstop : false, insertFinalTabstop !== null && insertFinalTabstop !== void 0 ? insertFinalTabstop : false);\n        return snippet;\n    }\n    parseFragment(value, snippet) {\n        const offset = snippet.children.length;\n        this._scanner.text(value);\n        this._token = this._scanner.next();\n        while (this._parse(snippet)) {\n            // nothing\n        }\n        // fill in values for placeholders. the first placeholder of an index\n        // that has a value defines the value for all placeholders with that index\n        const placeholderDefaultValues = new Map();\n        const incompletePlaceholders = [];\n        snippet.walk(marker => {\n            if (marker instanceof Placeholder) {\n                if (marker.isFinalTabstop) {\n                    placeholderDefaultValues.set(0, undefined);\n                }\n                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n                    placeholderDefaultValues.set(marker.index, marker.children);\n                }\n                else {\n                    incompletePlaceholders.push(marker);\n                }\n            }\n            return true;\n        });\n        const fillInIncompletePlaceholder = (placeholder, stack) => {\n            const defaultValues = placeholderDefaultValues.get(placeholder.index);\n            if (!defaultValues) {\n                return;\n            }\n            const clone = new Placeholder(placeholder.index);\n            clone.transform = placeholder.transform;\n            for (const child of defaultValues) {\n                const newChild = child.clone();\n                clone.appendChild(newChild);\n                // \"recurse\" on children that are again placeholders\n                if (newChild instanceof Placeholder && placeholderDefaultValues.has(newChild.index) && !stack.has(newChild.index)) {\n                    stack.add(newChild.index);\n                    fillInIncompletePlaceholder(newChild, stack);\n                    stack.delete(newChild.index);\n                }\n            }\n            snippet.replace(placeholder, [clone]);\n        };\n        const stack = new Set();\n        for (const placeholder of incompletePlaceholders) {\n            fillInIncompletePlaceholder(placeholder, stack);\n        }\n        return snippet.children.slice(offset);\n    }\n    ensureFinalTabstop(snippet, enforceFinalTabstop, insertFinalTabstop) {\n        if (enforceFinalTabstop || insertFinalTabstop && snippet.placeholders.length > 0) {\n            const finalTabstop = snippet.placeholders.find(p => p.index === 0);\n            if (!finalTabstop) {\n                // the snippet uses placeholders but has no\n                // final tabstop defined -> insert at the end\n                snippet.appendChild(new Placeholder(0));\n            }\n        }\n    }\n    _accept(type, value) {\n        if (type === undefined || this._token.type === type) {\n            const ret = !value ? true : this._scanner.tokenText(this._token);\n            this._token = this._scanner.next();\n            return ret;\n        }\n        return false;\n    }\n    _backTo(token) {\n        this._scanner.pos = token.pos + token.len;\n        this._token = token;\n        return false;\n    }\n    _until(type) {\n        const start = this._token;\n        while (this._token.type !== type) {\n            if (this._token.type === 14 /* TokenType.EOF */) {\n                return false;\n            }\n            else if (this._token.type === 5 /* TokenType.Backslash */) {\n                const nextToken = this._scanner.next();\n                if (nextToken.type !== 0 /* TokenType.Dollar */\n                    && nextToken.type !== 4 /* TokenType.CurlyClose */\n                    && nextToken.type !== 5 /* TokenType.Backslash */) {\n                    return false;\n                }\n            }\n            this._token = this._scanner.next();\n        }\n        const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\n        this._token = this._scanner.next();\n        return value;\n    }\n    _parse(marker) {\n        return this._parseEscaped(marker)\n            || this._parseTabstopOrVariableName(marker)\n            || this._parseComplexPlaceholder(marker)\n            || this._parseComplexVariable(marker)\n            || this._parseAnything(marker);\n    }\n    // \\$, \\\\, \\} -> just text\n    _parseEscaped(marker) {\n        let value;\n        if (value = this._accept(5 /* TokenType.Backslash */, true)) {\n            // saw a backslash, append escaped token or that backslash\n            value = this._accept(0 /* TokenType.Dollar */, true)\n                || this._accept(4 /* TokenType.CurlyClose */, true)\n                || this._accept(5 /* TokenType.Backslash */, true)\n                || value;\n            marker.appendChild(new Text(value));\n            return true;\n        }\n        return false;\n    }\n    // $foo -> variable, $1 -> tabstop\n    _parseTabstopOrVariableName(parent) {\n        let value;\n        const token = this._token;\n        const match = this._accept(0 /* TokenType.Dollar */)\n            && (value = this._accept(9 /* TokenType.VariableName */, true) || this._accept(8 /* TokenType.Int */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        parent.appendChild(/^\\d+$/.test(value)\n            ? new Placeholder(Number(value))\n            : new Variable(value));\n        return true;\n    }\n    // ${1:<children>}, ${1} -> placeholder\n    _parseComplexPlaceholder(parent) {\n        let index;\n        const token = this._token;\n        const match = this._accept(0 /* TokenType.Dollar */)\n            && this._accept(3 /* TokenType.CurlyOpen */)\n            && (index = this._accept(8 /* TokenType.Int */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const placeholder = new Placeholder(Number(index));\n        if (this._accept(1 /* TokenType.Colon */)) {\n            // ${1:<children>}\n            while (true) {\n                // ...} -> done\n                if (this._accept(4 /* TokenType.CurlyClose */)) {\n                    parent.appendChild(placeholder);\n                    return true;\n                }\n                if (this._parse(placeholder)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + index + ':'));\n                placeholder.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (placeholder.index > 0 && this._accept(7 /* TokenType.Pipe */)) {\n            // ${1|one,two,three|}\n            const choice = new Choice();\n            while (true) {\n                if (this._parseChoiceElement(choice)) {\n                    if (this._accept(2 /* TokenType.Comma */)) {\n                        // opt, -> more\n                        continue;\n                    }\n                    if (this._accept(7 /* TokenType.Pipe */)) {\n                        placeholder.appendChild(choice);\n                        if (this._accept(4 /* TokenType.CurlyClose */)) {\n                            // ..|} -> done\n                            parent.appendChild(placeholder);\n                            return true;\n                        }\n                    }\n                }\n                this._backTo(token);\n                return false;\n            }\n        }\n        else if (this._accept(6 /* TokenType.Forwardslash */)) {\n            // ${1/<regex>/<format>/<options>}\n            if (this._parseTransform(placeholder)) {\n                parent.appendChild(placeholder);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(4 /* TokenType.CurlyClose */)) {\n            // ${1}\n            parent.appendChild(placeholder);\n            return true;\n        }\n        else {\n            // ${1 <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseChoiceElement(parent) {\n        const token = this._token;\n        const values = [];\n        while (true) {\n            if (this._token.type === 2 /* TokenType.Comma */ || this._token.type === 7 /* TokenType.Pipe */) {\n                break;\n            }\n            let value;\n            if (value = this._accept(5 /* TokenType.Backslash */, true)) {\n                // \\, \\|, or \\\\\n                value = this._accept(2 /* TokenType.Comma */, true)\n                    || this._accept(7 /* TokenType.Pipe */, true)\n                    || this._accept(5 /* TokenType.Backslash */, true)\n                    || value;\n            }\n            else {\n                value = this._accept(undefined, true);\n            }\n            if (!value) {\n                // EOF\n                this._backTo(token);\n                return false;\n            }\n            values.push(value);\n        }\n        if (values.length === 0) {\n            this._backTo(token);\n            return false;\n        }\n        parent.appendChild(new Text(values.join('')));\n        return true;\n    }\n    // ${foo:<children>}, ${foo} -> variable\n    _parseComplexVariable(parent) {\n        let name;\n        const token = this._token;\n        const match = this._accept(0 /* TokenType.Dollar */)\n            && this._accept(3 /* TokenType.CurlyOpen */)\n            && (name = this._accept(9 /* TokenType.VariableName */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const variable = new Variable(name);\n        if (this._accept(1 /* TokenType.Colon */)) {\n            // ${foo:<children>}\n            while (true) {\n                // ...} -> done\n                if (this._accept(4 /* TokenType.CurlyClose */)) {\n                    parent.appendChild(variable);\n                    return true;\n                }\n                if (this._parse(variable)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + name + ':'));\n                variable.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (this._accept(6 /* TokenType.Forwardslash */)) {\n            // ${foo/<regex>/<format>/<options>}\n            if (this._parseTransform(variable)) {\n                parent.appendChild(variable);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(4 /* TokenType.CurlyClose */)) {\n            // ${foo}\n            parent.appendChild(variable);\n            return true;\n        }\n        else {\n            // ${foo <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseTransform(parent) {\n        // ...<regex>/<format>/<options>}\n        const transform = new Transform();\n        let regexValue = '';\n        let regexOptions = '';\n        // (1) /regex\n        while (true) {\n            if (this._accept(6 /* TokenType.Forwardslash */)) {\n                break;\n            }\n            let escaped;\n            if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {\n                escaped = this._accept(6 /* TokenType.Forwardslash */, true) || escaped;\n                regexValue += escaped;\n                continue;\n            }\n            if (this._token.type !== 14 /* TokenType.EOF */) {\n                regexValue += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        // (2) /format\n        while (true) {\n            if (this._accept(6 /* TokenType.Forwardslash */)) {\n                break;\n            }\n            let escaped;\n            if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {\n                escaped = this._accept(5 /* TokenType.Backslash */, true) || this._accept(6 /* TokenType.Forwardslash */, true) || escaped;\n                transform.appendChild(new Text(escaped));\n                continue;\n            }\n            if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n                continue;\n            }\n            return false;\n        }\n        // (3) /option\n        while (true) {\n            if (this._accept(4 /* TokenType.CurlyClose */)) {\n                break;\n            }\n            if (this._token.type !== 14 /* TokenType.EOF */) {\n                regexOptions += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        try {\n            transform.regexp = new RegExp(regexValue, regexOptions);\n        }\n        catch (e) {\n            // invalid regexp\n            return false;\n        }\n        parent.transform = transform;\n        return true;\n    }\n    _parseFormatString(parent) {\n        const token = this._token;\n        if (!this._accept(0 /* TokenType.Dollar */)) {\n            return false;\n        }\n        let complex = false;\n        if (this._accept(3 /* TokenType.CurlyOpen */)) {\n            complex = true;\n        }\n        const index = this._accept(8 /* TokenType.Int */, true);\n        if (!index) {\n            this._backTo(token);\n            return false;\n        }\n        else if (!complex) {\n            // $1\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (this._accept(4 /* TokenType.CurlyClose */)) {\n            // ${1}\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (!this._accept(1 /* TokenType.Colon */)) {\n            this._backTo(token);\n            return false;\n        }\n        if (this._accept(6 /* TokenType.Forwardslash */)) {\n            // ${1:/upcase}\n            const shorthand = this._accept(9 /* TokenType.VariableName */, true);\n            if (!shorthand || !this._accept(4 /* TokenType.CurlyClose */)) {\n                this._backTo(token);\n                return false;\n            }\n            else {\n                parent.appendChild(new FormatString(Number(index), shorthand));\n                return true;\n            }\n        }\n        else if (this._accept(11 /* TokenType.Plus */)) {\n            // ${1:+<if>}\n            const ifValue = this._until(4 /* TokenType.CurlyClose */);\n            if (ifValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n                return true;\n            }\n        }\n        else if (this._accept(12 /* TokenType.Dash */)) {\n            // ${2:-<else>}\n            const elseValue = this._until(4 /* TokenType.CurlyClose */);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        else if (this._accept(13 /* TokenType.QuestionMark */)) {\n            // ${2:?<if>:<else>}\n            const ifValue = this._until(1 /* TokenType.Colon */);\n            if (ifValue) {\n                const elseValue = this._until(4 /* TokenType.CurlyClose */);\n                if (elseValue) {\n                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n                    return true;\n                }\n            }\n        }\n        else {\n            // ${1:<else>}\n            const elseValue = this._until(4 /* TokenType.CurlyClose */);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        this._backTo(token);\n        return false;\n    }\n    _parseAnything(marker) {\n        if (this._token.type !== 14 /* TokenType.EOF */) {\n            marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n            this._accept(undefined);\n            return true;\n        }\n        return false;\n    }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA,OAAO,MAAMA,OAAO,CAAC;EACjBC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,GAAG,GAAG,CAAC;EAChB;EACA,OAAOC,gBAAgBA,CAACC,EAAE,EAAE;IACxB,OAAOA,EAAE,IAAI,EAAE,CAAC,yBAAyBA,EAAE,IAAI,EAAE,CAAC;EACtD;EACA,OAAOC,mBAAmBA,CAACD,EAAE,EAAE;IAC3B,OAAOA,EAAE,KAAK,EAAE,CAAC,4BACTA,EAAE,IAAI,EAAE,CAAC,oBAAoBA,EAAE,IAAI,GAAG,CAAC,gBAAiB,IACxDA,EAAE,IAAI,EAAE,CAAC,oBAAoBA,EAAE,IAAI,EAAE,CAAC,gBAAiB;EACnE;EACAE,IAAIA,CAACL,KAAK,EAAE;IACR,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAG,CAAC;EAChB;EACAK,SAASA,CAACC,KAAK,EAAE;IACb,OAAO,IAAI,CAACP,KAAK,CAACQ,MAAM,CAACD,KAAK,CAACN,GAAG,EAAEM,KAAK,CAACE,GAAG,CAAC;EAClD;EACAC,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACT,GAAG,IAAI,IAAI,CAACD,KAAK,CAACW,MAAM,EAAE;MAC/B,OAAO;QAAEC,IAAI,EAAE,EAAE,CAAC;QAAqBX,GAAG,EAAE,IAAI,CAACA,GAAG;QAAEQ,GAAG,EAAE;MAAE,CAAC;IAClE;IACA,MAAMR,GAAG,GAAG,IAAI,CAACA,GAAG;IACpB,IAAIQ,GAAG,GAAG,CAAC;IACX,IAAIN,EAAE,GAAG,IAAI,CAACH,KAAK,CAACa,UAAU,CAACZ,GAAG,CAAC;IACnC,IAAIW,IAAI;IACR;IACAA,IAAI,GAAGd,OAAO,CAACgB,MAAM,CAACX,EAAE,CAAC;IACzB,IAAI,OAAOS,IAAI,KAAK,QAAQ,EAAE;MAC1B,IAAI,CAACX,GAAG,IAAI,CAAC;MACb,OAAO;QAAEW,IAAI;QAAEX,GAAG;QAAEQ,GAAG,EAAE;MAAE,CAAC;IAChC;IACA;IACA,IAAIX,OAAO,CAACI,gBAAgB,CAACC,EAAE,CAAC,EAAE;MAC9BS,IAAI,GAAG,CAAC,CAAC;MACT,GAAG;QACCH,GAAG,IAAI,CAAC;QACRN,EAAE,GAAG,IAAI,CAACH,KAAK,CAACa,UAAU,CAACZ,GAAG,GAAGQ,GAAG,CAAC;MACzC,CAAC,QAAQX,OAAO,CAACI,gBAAgB,CAACC,EAAE,CAAC;MACrC,IAAI,CAACF,GAAG,IAAIQ,GAAG;MACf,OAAO;QAAEG,IAAI;QAAEX,GAAG;QAAEQ;MAAI,CAAC;IAC7B;IACA;IACA,IAAIX,OAAO,CAACM,mBAAmB,CAACD,EAAE,CAAC,EAAE;MACjCS,IAAI,GAAG,CAAC,CAAC;MACT,GAAG;QACCT,EAAE,GAAG,IAAI,CAACH,KAAK,CAACa,UAAU,CAACZ,GAAG,GAAI,EAAEQ,GAAI,CAAC;MAC7C,CAAC,QAAQX,OAAO,CAACM,mBAAmB,CAACD,EAAE,CAAC,IAAIL,OAAO,CAACI,gBAAgB,CAACC,EAAE,CAAC;MACxE,IAAI,CAACF,GAAG,IAAIQ,GAAG;MACf,OAAO;QAAEG,IAAI;QAAEX,GAAG;QAAEQ;MAAI,CAAC;IAC7B;IACA;IACAG,IAAI,GAAG,EAAE,CAAC;IACV,GAAG;MACCH,GAAG,IAAI,CAAC;MACRN,EAAE,GAAG,IAAI,CAACH,KAAK,CAACa,UAAU,CAACZ,GAAG,GAAGQ,GAAG,CAAC;IACzC,CAAC,QAAQ,CAACM,KAAK,CAACZ,EAAE,CAAC,IACZ,OAAOL,OAAO,CAACgB,MAAM,CAACX,EAAE,CAAC,KAAK,WAAW,CAAC;IAAA,GAC1C,CAACL,OAAO,CAACI,gBAAgB,CAACC,EAAE,CAAC,CAAC;IAAA,GAC9B,CAACL,OAAO,CAACM,mBAAmB,CAACD,EAAE,CAAC,CAAC;IAAA;IAExC,IAAI,CAACF,GAAG,IAAIQ,GAAG;IACf,OAAO;MAAEG,IAAI;MAAEX,GAAG;MAAEQ;IAAI,CAAC;EAC7B;AACJ;AACAX,OAAO,CAACgB,MAAM,GAAG;EACb,CAAC,EAAE,CAAC,4BAA4B,CAAC,CAAC;EAClC,CAAC,EAAE,CAAC,uBAAuB,CAAC,CAAC;EAC7B,CAAC,EAAE,CAAC,uBAAuB,CAAC,CAAC;EAC7B,CAAC,GAAG,CAAC,gCAAgC,CAAC,CAAC;EACvC,CAAC,GAAG,CAAC,iCAAiC,CAAC,CAAC;EACxC,CAAC,EAAE,CAAC,2BAA2B,CAAC,CAAC;EACjC,CAAC,EAAE,CAAC,uBAAuB,CAAC,CAAC;EAC7B,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;EAC7B,CAAC,EAAE,CAAC,sBAAsB,EAAE,CAAC;EAC7B,CAAC,EAAE,CAAC,sBAAsB,EAAE,CAAC;EAC7B,CAAC,EAAE,CAAC,8BAA8B,EAAE,CAAC;AACzC,CAAC;AACD,OAAO,MAAME,MAAM,CAAC;EAChBjB,WAAWA,CAAA,EAAG;IACV,IAAI,CAACkB,SAAS,GAAG,EAAE;EACvB;EACAC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAIA,KAAK,YAAYC,IAAI,IAAI,IAAI,CAACH,SAAS,CAAC,IAAI,CAACA,SAAS,CAACN,MAAM,GAAG,CAAC,CAAC,YAAYS,IAAI,EAAE;MACpF;MACA,IAAI,CAACH,SAAS,CAAC,IAAI,CAACA,SAAS,CAACN,MAAM,GAAG,CAAC,CAAC,CAACX,KAAK,IAAImB,KAAK,CAACnB,KAAK;IAClE,CAAC,MACI;MACD;MACAmB,KAAK,CAACE,MAAM,GAAG,IAAI;MACnB,IAAI,CAACJ,SAAS,CAACK,IAAI,CAACH,KAAK,CAAC;IAC9B;IACA,OAAO,IAAI;EACf;EACAI,OAAOA,CAACJ,KAAK,EAAEK,MAAM,EAAE;IACnB,MAAM;MAAEH;IAAO,CAAC,GAAGF,KAAK;IACxB,MAAMM,GAAG,GAAGJ,MAAM,CAACK,QAAQ,CAACC,OAAO,CAACR,KAAK,CAAC;IAC1C,MAAMS,WAAW,GAAGP,MAAM,CAACK,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC;IAC5CD,WAAW,CAACE,MAAM,CAACL,GAAG,EAAE,CAAC,EAAE,GAAGD,MAAM,CAAC;IACrCH,MAAM,CAACJ,SAAS,GAAGW,WAAW;IAC9B,CAAC,SAASG,UAAUA,CAACL,QAAQ,EAAEL,MAAM,EAAE;MACnC,KAAK,MAAMF,KAAK,IAAIO,QAAQ,EAAE;QAC1BP,KAAK,CAACE,MAAM,GAAGA,MAAM;QACrBU,UAAU,CAACZ,KAAK,CAACO,QAAQ,EAAEP,KAAK,CAAC;MACrC;IACJ,CAAC,EAAEK,MAAM,EAAEH,MAAM,CAAC;EACtB;EACA,IAAIK,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAACT,SAAS;EACzB;EACA,IAAIe,mBAAmBA,CAAA,EAAG;IACtB,IAAI,IAAI,CAACf,SAAS,CAACN,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAO,IAAI,CAACM,SAAS,CAAC,IAAI,CAACA,SAAS,CAACN,MAAM,GAAG,CAAC,CAAC,CAACqB,mBAAmB;IACxE;IACA,OAAO,IAAI;EACf;EACA,IAAIC,OAAOA,CAAA,EAAG;IACV,IAAIC,SAAS,GAAG,IAAI;IACpB,OAAO,IAAI,EAAE;MACT,IAAI,CAACA,SAAS,EAAE;QACZ,OAAOC,SAAS;MACpB;MACA,IAAID,SAAS,YAAYE,eAAe,EAAE;QACtC,OAAOF,SAAS;MACpB;MACAA,SAAS,GAAGA,SAAS,CAACb,MAAM;IAChC;EACJ;EACAgB,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACX,QAAQ,CAACY,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,KAAKD,IAAI,GAAGC,GAAG,CAACH,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;EACzE;EACA5B,GAAGA,CAAA,EAAG;IACF,OAAO,CAAC;EACZ;AACJ;AACA,OAAO,MAAMW,IAAI,SAASJ,MAAM,CAAC;EAC7BjB,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EACAqC,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACrC,KAAK;EACrB;EACAS,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACT,KAAK,CAACW,MAAM;EAC5B;EACA8B,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAIrB,IAAI,CAAC,IAAI,CAACpB,KAAK,CAAC;EAC/B;AACJ;AACA,OAAO,MAAM0C,mBAAmB,SAAS1B,MAAM,CAAC;AAEhD,OAAO,MAAM2B,WAAW,SAASD,mBAAmB,CAAC;EACjD,OAAOE,cAAcA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACxB,IAAID,CAAC,CAACE,KAAK,KAAKD,CAAC,CAACC,KAAK,EAAE;MACrB,OAAO,CAAC;IACZ,CAAC,MACI,IAAIF,CAAC,CAACG,cAAc,EAAE;MACvB,OAAO,CAAC;IACZ,CAAC,MACI,IAAIF,CAAC,CAACE,cAAc,EAAE;MACvB,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIH,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK,EAAE;MACxB,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIF,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK,EAAE;MACxB,OAAO,CAAC;IACZ,CAAC,MACI;MACD,OAAO,CAAC;IACZ;EACJ;EACAhD,WAAWA,CAACgD,KAAK,EAAE;IACf,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EACA,IAAIC,cAAcA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACD,KAAK,KAAK,CAAC;EAC3B;EACA,IAAIE,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAAChC,SAAS,CAACN,MAAM,KAAK,CAAC,IAAI,IAAI,CAACM,SAAS,CAAC,CAAC,CAAC,YAAYiC,MAAM,GACnE,IAAI,CAACjC,SAAS,CAAC,CAAC,CAAC,GACjBkB,SAAS;EACnB;EACAM,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAIR,WAAW,CAAC,IAAI,CAACI,KAAK,CAAC;IACvC,IAAI,IAAI,CAACK,SAAS,EAAE;MAChBD,GAAG,CAACC,SAAS,GAAG,IAAI,CAACA,SAAS,CAACX,KAAK,CAAC,CAAC;IAC1C;IACAU,GAAG,CAAClC,SAAS,GAAG,IAAI,CAACS,QAAQ,CAAC2B,GAAG,CAAClC,KAAK,IAAIA,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC;IACzD,OAAOU,GAAG;EACd;AACJ;AACA,OAAO,MAAMD,MAAM,SAASlC,MAAM,CAAC;EAC/BjB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGuD,SAAS,CAAC;IACnB,IAAI,CAACC,OAAO,GAAG,EAAE;EACrB;EACArC,WAAWA,CAACsC,MAAM,EAAE;IAChB,IAAIA,MAAM,YAAYpC,IAAI,EAAE;MACxBoC,MAAM,CAACnC,MAAM,GAAG,IAAI;MACpB,IAAI,CAACkC,OAAO,CAACjC,IAAI,CAACkC,MAAM,CAAC;IAC7B;IACA,OAAO,IAAI;EACf;EACAnB,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACkB,OAAO,CAAC,CAAC,CAAC,CAACvD,KAAK;EAChC;EACAS,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAAC8C,OAAO,CAAC,CAAC,CAAC,CAAC9C,GAAG,CAAC,CAAC;EAChC;EACAgC,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAID,MAAM,CAAC,CAAC;IACxB,IAAI,CAACK,OAAO,CAACE,OAAO,CAACN,GAAG,CAACjC,WAAW,EAAEiC,GAAG,CAAC;IAC1C,OAAOA,GAAG;EACd;AACJ;AACA,OAAO,MAAMO,SAAS,SAAS1C,MAAM,CAAC;EAClCjB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGuD,SAAS,CAAC;IACnB,IAAI,CAACK,MAAM,GAAG,IAAIC,MAAM,CAAC,EAAE,CAAC;EAChC;EACAC,OAAOA,CAAC7D,KAAK,EAAE;IACX,MAAM8D,KAAK,GAAG,IAAI;IAClB,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIZ,GAAG,GAAGnD,KAAK,CAACuB,OAAO,CAAC,IAAI,CAACoC,MAAM,EAAE,YAAY;MAC7CI,QAAQ,GAAG,IAAI;MACf,OAAOD,KAAK,CAACE,QAAQ,CAACC,KAAK,CAACC,SAAS,CAACrC,KAAK,CAACsC,IAAI,CAACb,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACvE,CAAC,CAAC;IACF;IACA;IACA,IAAI,CAACS,QAAQ,IAAI,IAAI,CAAC9C,SAAS,CAACmD,IAAI,CAACjD,KAAK,IAAIA,KAAK,YAAYkD,YAAY,IAAIC,OAAO,CAACnD,KAAK,CAACoD,SAAS,CAAC,CAAC,EAAE;MACtGpB,GAAG,GAAG,IAAI,CAACa,QAAQ,CAAC,EAAE,CAAC;IAC3B;IACA,OAAOb,GAAG;EACd;EACAa,QAAQA,CAACQ,MAAM,EAAE;IACb,IAAIrB,GAAG,GAAG,EAAE;IACZ,KAAK,MAAMK,MAAM,IAAI,IAAI,CAACvC,SAAS,EAAE;MACjC,IAAIuC,MAAM,YAAYa,YAAY,EAAE;QAChC,IAAIrE,KAAK,GAAGwE,MAAM,CAAChB,MAAM,CAACT,KAAK,CAAC,IAAI,EAAE;QACtC/C,KAAK,GAAGwD,MAAM,CAACK,OAAO,CAAC7D,KAAK,CAAC;QAC7BmD,GAAG,IAAInD,KAAK;MAChB,CAAC,MACI;QACDmD,GAAG,IAAIK,MAAM,CAACnB,QAAQ,CAAC,CAAC;MAC5B;IACJ;IACA,OAAOc,GAAG;EACd;EACAd,QAAQA,CAAA,EAAG;IACP,OAAO,EAAE;EACb;EACAI,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAIO,SAAS,CAAC,CAAC;IAC3BP,GAAG,CAACQ,MAAM,GAAG,IAAIC,MAAM,CAAC,IAAI,CAACD,MAAM,CAACc,MAAM,EAAE,EAAE,IAAI,IAAI,CAACd,MAAM,CAACe,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,IAAI,IAAI,CAACf,MAAM,CAACgB,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;IACvHxB,GAAG,CAAClC,SAAS,GAAG,IAAI,CAACS,QAAQ,CAAC2B,GAAG,CAAClC,KAAK,IAAIA,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC;IACzD,OAAOU,GAAG;EACd;AACJ;AACA,OAAO,MAAMkB,YAAY,SAASrD,MAAM,CAAC;EACrCjB,WAAWA,CAACgD,KAAK,EAAE6B,aAAa,EAAEC,OAAO,EAAEN,SAAS,EAAE;IAClD,KAAK,CAAC,CAAC;IACP,IAAI,CAACxB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC6B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACN,SAAS,GAAGA,SAAS;EAC9B;EACAV,OAAOA,CAAC7D,KAAK,EAAE;IACX,IAAI,IAAI,CAAC4E,aAAa,KAAK,QAAQ,EAAE;MACjC,OAAO,CAAC5E,KAAK,GAAG,EAAE,GAAGA,KAAK,CAAC8E,iBAAiB,CAAC,CAAC;IAClD,CAAC,MACI,IAAI,IAAI,CAACF,aAAa,KAAK,UAAU,EAAE;MACxC,OAAO,CAAC5E,KAAK,GAAG,EAAE,GAAGA,KAAK,CAAC+E,iBAAiB,CAAC,CAAC;IAClD,CAAC,MACI,IAAI,IAAI,CAACH,aAAa,KAAK,YAAY,EAAE;MAC1C,OAAO,CAAC5E,KAAK,GAAG,EAAE,GAAIA,KAAK,CAAC,CAAC,CAAC,CAAC8E,iBAAiB,CAAC,CAAC,GAAG9E,KAAK,CAACQ,MAAM,CAAC,CAAC,CAAE;IACzE,CAAC,MACI,IAAI,IAAI,CAACoE,aAAa,KAAK,YAAY,EAAE;MAC1C,OAAO,CAAC5E,KAAK,GAAG,EAAE,GAAG,IAAI,CAACgF,aAAa,CAAChF,KAAK,CAAC;IAClD,CAAC,MACI,IAAI,IAAI,CAAC4E,aAAa,KAAK,WAAW,EAAE;MACzC,OAAO,CAAC5E,KAAK,GAAG,EAAE,GAAG,IAAI,CAACiF,YAAY,CAACjF,KAAK,CAAC;IACjD,CAAC,MACI,IAAIsE,OAAO,CAACtE,KAAK,CAAC,IAAI,OAAO,IAAI,CAAC6E,OAAO,KAAK,QAAQ,EAAE;MACzD,OAAO,IAAI,CAACA,OAAO;IACvB,CAAC,MACI,IAAI,CAACP,OAAO,CAACtE,KAAK,CAAC,IAAI,OAAO,IAAI,CAACuE,SAAS,KAAK,QAAQ,EAAE;MAC5D,OAAO,IAAI,CAACA,SAAS;IACzB,CAAC,MACI;MACD,OAAOvE,KAAK,IAAI,EAAE;IACtB;EACJ;EACAgF,aAAaA,CAAChF,KAAK,EAAE;IACjB,MAAMkF,KAAK,GAAGlF,KAAK,CAACkF,KAAK,CAAC,aAAa,CAAC;IACxC,IAAI,CAACA,KAAK,EAAE;MACR,OAAOlF,KAAK;IAChB;IACA,OAAOkF,KAAK,CAAC7B,GAAG,CAAC8B,IAAI,IAAI;MACrB,OAAOA,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGF,IAAI,CAAC3E,MAAM,CAAC,CAAC,CAAC;IACxD,CAAC,CAAC,CACG8E,IAAI,CAAC,EAAE,CAAC;EACjB;EACAL,YAAYA,CAACjF,KAAK,EAAE;IAChB,MAAMkF,KAAK,GAAGlF,KAAK,CAACkF,KAAK,CAAC,aAAa,CAAC;IACxC,IAAI,CAACA,KAAK,EAAE;MACR,OAAOlF,KAAK;IAChB;IACA,OAAOkF,KAAK,CAAC7B,GAAG,CAAC,CAAC8B,IAAI,EAAEpC,KAAK,KAAK;MAC9B,IAAIA,KAAK,KAAK,CAAC,EAAE;QACb,OAAOoC,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC,GAAGJ,IAAI,CAAC3E,MAAM,CAAC,CAAC,CAAC;MACxD;MACA,OAAO2E,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGF,IAAI,CAAC3E,MAAM,CAAC,CAAC,CAAC;IACxD,CAAC,CAAC,CACG8E,IAAI,CAAC,EAAE,CAAC;EACjB;EACA7C,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAIkB,YAAY,CAAC,IAAI,CAACtB,KAAK,EAAE,IAAI,CAAC6B,aAAa,EAAE,IAAI,CAACC,OAAO,EAAE,IAAI,CAACN,SAAS,CAAC;IAC1F,OAAOpB,GAAG;EACd;AACJ;AACA,OAAO,MAAMqC,QAAQ,SAAS9C,mBAAmB,CAAC;EAC9C3C,WAAWA,CAAC0F,IAAI,EAAE;IACd,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EACpB;EACA5B,OAAOA,CAAC6B,QAAQ,EAAE;IACd,IAAI1F,KAAK,GAAG0F,QAAQ,CAAC7B,OAAO,CAAC,IAAI,CAAC;IAClC,IAAI,IAAI,CAACT,SAAS,EAAE;MAChBpD,KAAK,GAAG,IAAI,CAACoD,SAAS,CAACS,OAAO,CAAC7D,KAAK,IAAI,EAAE,CAAC;IAC/C;IACA,IAAIA,KAAK,KAAKmC,SAAS,EAAE;MACrB,IAAI,CAAClB,SAAS,GAAG,CAAC,IAAIG,IAAI,CAACpB,KAAK,CAAC,CAAC;MAClC,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACAyC,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAIqC,QAAQ,CAAC,IAAI,CAACC,IAAI,CAAC;IACnC,IAAI,IAAI,CAACrC,SAAS,EAAE;MAChBD,GAAG,CAACC,SAAS,GAAG,IAAI,CAACA,SAAS,CAACX,KAAK,CAAC,CAAC;IAC1C;IACAU,GAAG,CAAClC,SAAS,GAAG,IAAI,CAACS,QAAQ,CAAC2B,GAAG,CAAClC,KAAK,IAAIA,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC;IACzD,OAAOU,GAAG;EACd;AACJ;AACA,SAASwC,IAAIA,CAACnC,MAAM,EAAEoC,OAAO,EAAE;EAC3B,MAAMC,KAAK,GAAG,CAAC,GAAGrC,MAAM,CAAC;EACzB,OAAOqC,KAAK,CAAClF,MAAM,GAAG,CAAC,EAAE;IACrB,MAAM6C,MAAM,GAAGqC,KAAK,CAACC,KAAK,CAAC,CAAC;IAC5B,MAAMC,OAAO,GAAGH,OAAO,CAACpC,MAAM,CAAC;IAC/B,IAAI,CAACuC,OAAO,EAAE;MACV;IACJ;IACAF,KAAK,CAACG,OAAO,CAAC,GAAGxC,MAAM,CAAC9B,QAAQ,CAAC;EACrC;AACJ;AACA,OAAO,MAAMU,eAAe,SAASpB,MAAM,CAAC;EACxC,IAAIiF,eAAeA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;MACrB;MACA,MAAMC,GAAG,GAAG,EAAE;MACd,IAAIC,IAAI;MACR,IAAI,CAACT,IAAI,CAAC,UAAUzD,SAAS,EAAE;QAC3B,IAAIA,SAAS,YAAYS,WAAW,EAAE;UAClCwD,GAAG,CAAC7E,IAAI,CAACY,SAAS,CAAC;UACnBkE,IAAI,GAAG,CAACA,IAAI,IAAIA,IAAI,CAACrD,KAAK,GAAGb,SAAS,CAACa,KAAK,GAAGb,SAAS,GAAGkE,IAAI;QACnE;QACA,OAAO,IAAI;MACf,CAAC,CAAC;MACF,IAAI,CAACF,aAAa,GAAG;QAAEC,GAAG;QAAEC;MAAK,CAAC;IACtC;IACA,OAAO,IAAI,CAACF,aAAa;EAC7B;EACA,IAAIG,YAAYA,CAAA,EAAG;IACf,MAAM;MAAEF;IAAI,CAAC,GAAG,IAAI,CAACF,eAAe;IACpC,OAAOE,GAAG;EACd;EACAG,MAAMA,CAAC9C,MAAM,EAAE;IACX,IAAIvD,GAAG,GAAG,CAAC;IACX,IAAIsG,KAAK,GAAG,KAAK;IACjB,IAAI,CAACZ,IAAI,CAACzD,SAAS,IAAI;MACnB,IAAIA,SAAS,KAAKsB,MAAM,EAAE;QACtB+C,KAAK,GAAG,IAAI;QACZ,OAAO,KAAK;MAChB;MACAtG,GAAG,IAAIiC,SAAS,CAACzB,GAAG,CAAC,CAAC;MACtB,OAAO,IAAI;IACf,CAAC,CAAC;IACF,IAAI,CAAC8F,KAAK,EAAE;MACR,OAAO,CAAC,CAAC;IACb;IACA,OAAOtG,GAAG;EACd;EACAuG,OAAOA,CAAChD,MAAM,EAAE;IACZ,IAAIL,GAAG,GAAG,CAAC;IACXwC,IAAI,CAAC,CAACnC,MAAM,CAAC,EAAEA,MAAM,IAAI;MACrBL,GAAG,IAAIK,MAAM,CAAC/C,GAAG,CAAC,CAAC;MACnB,OAAO,IAAI;IACf,CAAC,CAAC;IACF,OAAO0C,GAAG;EACd;EACAsD,qBAAqBA,CAACC,WAAW,EAAE;IAC/B,MAAMvD,GAAG,GAAG,EAAE;IACd,IAAI;MAAE9B;IAAO,CAAC,GAAGqF,WAAW;IAC5B,OAAOrF,MAAM,EAAE;MACX,IAAIA,MAAM,YAAYsB,WAAW,EAAE;QAC/BQ,GAAG,CAAC7B,IAAI,CAACD,MAAM,CAAC;MACpB;MACAA,MAAM,GAAGA,MAAM,CAACA,MAAM;IAC1B;IACA,OAAO8B,GAAG;EACd;EACAwD,gBAAgBA,CAACjB,QAAQ,EAAE;IACvB,IAAI,CAACC,IAAI,CAACzD,SAAS,IAAI;MACnB,IAAIA,SAAS,YAAYsD,QAAQ,EAAE;QAC/B,IAAItD,SAAS,CAAC2B,OAAO,CAAC6B,QAAQ,CAAC,EAAE;UAC7B,IAAI,CAACQ,aAAa,GAAG/D,SAAS;QAClC;MACJ;MACA,OAAO,IAAI;IACf,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACAjB,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAAC+E,aAAa,GAAG/D,SAAS;IAC9B,OAAO,KAAK,CAACjB,WAAW,CAACC,KAAK,CAAC;EACnC;EACAI,OAAOA,CAACJ,KAAK,EAAEK,MAAM,EAAE;IACnB,IAAI,CAAC0E,aAAa,GAAG/D,SAAS;IAC9B,OAAO,KAAK,CAACZ,OAAO,CAACJ,KAAK,EAAEK,MAAM,CAAC;EACvC;EACAiB,KAAKA,CAAA,EAAG;IACJ,MAAMU,GAAG,GAAG,IAAIf,eAAe,CAAC,CAAC;IACjC,IAAI,CAACnB,SAAS,GAAG,IAAI,CAACS,QAAQ,CAAC2B,GAAG,CAAClC,KAAK,IAAIA,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC;IAC1D,OAAOU,GAAG;EACd;EACAwC,IAAIA,CAACC,OAAO,EAAE;IACVD,IAAI,CAAC,IAAI,CAACjE,QAAQ,EAAEkE,OAAO,CAAC;EAChC;AACJ;AACA,OAAO,MAAMgB,aAAa,CAAC;EACvB7G,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC8G,QAAQ,GAAG,IAAI/G,OAAO,CAAC,CAAC;IAC7B,IAAI,CAACgH,MAAM,GAAG;MAAElG,IAAI,EAAE,EAAE,CAAC;MAAqBX,GAAG,EAAE,CAAC;MAAEQ,GAAG,EAAE;IAAE,CAAC;EAClE;EACA,OAAOsG,MAAMA,CAAC/G,KAAK,EAAE;IACjB,OAAOA,KAAK,CAACuB,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC;EAC5C;EACA,OAAOyF,mBAAmBA,CAACC,QAAQ,EAAE;IACjC,OAAO,eAAe,CAACC,IAAI,CAACD,QAAQ,CAAC;EACzC;EACAE,KAAKA,CAACnH,KAAK,EAAEoH,kBAAkB,EAAEC,mBAAmB,EAAE;IAClD,MAAMpF,OAAO,GAAG,IAAIG,eAAe,CAAC,CAAC;IACrC,IAAI,CAACkF,aAAa,CAACtH,KAAK,EAAEiC,OAAO,CAAC;IAClC,IAAI,CAACsF,kBAAkB,CAACtF,OAAO,EAAEoF,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,KAAK,KAAK,CAAC,GAAGA,mBAAmB,GAAG,KAAK,EAAED,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,KAAK,CAAC,GAAGA,kBAAkB,GAAG,KAAK,CAAC;IACzN,OAAOnF,OAAO;EAClB;EACAqF,aAAaA,CAACtH,KAAK,EAAEiC,OAAO,EAAE;IAC1B,MAAMqE,MAAM,GAAGrE,OAAO,CAACP,QAAQ,CAACf,MAAM;IACtC,IAAI,CAACkG,QAAQ,CAACxG,IAAI,CAACL,KAAK,CAAC;IACzB,IAAI,CAAC8G,MAAM,GAAG,IAAI,CAACD,QAAQ,CAACnG,IAAI,CAAC,CAAC;IAClC,OAAO,IAAI,CAAC8G,MAAM,CAACvF,OAAO,CAAC,EAAE;MACzB;IAAA;IAEJ;IACA;IACA,MAAMwF,wBAAwB,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC1C,MAAMC,sBAAsB,GAAG,EAAE;IACjC1F,OAAO,CAAC0D,IAAI,CAACnC,MAAM,IAAI;MACnB,IAAIA,MAAM,YAAYb,WAAW,EAAE;QAC/B,IAAIa,MAAM,CAACR,cAAc,EAAE;UACvByE,wBAAwB,CAACG,GAAG,CAAC,CAAC,EAAEzF,SAAS,CAAC;QAC9C,CAAC,MACI,IAAI,CAACsF,wBAAwB,CAACI,GAAG,CAACrE,MAAM,CAACT,KAAK,CAAC,IAAIS,MAAM,CAAC9B,QAAQ,CAACf,MAAM,GAAG,CAAC,EAAE;UAChF8G,wBAAwB,CAACG,GAAG,CAACpE,MAAM,CAACT,KAAK,EAAES,MAAM,CAAC9B,QAAQ,CAAC;QAC/D,CAAC,MACI;UACDiG,sBAAsB,CAACrG,IAAI,CAACkC,MAAM,CAAC;QACvC;MACJ;MACA,OAAO,IAAI;IACf,CAAC,CAAC;IACF,MAAMsE,2BAA2B,GAAGA,CAACpB,WAAW,EAAEb,KAAK,KAAK;MACxD,MAAMkC,aAAa,GAAGN,wBAAwB,CAACO,GAAG,CAACtB,WAAW,CAAC3D,KAAK,CAAC;MACrE,IAAI,CAACgF,aAAa,EAAE;QAChB;MACJ;MACA,MAAMtF,KAAK,GAAG,IAAIE,WAAW,CAAC+D,WAAW,CAAC3D,KAAK,CAAC;MAChDN,KAAK,CAACW,SAAS,GAAGsD,WAAW,CAACtD,SAAS;MACvC,KAAK,MAAMjC,KAAK,IAAI4G,aAAa,EAAE;QAC/B,MAAME,QAAQ,GAAG9G,KAAK,CAACsB,KAAK,CAAC,CAAC;QAC9BA,KAAK,CAACvB,WAAW,CAAC+G,QAAQ,CAAC;QAC3B;QACA,IAAIA,QAAQ,YAAYtF,WAAW,IAAI8E,wBAAwB,CAACI,GAAG,CAACI,QAAQ,CAAClF,KAAK,CAAC,IAAI,CAAC8C,KAAK,CAACgC,GAAG,CAACI,QAAQ,CAAClF,KAAK,CAAC,EAAE;UAC/G8C,KAAK,CAACqC,GAAG,CAACD,QAAQ,CAAClF,KAAK,CAAC;UACzB+E,2BAA2B,CAACG,QAAQ,EAAEpC,KAAK,CAAC;UAC5CA,KAAK,CAACsC,MAAM,CAACF,QAAQ,CAAClF,KAAK,CAAC;QAChC;MACJ;MACAd,OAAO,CAACV,OAAO,CAACmF,WAAW,EAAE,CAACjE,KAAK,CAAC,CAAC;IACzC,CAAC;IACD,MAAMoD,KAAK,GAAG,IAAIuC,GAAG,CAAC,CAAC;IACvB,KAAK,MAAM1B,WAAW,IAAIiB,sBAAsB,EAAE;MAC9CG,2BAA2B,CAACpB,WAAW,EAAEb,KAAK,CAAC;IACnD;IACA,OAAO5D,OAAO,CAACP,QAAQ,CAACG,KAAK,CAACyE,MAAM,CAAC;EACzC;EACAiB,kBAAkBA,CAACtF,OAAO,EAAEoF,mBAAmB,EAAED,kBAAkB,EAAE;IACjE,IAAIC,mBAAmB,IAAID,kBAAkB,IAAInF,OAAO,CAACoE,YAAY,CAAC1F,MAAM,GAAG,CAAC,EAAE;MAC9E,MAAM0H,YAAY,GAAGpG,OAAO,CAACoE,YAAY,CAACiC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACxF,KAAK,KAAK,CAAC,CAAC;MAClE,IAAI,CAACsF,YAAY,EAAE;QACf;QACA;QACApG,OAAO,CAACf,WAAW,CAAC,IAAIyB,WAAW,CAAC,CAAC,CAAC,CAAC;MAC3C;IACJ;EACJ;EACA6F,OAAOA,CAAC5H,IAAI,EAAEZ,KAAK,EAAE;IACjB,IAAIY,IAAI,KAAKuB,SAAS,IAAI,IAAI,CAAC2E,MAAM,CAAClG,IAAI,KAAKA,IAAI,EAAE;MACjD,MAAMuC,GAAG,GAAG,CAACnD,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC6G,QAAQ,CAACvG,SAAS,CAAC,IAAI,CAACwG,MAAM,CAAC;MAChE,IAAI,CAACA,MAAM,GAAG,IAAI,CAACD,QAAQ,CAACnG,IAAI,CAAC,CAAC;MAClC,OAAOyC,GAAG;IACd;IACA,OAAO,KAAK;EAChB;EACAsF,OAAOA,CAAClI,KAAK,EAAE;IACX,IAAI,CAACsG,QAAQ,CAAC5G,GAAG,GAAGM,KAAK,CAACN,GAAG,GAAGM,KAAK,CAACE,GAAG;IACzC,IAAI,CAACqG,MAAM,GAAGvG,KAAK;IACnB,OAAO,KAAK;EAChB;EACAmI,MAAMA,CAAC9H,IAAI,EAAE;IACT,MAAM+H,KAAK,GAAG,IAAI,CAAC7B,MAAM;IACzB,OAAO,IAAI,CAACA,MAAM,CAAClG,IAAI,KAAKA,IAAI,EAAE;MAC9B,IAAI,IAAI,CAACkG,MAAM,CAAClG,IAAI,KAAK,EAAE,CAAC,qBAAqB;QAC7C,OAAO,KAAK;MAChB,CAAC,MACI,IAAI,IAAI,CAACkG,MAAM,CAAClG,IAAI,KAAK,CAAC,CAAC,2BAA2B;QACvD,MAAMgI,SAAS,GAAG,IAAI,CAAC/B,QAAQ,CAACnG,IAAI,CAAC,CAAC;QACtC,IAAIkI,SAAS,CAAChI,IAAI,KAAK,CAAC,CAAC,0BAClBgI,SAAS,CAAChI,IAAI,KAAK,CAAC,CAAC,8BACrBgI,SAAS,CAAChI,IAAI,KAAK,CAAC,CAAC,2BAA2B;UACnD,OAAO,KAAK;QAChB;MACJ;MACA,IAAI,CAACkG,MAAM,GAAG,IAAI,CAACD,QAAQ,CAACnG,IAAI,CAAC,CAAC;IACtC;IACA,MAAMV,KAAK,GAAG,IAAI,CAAC6G,QAAQ,CAAC7G,KAAK,CAAC6I,SAAS,CAACF,KAAK,CAAC1I,GAAG,EAAE,IAAI,CAAC6G,MAAM,CAAC7G,GAAG,CAAC,CAACsB,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;IACrG,IAAI,CAACuF,MAAM,GAAG,IAAI,CAACD,QAAQ,CAACnG,IAAI,CAAC,CAAC;IAClC,OAAOV,KAAK;EAChB;EACAwH,MAAMA,CAAChE,MAAM,EAAE;IACX,OAAO,IAAI,CAACsF,aAAa,CAACtF,MAAM,CAAC,IAC1B,IAAI,CAACuF,2BAA2B,CAACvF,MAAM,CAAC,IACxC,IAAI,CAACwF,wBAAwB,CAACxF,MAAM,CAAC,IACrC,IAAI,CAACyF,qBAAqB,CAACzF,MAAM,CAAC,IAClC,IAAI,CAAC0F,cAAc,CAAC1F,MAAM,CAAC;EACtC;EACA;EACAsF,aAAaA,CAACtF,MAAM,EAAE;IAClB,IAAIxD,KAAK;IACT,IAAIA,KAAK,GAAG,IAAI,CAACwI,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,EAAE;MACzD;MACAxI,KAAK,GAAG,IAAI,CAACwI,OAAO,CAAC,CAAC,CAAC,wBAAwB,IAAI,CAAC,IAC7C,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,4BAA4B,IAAI,CAAC,IAChD,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,IAC/CxI,KAAK;MACZwD,MAAM,CAACtC,WAAW,CAAC,IAAIE,IAAI,CAACpB,KAAK,CAAC,CAAC;MACnC,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA;EACA+I,2BAA2BA,CAAC1H,MAAM,EAAE;IAChC,IAAIrB,KAAK;IACT,MAAMO,KAAK,GAAG,IAAI,CAACuG,MAAM;IACzB,MAAM5B,KAAK,GAAG,IAAI,CAACsD,OAAO,CAAC,CAAC,CAAC,sBAAsB,CAAC,KAC5CxI,KAAK,GAAG,IAAI,CAACwI,OAAO,CAAC,CAAC,CAAC,8BAA8B,IAAI,CAAC,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,qBAAqB,IAAI,CAAC,CAAC;IAChH,IAAI,CAACtD,KAAK,EAAE;MACR,OAAO,IAAI,CAACuD,OAAO,CAAClI,KAAK,CAAC;IAC9B;IACAc,MAAM,CAACH,WAAW,CAAC,OAAO,CAACgG,IAAI,CAAClH,KAAK,CAAC,GAChC,IAAI2C,WAAW,CAACwG,MAAM,CAACnJ,KAAK,CAAC,CAAC,GAC9B,IAAIwF,QAAQ,CAACxF,KAAK,CAAC,CAAC;IAC1B,OAAO,IAAI;EACf;EACA;EACAgJ,wBAAwBA,CAAC3H,MAAM,EAAE;IAC7B,IAAI0B,KAAK;IACT,MAAMxC,KAAK,GAAG,IAAI,CAACuG,MAAM;IACzB,MAAM5B,KAAK,GAAG,IAAI,CAACsD,OAAO,CAAC,CAAC,CAAC,sBAAsB,CAAC,IAC7C,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,yBAAyB,CAAC,KACxCzF,KAAK,GAAG,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,qBAAqB,IAAI,CAAC,CAAC;IAC1D,IAAI,CAACtD,KAAK,EAAE;MACR,OAAO,IAAI,CAACuD,OAAO,CAAClI,KAAK,CAAC;IAC9B;IACA,MAAMmG,WAAW,GAAG,IAAI/D,WAAW,CAACwG,MAAM,CAACpG,KAAK,CAAC,CAAC;IAClD,IAAI,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,qBAAqB,CAAC,EAAE;MACvC;MACA,OAAO,IAAI,EAAE;QACT;QACA,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;UAC5CnH,MAAM,CAACH,WAAW,CAACwF,WAAW,CAAC;UAC/B,OAAO,IAAI;QACf;QACA,IAAI,IAAI,CAACc,MAAM,CAACd,WAAW,CAAC,EAAE;UAC1B;QACJ;QACA;QACArF,MAAM,CAACH,WAAW,CAAC,IAAIE,IAAI,CAAC,IAAI,GAAG2B,KAAK,GAAG,GAAG,CAAC,CAAC;QAChD2D,WAAW,CAAChF,QAAQ,CAAC+B,OAAO,CAACpC,MAAM,CAACH,WAAW,EAAEG,MAAM,CAAC;QACxD,OAAO,IAAI;MACf;IACJ,CAAC,MACI,IAAIqF,WAAW,CAAC3D,KAAK,GAAG,CAAC,IAAI,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,oBAAoB,CAAC,EAAE;MACpE;MACA,MAAMvF,MAAM,GAAG,IAAIC,MAAM,CAAC,CAAC;MAC3B,OAAO,IAAI,EAAE;QACT,IAAI,IAAI,CAACkG,mBAAmB,CAACnG,MAAM,CAAC,EAAE;UAClC,IAAI,IAAI,CAACuF,OAAO,CAAC,CAAC,CAAC,qBAAqB,CAAC,EAAE;YACvC;YACA;UACJ;UACA,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,oBAAoB,CAAC,EAAE;YACtC9B,WAAW,CAACxF,WAAW,CAAC+B,MAAM,CAAC;YAC/B,IAAI,IAAI,CAACuF,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;cAC5C;cACAnH,MAAM,CAACH,WAAW,CAACwF,WAAW,CAAC;cAC/B,OAAO,IAAI;YACf;UACJ;QACJ;QACA,IAAI,CAAC+B,OAAO,CAAClI,KAAK,CAAC;QACnB,OAAO,KAAK;MAChB;IACJ,CAAC,MACI,IAAI,IAAI,CAACiI,OAAO,CAAC,CAAC,CAAC,4BAA4B,CAAC,EAAE;MACnD;MACA,IAAI,IAAI,CAACa,eAAe,CAAC3C,WAAW,CAAC,EAAE;QACnCrF,MAAM,CAACH,WAAW,CAACwF,WAAW,CAAC;QAC/B,OAAO,IAAI;MACf;MACA,IAAI,CAAC+B,OAAO,CAAClI,KAAK,CAAC;MACnB,OAAO,KAAK;IAChB,CAAC,MACI,IAAI,IAAI,CAACiI,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;MACjD;MACAnH,MAAM,CAACH,WAAW,CAACwF,WAAW,CAAC;MAC/B,OAAO,IAAI;IACf,CAAC,MACI;MACD;MACA,OAAO,IAAI,CAAC+B,OAAO,CAAClI,KAAK,CAAC;IAC9B;EACJ;EACA6I,mBAAmBA,CAAC/H,MAAM,EAAE;IACxB,MAAMd,KAAK,GAAG,IAAI,CAACuG,MAAM;IACzB,MAAMwC,MAAM,GAAG,EAAE;IACjB,OAAO,IAAI,EAAE;MACT,IAAI,IAAI,CAACxC,MAAM,CAAClG,IAAI,KAAK,CAAC,CAAC,yBAAyB,IAAI,CAACkG,MAAM,CAAClG,IAAI,KAAK,CAAC,CAAC,sBAAsB;QAC7F;MACJ;MACA,IAAIZ,KAAK;MACT,IAAIA,KAAK,GAAG,IAAI,CAACwI,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,EAAE;QACzD;QACAxI,KAAK,GAAG,IAAI,CAACwI,OAAO,CAAC,CAAC,CAAC,uBAAuB,IAAI,CAAC,IAC5C,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,sBAAsB,IAAI,CAAC,IAC1C,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,IAC/CxI,KAAK;MAChB,CAAC,MACI;QACDA,KAAK,GAAG,IAAI,CAACwI,OAAO,CAACrG,SAAS,EAAE,IAAI,CAAC;MACzC;MACA,IAAI,CAACnC,KAAK,EAAE;QACR;QACA,IAAI,CAACyI,OAAO,CAAClI,KAAK,CAAC;QACnB,OAAO,KAAK;MAChB;MACA+I,MAAM,CAAChI,IAAI,CAACtB,KAAK,CAAC;IACtB;IACA,IAAIsJ,MAAM,CAAC3I,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAAC8H,OAAO,CAAClI,KAAK,CAAC;MACnB,OAAO,KAAK;IAChB;IACAc,MAAM,CAACH,WAAW,CAAC,IAAIE,IAAI,CAACkI,MAAM,CAAChE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7C,OAAO,IAAI;EACf;EACA;EACA2D,qBAAqBA,CAAC5H,MAAM,EAAE;IAC1B,IAAIoE,IAAI;IACR,MAAMlF,KAAK,GAAG,IAAI,CAACuG,MAAM;IACzB,MAAM5B,KAAK,GAAG,IAAI,CAACsD,OAAO,CAAC,CAAC,CAAC,sBAAsB,CAAC,IAC7C,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,yBAAyB,CAAC,KACxC/C,IAAI,GAAG,IAAI,CAAC+C,OAAO,CAAC,CAAC,CAAC,8BAA8B,IAAI,CAAC,CAAC;IAClE,IAAI,CAACtD,KAAK,EAAE;MACR,OAAO,IAAI,CAACuD,OAAO,CAAClI,KAAK,CAAC;IAC9B;IACA,MAAMgJ,QAAQ,GAAG,IAAI/D,QAAQ,CAACC,IAAI,CAAC;IACnC,IAAI,IAAI,CAAC+C,OAAO,CAAC,CAAC,CAAC,qBAAqB,CAAC,EAAE;MACvC;MACA,OAAO,IAAI,EAAE;QACT;QACA,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;UAC5CnH,MAAM,CAACH,WAAW,CAACqI,QAAQ,CAAC;UAC5B,OAAO,IAAI;QACf;QACA,IAAI,IAAI,CAAC/B,MAAM,CAAC+B,QAAQ,CAAC,EAAE;UACvB;QACJ;QACA;QACAlI,MAAM,CAACH,WAAW,CAAC,IAAIE,IAAI,CAAC,IAAI,GAAGqE,IAAI,GAAG,GAAG,CAAC,CAAC;QAC/C8D,QAAQ,CAAC7H,QAAQ,CAAC+B,OAAO,CAACpC,MAAM,CAACH,WAAW,EAAEG,MAAM,CAAC;QACrD,OAAO,IAAI;MACf;IACJ,CAAC,MACI,IAAI,IAAI,CAACmH,OAAO,CAAC,CAAC,CAAC,4BAA4B,CAAC,EAAE;MACnD;MACA,IAAI,IAAI,CAACa,eAAe,CAACE,QAAQ,CAAC,EAAE;QAChClI,MAAM,CAACH,WAAW,CAACqI,QAAQ,CAAC;QAC5B,OAAO,IAAI;MACf;MACA,IAAI,CAACd,OAAO,CAAClI,KAAK,CAAC;MACnB,OAAO,KAAK;IAChB,CAAC,MACI,IAAI,IAAI,CAACiI,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;MACjD;MACAnH,MAAM,CAACH,WAAW,CAACqI,QAAQ,CAAC;MAC5B,OAAO,IAAI;IACf,CAAC,MACI;MACD;MACA,OAAO,IAAI,CAACd,OAAO,CAAClI,KAAK,CAAC;IAC9B;EACJ;EACA8I,eAAeA,CAAChI,MAAM,EAAE;IACpB;IACA,MAAM+B,SAAS,GAAG,IAAIM,SAAS,CAAC,CAAC;IACjC,IAAI8F,UAAU,GAAG,EAAE;IACnB,IAAIC,YAAY,GAAG,EAAE;IACrB;IACA,OAAO,IAAI,EAAE;MACT,IAAI,IAAI,CAACjB,OAAO,CAAC,CAAC,CAAC,4BAA4B,CAAC,EAAE;QAC9C;MACJ;MACA,IAAIkB,OAAO;MACX,IAAIA,OAAO,GAAG,IAAI,CAAClB,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,EAAE;QAC3DkB,OAAO,GAAG,IAAI,CAAClB,OAAO,CAAC,CAAC,CAAC,8BAA8B,IAAI,CAAC,IAAIkB,OAAO;QACvEF,UAAU,IAAIE,OAAO;QACrB;MACJ;MACA,IAAI,IAAI,CAAC5C,MAAM,CAAClG,IAAI,KAAK,EAAE,CAAC,qBAAqB;QAC7C4I,UAAU,IAAI,IAAI,CAAChB,OAAO,CAACrG,SAAS,EAAE,IAAI,CAAC;QAC3C;MACJ;MACA,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI,EAAE;MACT,IAAI,IAAI,CAACqG,OAAO,CAAC,CAAC,CAAC,4BAA4B,CAAC,EAAE;QAC9C;MACJ;MACA,IAAIkB,OAAO;MACX,IAAIA,OAAO,GAAG,IAAI,CAAClB,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,EAAE;QAC3DkB,OAAO,GAAG,IAAI,CAAClB,OAAO,CAAC,CAAC,CAAC,2BAA2B,IAAI,CAAC,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,8BAA8B,IAAI,CAAC,IAAIkB,OAAO;QAC1HtG,SAAS,CAAClC,WAAW,CAAC,IAAIE,IAAI,CAACsI,OAAO,CAAC,CAAC;QACxC;MACJ;MACA,IAAI,IAAI,CAACC,kBAAkB,CAACvG,SAAS,CAAC,IAAI,IAAI,CAAC8F,cAAc,CAAC9F,SAAS,CAAC,EAAE;QACtE;MACJ;MACA,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI,EAAE;MACT,IAAI,IAAI,CAACoF,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;QAC5C;MACJ;MACA,IAAI,IAAI,CAAC1B,MAAM,CAAClG,IAAI,KAAK,EAAE,CAAC,qBAAqB;QAC7C6I,YAAY,IAAI,IAAI,CAACjB,OAAO,CAACrG,SAAS,EAAE,IAAI,CAAC;QAC7C;MACJ;MACA,OAAO,KAAK;IAChB;IACA,IAAI;MACAiB,SAAS,CAACO,MAAM,GAAG,IAAIC,MAAM,CAAC4F,UAAU,EAAEC,YAAY,CAAC;IAC3D,CAAC,CACD,OAAOG,CAAC,EAAE;MACN;MACA,OAAO,KAAK;IAChB;IACAvI,MAAM,CAAC+B,SAAS,GAAGA,SAAS;IAC5B,OAAO,IAAI;EACf;EACAuG,kBAAkBA,CAACtI,MAAM,EAAE;IACvB,MAAMd,KAAK,GAAG,IAAI,CAACuG,MAAM;IACzB,IAAI,CAAC,IAAI,CAAC0B,OAAO,CAAC,CAAC,CAAC,sBAAsB,CAAC,EAAE;MACzC,OAAO,KAAK;IAChB;IACA,IAAIqB,OAAO,GAAG,KAAK;IACnB,IAAI,IAAI,CAACrB,OAAO,CAAC,CAAC,CAAC,yBAAyB,CAAC,EAAE;MAC3CqB,OAAO,GAAG,IAAI;IAClB;IACA,MAAM9G,KAAK,GAAG,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,qBAAqB,IAAI,CAAC;IACvD,IAAI,CAACzF,KAAK,EAAE;MACR,IAAI,CAAC0F,OAAO,CAAClI,KAAK,CAAC;MACnB,OAAO,KAAK;IAChB,CAAC,MACI,IAAI,CAACsJ,OAAO,EAAE;MACf;MACAxI,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,CAAC,CAAC;MACnD,OAAO,IAAI;IACf,CAAC,MACI,IAAI,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;MACjD;MACAnH,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,CAAC,CAAC;MACnD,OAAO,IAAI;IACf,CAAC,MACI,IAAI,CAAC,IAAI,CAACyF,OAAO,CAAC,CAAC,CAAC,qBAAqB,CAAC,EAAE;MAC7C,IAAI,CAACC,OAAO,CAAClI,KAAK,CAAC;MACnB,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAACiI,OAAO,CAAC,CAAC,CAAC,4BAA4B,CAAC,EAAE;MAC9C;MACA,MAAMsB,SAAS,GAAG,IAAI,CAACtB,OAAO,CAAC,CAAC,CAAC,8BAA8B,IAAI,CAAC;MACpE,IAAI,CAACsB,SAAS,IAAI,CAAC,IAAI,CAACtB,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,EAAE;QAC3D,IAAI,CAACC,OAAO,CAAClI,KAAK,CAAC;QACnB,OAAO,KAAK;MAChB,CAAC,MACI;QACDc,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,EAAE+G,SAAS,CAAC,CAAC;QAC9D,OAAO,IAAI;MACf;IACJ,CAAC,MACI,IAAI,IAAI,CAACtB,OAAO,CAAC,EAAE,CAAC,oBAAoB,CAAC,EAAE;MAC5C;MACA,MAAM3D,OAAO,GAAG,IAAI,CAAC6D,MAAM,CAAC,CAAC,CAAC,0BAA0B,CAAC;MACzD,IAAI7D,OAAO,EAAE;QACTxD,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,EAAEZ,SAAS,EAAE0C,OAAO,EAAE1C,SAAS,CAAC,CAAC;QAClF,OAAO,IAAI;MACf;IACJ,CAAC,MACI,IAAI,IAAI,CAACqG,OAAO,CAAC,EAAE,CAAC,oBAAoB,CAAC,EAAE;MAC5C;MACA,MAAMjE,SAAS,GAAG,IAAI,CAACmE,MAAM,CAAC,CAAC,CAAC,0BAA0B,CAAC;MAC3D,IAAInE,SAAS,EAAE;QACXlD,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,EAAEZ,SAAS,EAAEA,SAAS,EAAEoC,SAAS,CAAC,CAAC;QACpF,OAAO,IAAI;MACf;IACJ,CAAC,MACI,IAAI,IAAI,CAACiE,OAAO,CAAC,EAAE,CAAC,4BAA4B,CAAC,EAAE;MACpD;MACA,MAAM3D,OAAO,GAAG,IAAI,CAAC6D,MAAM,CAAC,CAAC,CAAC,qBAAqB,CAAC;MACpD,IAAI7D,OAAO,EAAE;QACT,MAAMN,SAAS,GAAG,IAAI,CAACmE,MAAM,CAAC,CAAC,CAAC,0BAA0B,CAAC;QAC3D,IAAInE,SAAS,EAAE;UACXlD,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,EAAEZ,SAAS,EAAE0C,OAAO,EAAEN,SAAS,CAAC,CAAC;UAClF,OAAO,IAAI;QACf;MACJ;IACJ,CAAC,MACI;MACD;MACA,MAAMA,SAAS,GAAG,IAAI,CAACmE,MAAM,CAAC,CAAC,CAAC,0BAA0B,CAAC;MAC3D,IAAInE,SAAS,EAAE;QACXlD,MAAM,CAACH,WAAW,CAAC,IAAImD,YAAY,CAAC8E,MAAM,CAACpG,KAAK,CAAC,EAAEZ,SAAS,EAAEA,SAAS,EAAEoC,SAAS,CAAC,CAAC;QACpF,OAAO,IAAI;MACf;IACJ;IACA,IAAI,CAACkE,OAAO,CAAClI,KAAK,CAAC;IACnB,OAAO,KAAK;EAChB;EACA2I,cAAcA,CAAC1F,MAAM,EAAE;IACnB,IAAI,IAAI,CAACsD,MAAM,CAAClG,IAAI,KAAK,EAAE,CAAC,qBAAqB;MAC7C4C,MAAM,CAACtC,WAAW,CAAC,IAAIE,IAAI,CAAC,IAAI,CAACyF,QAAQ,CAACvG,SAAS,CAAC,IAAI,CAACwG,MAAM,CAAC,CAAC,CAAC;MAClE,IAAI,CAAC0B,OAAO,CAACrG,SAAS,CAAC;MACvB,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}