{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\nimport { RunOnceScheduler, TimeoutTimer } from '../../../../base/common/async.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../../common/commands/replaceCommand.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { SearchParams } from '../../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { parseReplaceString, ReplacePattern } from './replacePattern.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\nexport const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();\n// Keep ContextKey use of 'Focussed' to not break when clauses\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n  primary: 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */,\n  mac: {\n    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */\n  }\n};\nexport const ToggleWholeWordKeybinding = {\n  primary: 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */,\n  mac: {\n    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */\n  }\n};\nexport const ToggleRegexKeybinding = {\n  primary: 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */,\n  mac: {\n    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */\n  }\n};\nexport const ToggleSearchScopeKeybinding = {\n  primary: 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */,\n  mac: {\n    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */\n  }\n};\nexport const TogglePreserveCaseKeybinding = {\n  primary: 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */,\n  mac: {\n    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */\n  }\n};\nexport const FIND_IDS = {\n  StartFindAction: 'actions.find',\n  StartFindWithSelection: 'actions.findWithSelection',\n  StartFindWithArgs: 'editor.actions.findWithArgs',\n  NextMatchFindAction: 'editor.action.nextMatchFindAction',\n  PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n  GoToMatchFindAction: 'editor.action.goToMatchFindAction',\n  NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n  PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n  StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n  CloseFindWidgetCommand: 'closeFindWidget',\n  ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n  ToggleWholeWordCommand: 'toggleFindWholeWord',\n  ToggleRegexCommand: 'toggleFindRegex',\n  ToggleSearchScopeCommand: 'toggleFindInSelection',\n  TogglePreserveCaseCommand: 'togglePreserveCase',\n  ReplaceOneAction: 'editor.action.replaceOne',\n  ReplaceAllAction: 'editor.action.replaceAll',\n  SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n  constructor(editor, state) {\n    this._toDispose = new DisposableStore();\n    this._editor = editor;\n    this._state = state;\n    this._isDisposed = false;\n    this._startSearchingTimer = new TimeoutTimer();\n    this._decorations = new FindDecorations(editor);\n    this._toDispose.add(this._decorations);\n    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n    this._toDispose.add(this._updateDecorationsScheduler);\n    this._toDispose.add(this._editor.onDidChangeCursorPosition(e => {\n      if (e.reason === 3 /* CursorChangeReason.Explicit */ || e.reason === 5 /* CursorChangeReason.Undo */ || e.reason === 6 /* CursorChangeReason.Redo */) {\n        this._decorations.setStartPosition(this._editor.getPosition());\n      }\n    }));\n    this._ignoreModelContentChanged = false;\n    this._toDispose.add(this._editor.onDidChangeModelContent(e => {\n      if (this._ignoreModelContentChanged) {\n        return;\n      }\n      if (e.isFlush) {\n        // a model.setValue() was called\n        this._decorations.reset();\n      }\n      this._decorations.setStartPosition(this._editor.getPosition());\n      this._updateDecorationsScheduler.schedule();\n    }));\n    this._toDispose.add(this._state.onFindReplaceStateChange(e => this._onStateChanged(e)));\n    this.research(false, this._state.searchScope);\n  }\n  dispose() {\n    this._isDisposed = true;\n    dispose(this._startSearchingTimer);\n    this._toDispose.dispose();\n  }\n  _onStateChanged(e) {\n    if (this._isDisposed) {\n      // The find model is disposed during a find state changed event\n      return;\n    }\n    if (!this._editor.hasModel()) {\n      // The find model will be disposed momentarily\n      return;\n    }\n    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n      const model = this._editor.getModel();\n      if (model.isTooLargeForSyncing()) {\n        this._startSearchingTimer.cancel();\n        this._startSearchingTimer.setIfNotSet(() => {\n          if (e.searchScope) {\n            this.research(e.moveCursor, this._state.searchScope);\n          } else {\n            this.research(e.moveCursor);\n          }\n        }, RESEARCH_DELAY);\n      } else {\n        if (e.searchScope) {\n          this.research(e.moveCursor, this._state.searchScope);\n        } else {\n          this.research(e.moveCursor);\n        }\n      }\n    }\n  }\n  static _getSearchRange(model, findScope) {\n    // If we have set now or before a find scope, use it for computing the search range\n    if (findScope) {\n      return findScope;\n    }\n    return model.getFullModelRange();\n  }\n  research(moveCursor, newFindScope) {\n    let findScopes = null;\n    if (typeof newFindScope !== 'undefined') {\n      if (newFindScope !== null) {\n        if (!Array.isArray(newFindScope)) {\n          findScopes = [newFindScope];\n        } else {\n          findScopes = newFindScope;\n        }\n      }\n    } else {\n      findScopes = this._decorations.getFindScopes();\n    }\n    if (findScopes !== null) {\n      findScopes = findScopes.map(findScope => {\n        if (findScope.startLineNumber !== findScope.endLineNumber) {\n          let endLineNumber = findScope.endLineNumber;\n          if (findScope.endColumn === 1) {\n            endLineNumber = endLineNumber - 1;\n          }\n          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n        }\n        return findScope;\n      });\n    }\n    const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n    this._decorations.set(findMatches, findScopes);\n    const editorSelection = this._editor.getSelection();\n    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n    if (currentMatchesPosition === 0 && findMatches.length > 0) {\n      // current selection is not on top of a match\n      // try to find its nearest result from the top of the document\n      const matchAfterSelection = findFirstIdxMonotonousOrArrLen(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\n    }\n    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n    if (moveCursor && this._editor.getOption(41 /* EditorOption.find */).cursorMoveOnType) {\n      this._moveToNextMatch(this._decorations.getStartPosition());\n    }\n  }\n  _hasMatches() {\n    return this._state.matchesCount > 0;\n  }\n  _cannotFind() {\n    if (!this._hasMatches()) {\n      const findScope = this._decorations.getFindScope();\n      if (findScope) {\n        // Reveal the selection so user is reminded that 'selection find' is on.\n        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* ScrollType.Smooth */);\n      }\n      return true;\n    }\n    return false;\n  }\n  _setCurrentFindMatch(match) {\n    const matchesPosition = this._decorations.setCurrentFindMatch(match);\n    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n    this._editor.setSelection(match);\n    this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* ScrollType.Smooth */);\n  }\n  _prevSearchPosition(before) {\n    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = before;\n    const model = this._editor.getModel();\n    if (isUsingLineStops || column === 1) {\n      if (lineNumber === 1) {\n        lineNumber = model.getLineCount();\n      } else {\n        lineNumber--;\n      }\n      column = model.getLineMaxColumn(lineNumber);\n    } else {\n      column--;\n    }\n    return new Position(lineNumber, column);\n  }\n  _moveToPrevMatch(before, isRecursed = false) {\n    if (!this._state.canNavigateBack()) {\n      // we are beyond the first matched find result\n      // instead of doing nothing, we should refocus the first item\n      const nextMatchRange = this._decorations.matchAfterPosition(before);\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n      return;\n    }\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let prevMatchRange = this._decorations.matchBeforePosition(before);\n      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n        before = this._prevSearchPosition(before);\n        prevMatchRange = this._decorations.matchBeforePosition(before);\n      }\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n      return;\n    }\n    if (this._cannotFind()) {\n      return;\n    }\n    const findScope = this._decorations.getFindScope();\n    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n    // ...(----)...|...\n    if (searchRange.getEndPosition().isBefore(before)) {\n      before = searchRange.getEndPosition();\n    }\n    // ...|...(----)...\n    if (before.isBefore(searchRange.getStartPosition())) {\n      before = searchRange.getEndPosition();\n    }\n    const {\n      lineNumber,\n      column\n    } = before;\n    const model = this._editor.getModel();\n    let position = new Position(lineNumber, column);\n    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, false);\n    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._prevSearchPosition(position);\n      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, false);\n    }\n    if (!prevMatch) {\n      // there is precisely one match and selection is on top of it\n      return;\n    }\n    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n    }\n    this._setCurrentFindMatch(prevMatch.range);\n  }\n  moveToPrevMatch() {\n    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n  }\n  _nextSearchPosition(after) {\n    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = after;\n    const model = this._editor.getModel();\n    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber === model.getLineCount()) {\n        lineNumber = 1;\n      } else {\n        lineNumber++;\n      }\n      column = 1;\n    } else {\n      column++;\n    }\n    return new Position(lineNumber, column);\n  }\n  _moveToNextMatch(after) {\n    if (!this._state.canNavigateForward()) {\n      // we are beyond the last matched find result\n      // instead of doing nothing, we should refocus the last item\n      const prevMatchRange = this._decorations.matchBeforePosition(after);\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n      return;\n    }\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let nextMatchRange = this._decorations.matchAfterPosition(after);\n      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n        // Looks like we're stuck at this position, unacceptable!\n        after = this._nextSearchPosition(after);\n        nextMatchRange = this._decorations.matchAfterPosition(after);\n      }\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n      return;\n    }\n    const nextMatch = this._getNextMatch(after, false, true);\n    if (nextMatch) {\n      this._setCurrentFindMatch(nextMatch.range);\n    }\n  }\n  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n    if (this._cannotFind()) {\n      return null;\n    }\n    const findScope = this._decorations.getFindScope();\n    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n    // ...(----)...|...\n    if (searchRange.getEndPosition().isBefore(after)) {\n      after = searchRange.getStartPosition();\n    }\n    // ...|...(----)...\n    if (after.isBefore(searchRange.getStartPosition())) {\n      after = searchRange.getStartPosition();\n    }\n    const {\n      lineNumber,\n      column\n    } = after;\n    const model = this._editor.getModel();\n    let position = new Position(lineNumber, column);\n    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches);\n    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._nextSearchPosition(position);\n      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches);\n    }\n    if (!nextMatch) {\n      // there is precisely one match and selection is on top of it\n      return null;\n    }\n    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n    }\n    return nextMatch;\n  }\n  moveToNextMatch() {\n    this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n  }\n  _moveToMatch(index) {\n    const decorationRange = this._decorations.getDecorationRangeAt(index);\n    if (decorationRange) {\n      this._setCurrentFindMatch(decorationRange);\n    }\n  }\n  moveToMatch(index) {\n    this._moveToMatch(index);\n  }\n  _getReplacePattern() {\n    if (this._state.isRegex) {\n      return parseReplaceString(this._state.replaceString);\n    }\n    return ReplacePattern.fromStaticValue(this._state.replaceString);\n  }\n  replace() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    const replacePattern = this._getReplacePattern();\n    const selection = this._editor.getSelection();\n    const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n    if (nextMatch) {\n      if (selection.equalsRange(nextMatch.range)) {\n        // selection sits on a find match => replace it!\n        const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n        const command = new ReplaceCommand(selection, replaceString);\n        this._executeEditorCommand('replace', command);\n        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n        this.research(true);\n      } else {\n        this._decorations.setStartPosition(this._editor.getPosition());\n        this._setCurrentFindMatch(nextMatch.range);\n      }\n    }\n  }\n  _findMatches(findScopes, captureMatches, limitResultCount) {\n    const searchRanges = (findScopes || [null]).map(scope => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches, limitResultCount);\n  }\n  replaceAll() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    const findScopes = this._decorations.getFindScopes();\n    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n      // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n      this._largeReplaceAll();\n    } else {\n      this._regularReplaceAll(findScopes);\n    }\n    this.research(false);\n  }\n  _largeReplaceAll() {\n    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null);\n    const searchData = searchParams.parseSearchRequest();\n    if (!searchData) {\n      return;\n    }\n    let searchRegex = searchData.regex;\n    if (!searchRegex.multiline) {\n      let mod = 'mu';\n      if (searchRegex.ignoreCase) {\n        mod += 'i';\n      }\n      if (searchRegex.global) {\n        mod += 'g';\n      }\n      searchRegex = new RegExp(searchRegex.source, mod);\n    }\n    const model = this._editor.getModel();\n    const modelText = model.getValue(1 /* EndOfLinePreference.LF */);\n    const fullModelRange = model.getFullModelRange();\n    const replacePattern = this._getReplacePattern();\n    let resultText;\n    const preserveCase = this._state.preserveCase;\n    if (replacePattern.hasReplacementPatterns || preserveCase) {\n      resultText = modelText.replace(searchRegex, function () {\n        return replacePattern.buildReplaceString(arguments, preserveCase);\n      });\n    } else {\n      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n    }\n    const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n    this._executeEditorCommand('replaceAll', command);\n  }\n  _regularReplaceAll(findScopes) {\n    const replacePattern = this._getReplacePattern();\n    // Get all the ranges (even more than the highlighted ones)\n    const matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    const replaceStrings = [];\n    for (let i = 0, len = matches.length; i < len; i++) {\n      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n    }\n    const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n    this._executeEditorCommand('replaceAll', command);\n  }\n  selectAllMatches() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    const findScopes = this._decorations.getFindScopes();\n    // Get all the ranges (even more than the highlighted ones)\n    const matches = this._findMatches(findScopes, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n    // If one of the ranges is the editor selection, then maintain it as primary\n    const editorSelection = this._editor.getSelection();\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const sel = selections[i];\n      if (sel.equalsRange(editorSelection)) {\n        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n        break;\n      }\n    }\n    this._editor.setSelections(selections);\n  }\n  _executeEditorCommand(source, command) {\n    try {\n      this._ignoreModelContentChanged = true;\n      this._editor.pushUndoStop();\n      this._editor.executeCommand(source, command);\n      this._editor.pushUndoStop();\n    } finally {\n      this._ignoreModelContentChanged = false;\n    }\n  }\n}","map":{"version":3,"names":["findFirstIdxMonotonousOrArrLen","RunOnceScheduler","TimeoutTimer","DisposableStore","dispose","ReplaceCommand","ReplaceCommandThatPreservesSelection","Position","Range","Selection","SearchParams","FindDecorations","ReplaceAllCommand","parseReplaceString","ReplacePattern","RawContextKey","CONTEXT_FIND_WIDGET_VISIBLE","CONTEXT_FIND_WIDGET_NOT_VISIBLE","toNegated","CONTEXT_FIND_INPUT_FOCUSED","CONTEXT_REPLACE_INPUT_FOCUSED","ToggleCaseSensitiveKeybinding","primary","mac","ToggleWholeWordKeybinding","ToggleRegexKeybinding","ToggleSearchScopeKeybinding","TogglePreserveCaseKeybinding","FIND_IDS","StartFindAction","StartFindWithSelection","StartFindWithArgs","NextMatchFindAction","PreviousMatchFindAction","GoToMatchFindAction","NextSelectionMatchFindAction","PreviousSelectionMatchFindAction","StartFindReplaceAction","CloseFindWidgetCommand","ToggleCaseSensitiveCommand","ToggleWholeWordCommand","ToggleRegexCommand","ToggleSearchScopeCommand","TogglePreserveCaseCommand","ReplaceOneAction","ReplaceAllAction","SelectAllMatchesAction","MATCHES_LIMIT","RESEARCH_DELAY","FindModelBoundToEditorModel","constructor","editor","state","_toDispose","_editor","_state","_isDisposed","_startSearchingTimer","_decorations","add","_updateDecorationsScheduler","research","onDidChangeCursorPosition","e","reason","setStartPosition","getPosition","_ignoreModelContentChanged","onDidChangeModelContent","isFlush","reset","schedule","onFindReplaceStateChange","_onStateChanged","searchScope","hasModel","searchString","isReplaceRevealed","isRegex","wholeWord","matchCase","model","getModel","isTooLargeForSyncing","cancel","setIfNotSet","moveCursor","_getSearchRange","findScope","getFullModelRange","newFindScope","findScopes","Array","isArray","getFindScopes","map","startLineNumber","endLineNumber","endColumn","getLineMaxColumn","findMatches","_findMatches","set","editorSelection","getSelection","currentMatchesPosition","getCurrentMatchesPosition","length","matchAfterSelection","match","range","compareRangesUsingStarts","changeMatchInfo","getCount","undefined","getOption","cursorMoveOnType","_moveToNextMatch","getStartPosition","_hasMatches","matchesCount","_cannotFind","getFindScope","revealRangeInCenterIfOutsideViewport","_setCurrentFindMatch","matchesPosition","setCurrentFindMatch","setSelection","_prevSearchPosition","before","isUsingLineStops","indexOf","lineNumber","column","getLineCount","_moveToPrevMatch","isRecursed","canNavigateBack","nextMatchRange","matchAfterPosition","prevMatchRange","matchBeforePosition","isEmpty","equals","searchRange","getEndPosition","isBefore","position","prevMatch","findPreviousMatch","containsRange","moveToPrevMatch","_nextSearchPosition","after","canNavigateForward","nextMatch","_getNextMatch","captureMatches","forceMove","findNextMatch","moveToNextMatch","_moveToMatch","index","decorationRange","getDecorationRangeAt","moveToMatch","_getReplacePattern","replaceString","fromStaticValue","replace","replacePattern","selection","equalsRange","buildReplaceString","matches","preserveCase","command","_executeEditorCommand","startColumn","limitResultCount","searchRanges","scope","replaceAll","_largeReplaceAll","_regularReplaceAll","searchParams","searchData","parseSearchRequest","searchRegex","regex","multiline","mod","ignoreCase","global","RegExp","source","modelText","getValue","fullModelRange","resultText","hasReplacementPatterns","arguments","replaceStrings","i","len","m","selectAllMatches","selections","sel","concat","slice","setSelections","pushUndoStop","executeCommand"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\nimport { RunOnceScheduler, TimeoutTimer } from '../../../../base/common/async.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../../common/commands/replaceCommand.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { SearchParams } from '../../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { parseReplaceString, ReplacePattern } from './replacePattern.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\nexport const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();\n// Keep ContextKey use of 'Focussed' to not break when clauses\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 33 /* KeyCode.KeyC */ }\n};\nexport const ToggleWholeWordKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 53 /* KeyCode.KeyW */ }\n};\nexport const ToggleRegexKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 48 /* KeyCode.KeyR */ }\n};\nexport const ToggleSearchScopeKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 42 /* KeyCode.KeyL */ }\n};\nexport const TogglePreserveCaseKeybinding = {\n    primary: 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */,\n    mac: { primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 46 /* KeyCode.KeyP */ }\n};\nexport const FIND_IDS = {\n    StartFindAction: 'actions.find',\n    StartFindWithSelection: 'actions.findWithSelection',\n    StartFindWithArgs: 'editor.actions.findWithArgs',\n    NextMatchFindAction: 'editor.action.nextMatchFindAction',\n    PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n    GoToMatchFindAction: 'editor.action.goToMatchFindAction',\n    NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n    PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n    StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n    CloseFindWidgetCommand: 'closeFindWidget',\n    ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n    ToggleWholeWordCommand: 'toggleFindWholeWord',\n    ToggleRegexCommand: 'toggleFindRegex',\n    ToggleSearchScopeCommand: 'toggleFindInSelection',\n    TogglePreserveCaseCommand: 'togglePreserveCase',\n    ReplaceOneAction: 'editor.action.replaceOne',\n    ReplaceAllAction: 'editor.action.replaceAll',\n    SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n    constructor(editor, state) {\n        this._toDispose = new DisposableStore();\n        this._editor = editor;\n        this._state = state;\n        this._isDisposed = false;\n        this._startSearchingTimer = new TimeoutTimer();\n        this._decorations = new FindDecorations(editor);\n        this._toDispose.add(this._decorations);\n        this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n        this._toDispose.add(this._updateDecorationsScheduler);\n        this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {\n            if (e.reason === 3 /* CursorChangeReason.Explicit */\n                || e.reason === 5 /* CursorChangeReason.Undo */\n                || e.reason === 6 /* CursorChangeReason.Redo */) {\n                this._decorations.setStartPosition(this._editor.getPosition());\n            }\n        }));\n        this._ignoreModelContentChanged = false;\n        this._toDispose.add(this._editor.onDidChangeModelContent((e) => {\n            if (this._ignoreModelContentChanged) {\n                return;\n            }\n            if (e.isFlush) {\n                // a model.setValue() was called\n                this._decorations.reset();\n            }\n            this._decorations.setStartPosition(this._editor.getPosition());\n            this._updateDecorationsScheduler.schedule();\n        }));\n        this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this.research(false, this._state.searchScope);\n    }\n    dispose() {\n        this._isDisposed = true;\n        dispose(this._startSearchingTimer);\n        this._toDispose.dispose();\n    }\n    _onStateChanged(e) {\n        if (this._isDisposed) {\n            // The find model is disposed during a find state changed event\n            return;\n        }\n        if (!this._editor.hasModel()) {\n            // The find model will be disposed momentarily\n            return;\n        }\n        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n            const model = this._editor.getModel();\n            if (model.isTooLargeForSyncing()) {\n                this._startSearchingTimer.cancel();\n                this._startSearchingTimer.setIfNotSet(() => {\n                    if (e.searchScope) {\n                        this.research(e.moveCursor, this._state.searchScope);\n                    }\n                    else {\n                        this.research(e.moveCursor);\n                    }\n                }, RESEARCH_DELAY);\n            }\n            else {\n                if (e.searchScope) {\n                    this.research(e.moveCursor, this._state.searchScope);\n                }\n                else {\n                    this.research(e.moveCursor);\n                }\n            }\n        }\n    }\n    static _getSearchRange(model, findScope) {\n        // If we have set now or before a find scope, use it for computing the search range\n        if (findScope) {\n            return findScope;\n        }\n        return model.getFullModelRange();\n    }\n    research(moveCursor, newFindScope) {\n        let findScopes = null;\n        if (typeof newFindScope !== 'undefined') {\n            if (newFindScope !== null) {\n                if (!Array.isArray(newFindScope)) {\n                    findScopes = [newFindScope];\n                }\n                else {\n                    findScopes = newFindScope;\n                }\n            }\n        }\n        else {\n            findScopes = this._decorations.getFindScopes();\n        }\n        if (findScopes !== null) {\n            findScopes = findScopes.map(findScope => {\n                if (findScope.startLineNumber !== findScope.endLineNumber) {\n                    let endLineNumber = findScope.endLineNumber;\n                    if (findScope.endColumn === 1) {\n                        endLineNumber = endLineNumber - 1;\n                    }\n                    return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n                }\n                return findScope;\n            });\n        }\n        const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n        this._decorations.set(findMatches, findScopes);\n        const editorSelection = this._editor.getSelection();\n        let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n        if (currentMatchesPosition === 0 && findMatches.length > 0) {\n            // current selection is not on top of a match\n            // try to find its nearest result from the top of the document\n            const matchAfterSelection = findFirstIdxMonotonousOrArrLen(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n            currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\n        }\n        this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n        if (moveCursor && this._editor.getOption(41 /* EditorOption.find */).cursorMoveOnType) {\n            this._moveToNextMatch(this._decorations.getStartPosition());\n        }\n    }\n    _hasMatches() {\n        return (this._state.matchesCount > 0);\n    }\n    _cannotFind() {\n        if (!this._hasMatches()) {\n            const findScope = this._decorations.getFindScope();\n            if (findScope) {\n                // Reveal the selection so user is reminded that 'selection find' is on.\n                this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* ScrollType.Smooth */);\n            }\n            return true;\n        }\n        return false;\n    }\n    _setCurrentFindMatch(match) {\n        const matchesPosition = this._decorations.setCurrentFindMatch(match);\n        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n        this._editor.setSelection(match);\n        this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* ScrollType.Smooth */);\n    }\n    _prevSearchPosition(before) {\n        const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = before;\n        const model = this._editor.getModel();\n        if (isUsingLineStops || column === 1) {\n            if (lineNumber === 1) {\n                lineNumber = model.getLineCount();\n            }\n            else {\n                lineNumber--;\n            }\n            column = model.getLineMaxColumn(lineNumber);\n        }\n        else {\n            column--;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToPrevMatch(before, isRecursed = false) {\n        if (!this._state.canNavigateBack()) {\n            // we are beyond the first matched find result\n            // instead of doing nothing, we should refocus the first item\n            const nextMatchRange = this._decorations.matchAfterPosition(before);\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let prevMatchRange = this._decorations.matchBeforePosition(before);\n            if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n                before = this._prevSearchPosition(before);\n                prevMatchRange = this._decorations.matchBeforePosition(before);\n            }\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._cannotFind()) {\n            return;\n        }\n        const findScope = this._decorations.getFindScope();\n        const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(before)) {\n            before = searchRange.getEndPosition();\n        }\n        // ...|...(----)...\n        if (before.isBefore(searchRange.getStartPosition())) {\n            before = searchRange.getEndPosition();\n        }\n        const { lineNumber, column } = before;\n        const model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, false);\n        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._prevSearchPosition(position);\n            prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, false);\n        }\n        if (!prevMatch) {\n            // there is precisely one match and selection is on top of it\n            return;\n        }\n        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n            return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n        }\n        this._setCurrentFindMatch(prevMatch.range);\n    }\n    moveToPrevMatch() {\n        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n    }\n    _nextSearchPosition(after) {\n        const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = after;\n        const model = this._editor.getModel();\n        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber === model.getLineCount()) {\n                lineNumber = 1;\n            }\n            else {\n                lineNumber++;\n            }\n            column = 1;\n        }\n        else {\n            column++;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToNextMatch(after) {\n        if (!this._state.canNavigateForward()) {\n            // we are beyond the last matched find result\n            // instead of doing nothing, we should refocus the last item\n            const prevMatchRange = this._decorations.matchBeforePosition(after);\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let nextMatchRange = this._decorations.matchAfterPosition(after);\n            if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n                // Looks like we're stuck at this position, unacceptable!\n                after = this._nextSearchPosition(after);\n                nextMatchRange = this._decorations.matchAfterPosition(after);\n            }\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        const nextMatch = this._getNextMatch(after, false, true);\n        if (nextMatch) {\n            this._setCurrentFindMatch(nextMatch.range);\n        }\n    }\n    _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n        if (this._cannotFind()) {\n            return null;\n        }\n        const findScope = this._decorations.getFindScope();\n        const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(after)) {\n            after = searchRange.getStartPosition();\n        }\n        // ...|...(----)...\n        if (after.isBefore(searchRange.getStartPosition())) {\n            after = searchRange.getStartPosition();\n        }\n        const { lineNumber, column } = after;\n        const model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches);\n        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._nextSearchPosition(position);\n            nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches);\n        }\n        if (!nextMatch) {\n            // there is precisely one match and selection is on top of it\n            return null;\n        }\n        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n            return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n        }\n        return nextMatch;\n    }\n    moveToNextMatch() {\n        this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n    }\n    _moveToMatch(index) {\n        const decorationRange = this._decorations.getDecorationRangeAt(index);\n        if (decorationRange) {\n            this._setCurrentFindMatch(decorationRange);\n        }\n    }\n    moveToMatch(index) {\n        this._moveToMatch(index);\n    }\n    _getReplacePattern() {\n        if (this._state.isRegex) {\n            return parseReplaceString(this._state.replaceString);\n        }\n        return ReplacePattern.fromStaticValue(this._state.replaceString);\n    }\n    replace() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const replacePattern = this._getReplacePattern();\n        const selection = this._editor.getSelection();\n        const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n        if (nextMatch) {\n            if (selection.equalsRange(nextMatch.range)) {\n                // selection sits on a find match => replace it!\n                const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n                const command = new ReplaceCommand(selection, replaceString);\n                this._executeEditorCommand('replace', command);\n                this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n                this.research(true);\n            }\n            else {\n                this._decorations.setStartPosition(this._editor.getPosition());\n                this._setCurrentFindMatch(nextMatch.range);\n            }\n        }\n    }\n    _findMatches(findScopes, captureMatches, limitResultCount) {\n        const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n        return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null, captureMatches, limitResultCount);\n    }\n    replaceAll() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const findScopes = this._decorations.getFindScopes();\n        if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n            // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n            this._largeReplaceAll();\n        }\n        else {\n            this._regularReplaceAll(findScopes);\n        }\n        this.research(false);\n    }\n    _largeReplaceAll() {\n        const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(129 /* EditorOption.wordSeparators */) : null);\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return;\n        }\n        let searchRegex = searchData.regex;\n        if (!searchRegex.multiline) {\n            let mod = 'mu';\n            if (searchRegex.ignoreCase) {\n                mod += 'i';\n            }\n            if (searchRegex.global) {\n                mod += 'g';\n            }\n            searchRegex = new RegExp(searchRegex.source, mod);\n        }\n        const model = this._editor.getModel();\n        const modelText = model.getValue(1 /* EndOfLinePreference.LF */);\n        const fullModelRange = model.getFullModelRange();\n        const replacePattern = this._getReplacePattern();\n        let resultText;\n        const preserveCase = this._state.preserveCase;\n        if (replacePattern.hasReplacementPatterns || preserveCase) {\n            resultText = modelText.replace(searchRegex, function () {\n                return replacePattern.buildReplaceString(arguments, preserveCase);\n            });\n        }\n        else {\n            resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n        }\n        const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n        this._executeEditorCommand('replaceAll', command);\n    }\n    _regularReplaceAll(findScopes) {\n        const replacePattern = this._getReplacePattern();\n        // Get all the ranges (even more than the highlighted ones)\n        const matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        const replaceStrings = [];\n        for (let i = 0, len = matches.length; i < len; i++) {\n            replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n        }\n        const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n        this._executeEditorCommand('replaceAll', command);\n    }\n    selectAllMatches() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const findScopes = this._decorations.getFindScopes();\n        // Get all the ranges (even more than the highlighted ones)\n        const matches = this._findMatches(findScopes, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n        // If one of the ranges is the editor selection, then maintain it as primary\n        const editorSelection = this._editor.getSelection();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const sel = selections[i];\n            if (sel.equalsRange(editorSelection)) {\n                selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n                break;\n            }\n        }\n        this._editor.setSelections(selections);\n    }\n    _executeEditorCommand(source, command) {\n        try {\n            this._ignoreModelContentChanged = true;\n            this._editor.pushUndoStop();\n            this._editor.executeCommand(source, command);\n            this._editor.pushUndoStop();\n        }\n        finally {\n            this._ignoreModelContentChanged = false;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}