{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n  constructor(lines, lineRange, considerWhitespaceChanges) {\n    // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n    // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n    this.lines = lines;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstCharOffsetByLine = [];\n    // To account for trimming\n    this.additionalOffsetByLine = [];\n    // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n    let trimFirstLineFully = false;\n    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n      trimFirstLineFully = true;\n    }\n    this.lineRange = lineRange;\n    this.firstCharOffsetByLine[0] = 0;\n    for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n      let line = lines[i];\n      let offset = 0;\n      if (trimFirstLineFully) {\n        offset = line.length;\n        line = '';\n        trimFirstLineFully = false;\n      } else if (!considerWhitespaceChanges) {\n        const trimmedStartLine = line.trimStart();\n        offset = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.additionalOffsetByLine.push(offset);\n      for (let i = 0; i < line.length; i++) {\n        this.elements.push(line.charCodeAt(i));\n      }\n      // Don't add an \\n that does not exist in the document.\n      if (i < lines.length - 1) {\n        this.elements.push('\\n'.charCodeAt(0));\n        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n      }\n    }\n    // To account for the last line\n    this.additionalOffsetByLine.push(0);\n  }\n  toString() {\n    return `Slice: \"${this.text}\"`;\n  }\n  get text() {\n    return this.getText(new OffsetRange(0, this.length));\n  }\n  getText(range) {\n    return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    //   a   b   c   ,           d   e   f\n    // 11  0   0   12  15  6   13  0   0   11\n    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n      // don't break between \\r and \\n\n      return 0;\n    }\n    let score = 0;\n    if (prevCategory !== nextCategory) {\n      score += 10;\n      if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n        score += 1;\n      }\n    }\n    score += getCategoryBoundaryScore(prevCategory);\n    score += getCategoryBoundaryScore(nextCategory);\n    return score;\n  }\n  translateOffset(offset) {\n    // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n    if (this.lineRange.isEmpty) {\n      return new Position(this.lineRange.start + 1, 1);\n    }\n    const i = findLastIdxMonotonous(this.firstCharOffsetByLine, value => value <= offset);\n    return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n  }\n  translateRange(range) {\n    return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n  }\n  /**\n   * Finds the word that contains the character at the given offset\n   */\n  findWordContaining(offset) {\n    if (offset < 0 || offset >= this.elements.length) {\n      return undefined;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return undefined;\n    }\n    // find start\n    let start = offset;\n    while (start > 0 && isWordChar(this.elements[start - 1])) {\n      start--;\n    }\n    // find end\n    let end = offset;\n    while (end < this.elements.length && isWordChar(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  countLinesIn(range) {\n    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.elements[offset1] === this.elements[offset2];\n  }\n  extendToFullLines(range) {\n    var _a, _b;\n    const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n    const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n    return new OffsetRange(start, end);\n  }\n}\nfunction isWordChar(charCode) {\n  return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */ || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */ || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n  [0 /* CharBoundaryCategory.WordLower */]: 0,\n  [1 /* CharBoundaryCategory.WordUpper */]: 0,\n  [2 /* CharBoundaryCategory.WordNumber */]: 0,\n  [3 /* CharBoundaryCategory.End */]: 10,\n  [4 /* CharBoundaryCategory.Other */]: 2,\n  [5 /* CharBoundaryCategory.Separator */]: 3,\n  [6 /* CharBoundaryCategory.Space */]: 3,\n  [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n  [8 /* CharBoundaryCategory.LineBreakLF */]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10 /* CharCode.LineFeed */) {\n    return 8 /* CharBoundaryCategory.LineBreakLF */;\n  } else if (charCode === 13 /* CharCode.CarriageReturn */) {\n    return 7 /* CharBoundaryCategory.LineBreakCR */;\n  } else if (isSpace(charCode)) {\n    return 6 /* CharBoundaryCategory.Space */;\n  } else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n    return 0 /* CharBoundaryCategory.WordLower */;\n  } else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n    return 1 /* CharBoundaryCategory.WordUpper */;\n  } else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n    return 2 /* CharBoundaryCategory.WordNumber */;\n  } else if (charCode === -1) {\n    return 3 /* CharBoundaryCategory.End */;\n  } else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n    return 5 /* CharBoundaryCategory.Separator */;\n  } else {\n    return 4 /* CharBoundaryCategory.Other */;\n  }\n}","map":{"version":3,"names":["findLastIdxMonotonous","findLastMonotonous","findFirstMonotonous","OffsetRange","Position","Range","isSpace","LinesSliceCharSequence","constructor","lines","lineRange","considerWhitespaceChanges","elements","firstCharOffsetByLine","additionalOffsetByLine","trimFirstLineFully","start","endExclusive","length","i","line","offset","trimmedStartLine","trimStart","trimEnd","push","charCodeAt","toString","text","getText","range","slice","map","e","String","fromCharCode","join","getElement","getBoundaryScore","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","isEmpty","value","translateRange","fromPositions","findWordContaining","undefined","isWordChar","end","countLinesIn","lineNumber","isStronglyEqual","offset1","offset2","extendToFullLines","_a","_b","x","charCode","category"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 3,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}