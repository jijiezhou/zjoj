{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { getWindow, scheduleAtNextAnimationFrame } from '../../../base/browser/dom.js';\nexport class ElementSizeObserver extends Disposable {\n  constructor(referenceDomElement, dimension) {\n    super();\n    this._onDidChange = this._register(new Emitter());\n    this.onDidChange = this._onDidChange.event;\n    this._referenceDomElement = referenceDomElement;\n    this._width = -1;\n    this._height = -1;\n    this._resizeObserver = null;\n    this.measureReferenceDomElement(false, dimension);\n  }\n  dispose() {\n    this.stopObserving();\n    super.dispose();\n  }\n  getWidth() {\n    return this._width;\n  }\n  getHeight() {\n    return this._height;\n  }\n  startObserving() {\n    if (!this._resizeObserver && this._referenceDomElement) {\n      // We want to react to the resize observer only once per animation frame\n      // The first time the resize observer fires, we will react to it immediately.\n      // Otherwise we will postpone to the next animation frame.\n      // We'll use `observeContentRect` to store the content rect we received.\n      let observeContentRect = null;\n      const observeNow = () => {\n        if (observeContentRect) {\n          this.observe({\n            width: observeContentRect.width,\n            height: observeContentRect.height\n          });\n        } else {\n          this.observe();\n        }\n      };\n      let shouldObserve = false;\n      let alreadyObservedThisAnimationFrame = false;\n      const update = () => {\n        if (shouldObserve && !alreadyObservedThisAnimationFrame) {\n          try {\n            shouldObserve = false;\n            alreadyObservedThisAnimationFrame = true;\n            observeNow();\n          } finally {\n            scheduleAtNextAnimationFrame(getWindow(this._referenceDomElement), () => {\n              alreadyObservedThisAnimationFrame = false;\n              update();\n            });\n          }\n        }\n      };\n      this._resizeObserver = new ResizeObserver(entries => {\n        observeContentRect = entries && entries[0] && entries[0].contentRect ? entries[0].contentRect : null;\n        shouldObserve = true;\n        update();\n      });\n      this._resizeObserver.observe(this._referenceDomElement);\n    }\n  }\n  stopObserving() {\n    if (this._resizeObserver) {\n      this._resizeObserver.disconnect();\n      this._resizeObserver = null;\n    }\n  }\n  observe(dimension) {\n    this.measureReferenceDomElement(true, dimension);\n  }\n  measureReferenceDomElement(emitEvent, dimension) {\n    let observedWidth = 0;\n    let observedHeight = 0;\n    if (dimension) {\n      observedWidth = dimension.width;\n      observedHeight = dimension.height;\n    } else if (this._referenceDomElement) {\n      observedWidth = this._referenceDomElement.clientWidth;\n      observedHeight = this._referenceDomElement.clientHeight;\n    }\n    observedWidth = Math.max(5, observedWidth);\n    observedHeight = Math.max(5, observedHeight);\n    if (this._width !== observedWidth || this._height !== observedHeight) {\n      this._width = observedWidth;\n      this._height = observedHeight;\n      if (emitEvent) {\n        this._onDidChange.fire();\n      }\n    }\n  }\n}","map":{"version":3,"names":["Disposable","Emitter","getWindow","scheduleAtNextAnimationFrame","ElementSizeObserver","constructor","referenceDomElement","dimension","_onDidChange","_register","onDidChange","event","_referenceDomElement","_width","_height","_resizeObserver","measureReferenceDomElement","dispose","stopObserving","getWidth","getHeight","startObserving","observeContentRect","observeNow","observe","width","height","shouldObserve","alreadyObservedThisAnimationFrame","update","ResizeObserver","entries","contentRect","disconnect","emitEvent","observedWidth","observedHeight","clientWidth","clientHeight","Math","max","fire"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/config/elementSizeObserver.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { getWindow, scheduleAtNextAnimationFrame } from '../../../base/browser/dom.js';\nexport class ElementSizeObserver extends Disposable {\n    constructor(referenceDomElement, dimension) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._referenceDomElement = referenceDomElement;\n        this._width = -1;\n        this._height = -1;\n        this._resizeObserver = null;\n        this.measureReferenceDomElement(false, dimension);\n    }\n    dispose() {\n        this.stopObserving();\n        super.dispose();\n    }\n    getWidth() {\n        return this._width;\n    }\n    getHeight() {\n        return this._height;\n    }\n    startObserving() {\n        if (!this._resizeObserver && this._referenceDomElement) {\n            // We want to react to the resize observer only once per animation frame\n            // The first time the resize observer fires, we will react to it immediately.\n            // Otherwise we will postpone to the next animation frame.\n            // We'll use `observeContentRect` to store the content rect we received.\n            let observeContentRect = null;\n            const observeNow = () => {\n                if (observeContentRect) {\n                    this.observe({ width: observeContentRect.width, height: observeContentRect.height });\n                }\n                else {\n                    this.observe();\n                }\n            };\n            let shouldObserve = false;\n            let alreadyObservedThisAnimationFrame = false;\n            const update = () => {\n                if (shouldObserve && !alreadyObservedThisAnimationFrame) {\n                    try {\n                        shouldObserve = false;\n                        alreadyObservedThisAnimationFrame = true;\n                        observeNow();\n                    }\n                    finally {\n                        scheduleAtNextAnimationFrame(getWindow(this._referenceDomElement), () => {\n                            alreadyObservedThisAnimationFrame = false;\n                            update();\n                        });\n                    }\n                }\n            };\n            this._resizeObserver = new ResizeObserver((entries) => {\n                observeContentRect = (entries && entries[0] && entries[0].contentRect ? entries[0].contentRect : null);\n                shouldObserve = true;\n                update();\n            });\n            this._resizeObserver.observe(this._referenceDomElement);\n        }\n    }\n    stopObserving() {\n        if (this._resizeObserver) {\n            this._resizeObserver.disconnect();\n            this._resizeObserver = null;\n        }\n    }\n    observe(dimension) {\n        this.measureReferenceDomElement(true, dimension);\n    }\n    measureReferenceDomElement(emitEvent, dimension) {\n        let observedWidth = 0;\n        let observedHeight = 0;\n        if (dimension) {\n            observedWidth = dimension.width;\n            observedHeight = dimension.height;\n        }\n        else if (this._referenceDomElement) {\n            observedWidth = this._referenceDomElement.clientWidth;\n            observedHeight = this._referenceDomElement.clientHeight;\n        }\n        observedWidth = Math.max(5, observedWidth);\n        observedHeight = Math.max(5, observedHeight);\n        if (this._width !== observedWidth || this._height !== observedHeight) {\n            this._width = observedWidth;\n            this._height = observedHeight;\n            if (emitEvent) {\n                this._onDidChange.fire();\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}