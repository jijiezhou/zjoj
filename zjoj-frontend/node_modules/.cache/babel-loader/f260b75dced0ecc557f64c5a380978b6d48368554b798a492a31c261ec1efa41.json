{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n  constructor(token, index, fontStyle, foreground, background) {\n    this._parsedThemeRuleBrand = undefined;\n    this.token = token;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n  if (!source || !Array.isArray(source)) {\n    return [];\n  }\n  const result = [];\n  let resultLen = 0;\n  for (let i = 0, len = source.length; i < len; i++) {\n    const entry = source[i];\n    let fontStyle = -1 /* FontStyle.NotSet */;\n    if (typeof entry.fontStyle === 'string') {\n      fontStyle = 0 /* FontStyle.None */;\n      const segments = entry.fontStyle.split(' ');\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        const segment = segments[j];\n        switch (segment) {\n          case 'italic':\n            fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n            break;\n          case 'bold':\n            fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n            break;\n          case 'underline':\n            fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n            break;\n          case 'strikethrough':\n            fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.foreground === 'string') {\n      foreground = entry.foreground;\n    }\n    let background = null;\n    if (typeof entry.background === 'string') {\n      background = entry.background;\n    }\n    result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n  }\n  return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n  // Sort rules lexicographically, and then by index if necessary\n  parsedThemeRules.sort((a, b) => {\n    const r = strcmp(a.token, b.token);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  // Determine defaults\n  let defaultFontStyle = 0 /* FontStyle.None */;\n  let defaultForeground = '000000';\n  let defaultBackground = 'ffffff';\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n    const incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  const colorMap = new ColorMap();\n  // start with token colors from custom token themes\n  for (const color of customTokenColors) {\n    colorMap.getId(color);\n  }\n  const foregroundColorId = colorMap.getId(defaultForeground);\n  const backgroundColorId = colorMap.getId(defaultBackground);\n  const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n  const root = new ThemeTrieElement(defaults);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    const rule = parsedThemeRules[i];\n    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n  constructor() {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = new Map();\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    const match = color.match(colorRegExp);\n    if (!match) {\n      throw new Error('Illegal value for token color: ' + color);\n    }\n    color = match[1].toUpperCase();\n    let value = this._color2id.get(color);\n    if (value) {\n      return value;\n    }\n    value = ++this._lastColorId;\n    this._color2id.set(color, value);\n    this._id2color[value] = Color.fromHex('#' + color);\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n}\nexport class TokenTheme {\n  static createFromRawTokenTheme(source, customTokenColors) {\n    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n  }\n  static createFromParsedTokenTheme(source, customTokenColors) {\n    return resolveParsedTokenThemeRules(source, customTokenColors);\n  }\n  constructor(colorMap, root) {\n    this._colorMap = colorMap;\n    this._root = root;\n    this._cache = new Map();\n  }\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  _match(token) {\n    return this._root.match(token);\n  }\n  match(languageId, token) {\n    // The cache contains the metadata without the language bits set.\n    let result = this._cache.get(token);\n    if (typeof result === 'undefined') {\n      const rule = this._match(token);\n      const standardToken = toStandardTokenType(token);\n      result = (rule.metadata | standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */) >>> 0;\n      this._cache.set(token, result);\n    }\n    return (result | languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */) >>> 0;\n  }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n  const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n  if (!m) {\n    return 0 /* StandardTokenType.Other */;\n  }\n  switch (m[1]) {\n    case 'comment':\n      return 1 /* StandardTokenType.Comment */;\n    case 'string':\n      return 2 /* StandardTokenType.String */;\n    case 'regex':\n      return 3 /* StandardTokenType.RegEx */;\n    case 'regexp':\n      return 3 /* StandardTokenType.RegEx */;\n  }\n  throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nexport class ThemeTrieElementRule {\n  constructor(fontStyle, foreground, background) {\n    this._themeTrieElementRuleBrand = undefined;\n    this._fontStyle = fontStyle;\n    this._foreground = foreground;\n    this._background = background;\n    this.metadata = (this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */) >>> 0;\n  }\n  clone() {\n    return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n  }\n  acceptOverwrite(fontStyle, foreground, background) {\n    if (fontStyle !== -1 /* FontStyle.NotSet */) {\n      this._fontStyle = fontStyle;\n    }\n    if (foreground !== 0 /* ColorId.None */) {\n      this._foreground = foreground;\n    }\n    if (background !== 0 /* ColorId.None */) {\n      this._background = background;\n    }\n    this.metadata = (this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */) >>> 0;\n  }\n}\nexport class ThemeTrieElement {\n  constructor(mainRule) {\n    this._themeTrieElementBrand = undefined;\n    this._mainRule = mainRule;\n    this._children = new Map();\n  }\n  match(token) {\n    if (token === '') {\n      return this._mainRule;\n    }\n    const dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n    const child = this._children.get(head);\n    if (typeof child !== 'undefined') {\n      return child.match(tail);\n    }\n    return this._mainRule;\n  }\n  insert(token, fontStyle, foreground, background) {\n    if (token === '') {\n      // Merge into the main rule\n      this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n      return;\n    }\n    const dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n    let child = this._children.get(head);\n    if (typeof child === 'undefined') {\n      child = new ThemeTrieElement(this._mainRule.clone());\n      this._children.set(head, child);\n    }\n    child.insert(tail, fontStyle, foreground, background);\n  }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n  const rules = [];\n  for (let i = 1, len = colorMap.length; i < len; i++) {\n    const color = colorMap[i];\n    rules[i] = `.mtk${i} { color: ${color}; }`;\n  }\n  rules.push('.mtki { font-style: italic; }');\n  rules.push('.mtkb { font-weight: bold; }');\n  rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n  rules.push('.mtks { text-decoration: line-through; }');\n  rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n  return rules.join('\\n');\n}","map":{"version":3,"names":["Color","ParsedTokenThemeRule","constructor","token","index","fontStyle","foreground","background","_parsedThemeRuleBrand","undefined","parseTokenTheme","source","Array","isArray","result","resultLen","i","len","length","entry","segments","split","j","lenJ","segment","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","sort","a","b","r","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","colorMap","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","rule","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","Map","match","Error","toUpperCase","value","get","set","fromHex","getColorMap","slice","createFromRawTokenTheme","createFromParsedTokenTheme","_colorMap","_root","_cache","_match","languageId","standardToken","toStandardTokenType","metadata","STANDARD_TOKEN_TYPE_REGEXP","tokenType","m","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","clone","acceptOverwrite","mainRule","_themeTrieElementBrand","_mainRule","_children","dotIndex","indexOf","head","tail","substring","child","generateTokensCSSForColorMap","rules","push","join"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}