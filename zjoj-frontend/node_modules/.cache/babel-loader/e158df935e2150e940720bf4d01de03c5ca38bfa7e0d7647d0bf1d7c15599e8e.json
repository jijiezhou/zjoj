{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n  static computeUnicodeHighlights(model, options, range) {\n    const startLine = range ? range.startLineNumber : 1;\n    const endLine = range ? range.endLineNumber : model.getLineCount();\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const candidates = codePointHighlighter.getCandidateCodePoints();\n    let regex;\n    if (candidates === 'allNonBasicAscii') {\n      regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n    } else {\n      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n    }\n    const searcher = new Searcher(null, regex);\n    const ranges = [];\n    let hasMore = false;\n    let m;\n    let ambiguousCharacterCount = 0;\n    let invisibleCharacterCount = 0;\n    let nonBasicAsciiCharacterCount = 0;\n    forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n      const lineContent = model.getLineContent(lineNumber);\n      const lineLength = lineContent.length;\n      // Reset regex to search from the beginning\n      searcher.reset(0);\n      do {\n        m = searcher.next(lineContent);\n        if (m) {\n          let startIndex = m.index;\n          let endIndex = m.index + m[0].length;\n          // Extend range to entire code point\n          if (startIndex > 0) {\n            const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n              startIndex--;\n            }\n          }\n          if (endIndex + 1 < lineLength) {\n            const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n              endIndex++;\n            }\n          }\n          const str = lineContent.substring(startIndex, endIndex);\n          let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n          if (word && word.endColumn <= startIndex + 1) {\n            // The word does not include the problematic character, ignore the word\n            word = null;\n          }\n          const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n          if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n            if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n              ambiguousCharacterCount++;\n            } else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n              invisibleCharacterCount++;\n            } else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n              nonBasicAsciiCharacterCount++;\n            } else {\n              assertNever(highlightReason);\n            }\n            const MAX_RESULT_LENGTH = 1000;\n            if (ranges.length >= MAX_RESULT_LENGTH) {\n              hasMore = true;\n              break forLoop;\n            }\n            ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n          }\n        }\n      } while (m);\n    }\n    return {\n      ranges,\n      hasMore,\n      ambiguousCharacterCount,\n      invisibleCharacterCount,\n      nonBasicAsciiCharacterCount\n    };\n  }\n  static computeUnicodeHighlightReason(char, options) {\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n    switch (reason) {\n      case 0 /* SimpleHighlightReason.None */:\n        return null;\n      case 2 /* SimpleHighlightReason.Invisible */:\n        return {\n          kind: 1 /* UnicodeHighlighterReasonKind.Invisible */\n        };\n      case 3 /* SimpleHighlightReason.Ambiguous */:\n        {\n          const codePoint = char.codePointAt(0);\n          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n          const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter(l => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n          return {\n            kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */,\n            confusableWith: String.fromCodePoint(primaryConfusable),\n            notAmbiguousInLocales\n          };\n        }\n      case 1 /* SimpleHighlightReason.NonBasicASCII */:\n        return {\n          kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */\n        };\n    }\n  }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n  const src = `[${strings.escapeRegExpCharacters(codePoints.map(i => String.fromCodePoint(i)).join(''))}]`;\n  return src;\n}\nclass CodePointHighlighter {\n  constructor(options) {\n    this.options = options;\n    this.allowedCodePoints = new Set(options.allowedCodePoints);\n    this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n  }\n  getCandidateCodePoints() {\n    if (this.options.nonBasicASCII) {\n      return 'allNonBasicAscii';\n    }\n    const set = new Set();\n    if (this.options.invisibleCharacters) {\n      for (const cp of strings.InvisibleCharacters.codePoints) {\n        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n          set.add(cp);\n        }\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n        set.add(cp);\n      }\n    }\n    for (const cp of this.allowedCodePoints) {\n      set.delete(cp);\n    }\n    return set;\n  }\n  shouldHighlightNonBasicASCII(character, wordContext) {\n    const codePoint = character.codePointAt(0);\n    if (this.allowedCodePoints.has(codePoint)) {\n      return 0 /* SimpleHighlightReason.None */;\n    }\n    if (this.options.nonBasicASCII) {\n      return 1 /* SimpleHighlightReason.NonBasicASCII */;\n    }\n    let hasBasicASCIICharacters = false;\n    let hasNonConfusableNonBasicAsciiCharacter = false;\n    if (wordContext) {\n      for (const char of wordContext) {\n        const codePoint = char.codePointAt(0);\n        const isBasicASCII = strings.isBasicASCII(char);\n        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n        if (!isBasicASCII && !this.ambiguousCharacters.isAmbiguous(codePoint) && !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n          hasNonConfusableNonBasicAsciiCharacter = true;\n        }\n      }\n    }\n    if ( /* Don't allow mixing weird looking characters with ASCII */!hasBasicASCIICharacters && /* Is there an obviously weird looking character? */hasNonConfusableNonBasicAsciiCharacter) {\n      return 0 /* SimpleHighlightReason.None */;\n    }\n    if (this.options.invisibleCharacters) {\n      // TODO check for emojis\n      if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n        return 2 /* SimpleHighlightReason.Invisible */;\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n        return 3 /* SimpleHighlightReason.Ambiguous */;\n      }\n    }\n    return 0 /* SimpleHighlightReason.None */;\n  }\n}\nfunction isAllowedInvisibleCharacter(character) {\n  return character === ' ' || character === '\\n' || character === '\\t';\n}","map":{"version":3,"names":["Range","Searcher","strings","assertNever","DEFAULT_WORD_REGEXP","getWordAtText","UnicodeTextModelHighlighter","computeUnicodeHighlights","model","options","range","startLine","startLineNumber","endLine","endLineNumber","getLineCount","codePointHighlighter","CodePointHighlighter","candidates","getCandidateCodePoints","regex","RegExp","buildRegExpCharClassExpr","Array","from","searcher","ranges","hasMore","m","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","lineNumber","lineCount","lineContent","getLineContent","lineLength","length","reset","next","startIndex","index","endIndex","charCodeBefore","charCodeAt","isHighSurrogate","str","substring","word","endColumn","highlightReason","shouldHighlightNonBasicASCII","MAX_RESULT_LENGTH","push","computeUnicodeHighlightReason","char","reason","kind","codePoint","codePointAt","primaryConfusable","ambiguousCharacters","getPrimaryConfusable","notAmbiguousInLocales","AmbiguousCharacters","getLocales","filter","l","getInstance","Set","allowedLocales","isAmbiguous","confusableWith","String","fromCodePoint","codePoints","flags","src","escapeRegExpCharacters","map","i","join","constructor","allowedCodePoints","nonBasicASCII","set","invisibleCharacters","cp","InvisibleCharacters","isAllowedInvisibleCharacter","add","getConfusableCodePoints","delete","character","wordContext","has","hasBasicASCIICharacters","hasNonConfusableNonBasicAsciiCharacter","isBasicASCII","isInvisibleCharacter"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}