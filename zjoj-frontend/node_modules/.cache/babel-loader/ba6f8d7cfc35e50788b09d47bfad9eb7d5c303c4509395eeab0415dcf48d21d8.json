{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace, splitLines } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nimport { addPositions, lengthOfText } from './utils.js';\nexport class SingleTextEdit {\n  constructor(range, text) {\n    this.range = range;\n    this.text = text;\n  }\n  removeCommonPrefix(model, validModelRange) {\n    const modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;\n    if (!modelRange) {\n      return this;\n    }\n    const valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n    const commonPrefixLen = commonPrefixLength(valueToReplace, this.text);\n    const start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));\n    const text = this.text.substring(commonPrefixLen);\n    const range = Range.fromPositions(start, this.range.getEndPosition());\n    return new SingleTextEdit(range, text);\n  }\n  augments(base) {\n    // The augmented completion must replace the base range, but can replace even more\n    return this.text.startsWith(base.text) && rangeExtends(this.range, base.range);\n  }\n  /**\n   * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n   * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n  */\n  computeGhostText(model, mode, cursorPosition, previewSuffixLength = 0) {\n    let edit = this.removeCommonPrefix(model);\n    if (edit.range.endLineNumber !== edit.range.startLineNumber) {\n      // This edit might span multiple lines, but the first lines must be a common prefix.\n      return undefined;\n    }\n    const sourceLine = model.getLineContent(edit.range.startLineNumber);\n    const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n    const suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;\n    if (suggestionTouchesIndentation) {\n      // source:      ··········[······abc]\n      //                         ^^^^^^^^^ inlineCompletion.range\n      //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n      //                         ^^^^^^ replacedIndentation.length\n      //                               ^^^ rangeThatDoesNotReplaceIndentation\n      // inlineCompletion.text: '··foo'\n      //                         ^^ suggestionAddedIndentationLength\n      const suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;\n      const replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);\n      const [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];\n      const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column ? startPosition.delta(0, replacedIndentation.length) : endPosition;\n      const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n      const suggestionWithoutIndentationChange = edit.text.startsWith(replacedIndentation)\n      // Adds more indentation without changing existing indentation: We can add ghost text for this\n      ? edit.text.substring(replacedIndentation.length)\n      // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n      : edit.text.substring(suggestionAddedIndentationLength);\n      edit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n    }\n    // This is a single line string\n    const valueToBeReplaced = model.getValueInRange(edit.range);\n    const changes = cachingDiff(valueToBeReplaced, edit.text);\n    if (!changes) {\n      // No ghost text in case the diff would be too slow to compute\n      return undefined;\n    }\n    const lineNumber = edit.range.startLineNumber;\n    const parts = new Array();\n    if (mode === 'prefix') {\n      const filteredChanges = changes.filter(c => c.originalLength === 0);\n      if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n        // Prefixes only have a single change.\n        return undefined;\n      }\n    }\n    const previewStartInCompletionText = edit.text.length - previewSuffixLength;\n    for (const c of changes) {\n      const insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;\n      if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {\n        // No ghost text before cursor\n        return undefined;\n      }\n      if (c.originalLength > 0) {\n        return undefined;\n      }\n      if (c.modifiedLength === 0) {\n        continue;\n      }\n      const modifiedEnd = c.modifiedStart + c.modifiedLength;\n      const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n      const nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);\n      const italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n      if (nonPreviewText.length > 0) {\n        const lines = splitLines(nonPreviewText);\n        parts.push(new GhostTextPart(insertColumn, lines, false));\n      }\n      if (italicText.length > 0) {\n        const lines = splitLines(italicText);\n        parts.push(new GhostTextPart(insertColumn, lines, true));\n      }\n    }\n    return new GhostText(lineNumber, parts);\n  }\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n  return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition()) && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n  } else {\n    let changes = smartDiff(originalValue, newValue, true);\n    if (changes) {\n      const deletedChars = deletedCharacters(changes);\n      if (deletedChars > 0) {\n        // For performance reasons, don't compute diff if there is nothing to improve\n        const newChanges = smartDiff(originalValue, newValue, false);\n        if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n          // Disabling smartness seems to be better here\n          changes = newChanges;\n        }\n      }\n    }\n    lastRequest = {\n      originalValue,\n      newValue,\n      changes\n    };\n    return changes;\n  }\n}\nfunction deletedCharacters(changes) {\n  let sum = 0;\n  for (const c of changes) {\n    sum += c.originalLength;\n  }\n  return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n  if (originalValue.length > 5000 || newValue.length > 5000) {\n    // We don't want to work on strings that are too big\n    return undefined;\n  }\n  function getMaxCharCode(val) {\n    let maxCharCode = 0;\n    for (let i = 0, len = val.length; i < len; i++) {\n      const charCode = val.charCodeAt(i);\n      if (charCode > maxCharCode) {\n        maxCharCode = charCode;\n      }\n    }\n    return maxCharCode;\n  }\n  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n  function getUniqueCharCode(id) {\n    if (id < 0) {\n      throw new Error('unexpected');\n    }\n    return maxCharCode + id + 1;\n  }\n  function getElements(source) {\n    let level = 0;\n    let group = 0;\n    const characters = new Int32Array(source.length);\n    for (let i = 0, len = source.length; i < len; i++) {\n      // TODO support more brackets\n      if (smartBracketMatching && source[i] === '(') {\n        const id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * id);\n        level++;\n      } else if (smartBracketMatching && source[i] === ')') {\n        level = Math.max(level - 1, 0);\n        const id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * id + 1);\n        if (level === 0) {\n          group++;\n        }\n      } else {\n        characters[i] = source.charCodeAt(i);\n      }\n    }\n    return characters;\n  }\n  const elements1 = getElements(originalValue);\n  const elements2 = getElements(newValue);\n  return new LcsDiff({\n    getElements: () => elements1\n  }, {\n    getElements: () => elements2\n  }).ComputeDiff(false).changes;\n}","map":{"version":3,"names":["LcsDiff","commonPrefixLength","getLeadingWhitespace","splitLines","Range","GhostText","GhostTextPart","addPositions","lengthOfText","SingleTextEdit","constructor","range","text","removeCommonPrefix","model","validModelRange","modelRange","intersectRanges","valueToReplace","getValueInRange","commonPrefixLen","start","getStartPosition","substring","fromPositions","getEndPosition","augments","base","startsWith","rangeExtends","computeGhostText","mode","cursorPosition","previewSuffixLength","edit","endLineNumber","startLineNumber","undefined","sourceLine","getLineContent","sourceIndentationLength","length","suggestionTouchesIndentation","startColumn","suggestionAddedIndentationLength","replacedIndentation","startPosition","endPosition","newStartPosition","column","delta","rangeThatDoesNotReplaceIndentation","suggestionWithoutIndentationChange","valueToBeReplaced","changes","cachingDiff","lineNumber","parts","Array","filteredChanges","filter","c","originalLength","originalStart","previewStartInCompletionText","insertColumn","modifiedLength","modifiedEnd","modifiedStart","nonPreviewTextEnd","Math","max","min","nonPreviewText","italicText","lines","push","extendingRange","rangeToExtend","equals","isBeforeOrEqual","lastRequest","originalValue","newValue","smartDiff","deletedChars","deletedCharacters","newChanges","sum","smartBracketMatching","getMaxCharCode","val","maxCharCode","i","len","charCode","charCodeAt","getUniqueCharCode","id","Error","getElements","source","level","group","characters","Int32Array","elements1","elements2","ComputeDiff"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace, splitLines } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nimport { addPositions, lengthOfText } from './utils.js';\nexport class SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n    removeCommonPrefix(model, validModelRange) {\n        const modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;\n        if (!modelRange) {\n            return this;\n        }\n        const valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n        const commonPrefixLen = commonPrefixLength(valueToReplace, this.text);\n        const start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));\n        const text = this.text.substring(commonPrefixLen);\n        const range = Range.fromPositions(start, this.range.getEndPosition());\n        return new SingleTextEdit(range, text);\n    }\n    augments(base) {\n        // The augmented completion must replace the base range, but can replace even more\n        return this.text.startsWith(base.text) && rangeExtends(this.range, base.range);\n    }\n    /**\n     * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n     * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n    */\n    computeGhostText(model, mode, cursorPosition, previewSuffixLength = 0) {\n        let edit = this.removeCommonPrefix(model);\n        if (edit.range.endLineNumber !== edit.range.startLineNumber) {\n            // This edit might span multiple lines, but the first lines must be a common prefix.\n            return undefined;\n        }\n        const sourceLine = model.getLineContent(edit.range.startLineNumber);\n        const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n        const suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;\n        if (suggestionTouchesIndentation) {\n            // source:      ··········[······abc]\n            //                         ^^^^^^^^^ inlineCompletion.range\n            //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n            //                         ^^^^^^ replacedIndentation.length\n            //                               ^^^ rangeThatDoesNotReplaceIndentation\n            // inlineCompletion.text: '··foo'\n            //                         ^^ suggestionAddedIndentationLength\n            const suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;\n            const replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);\n            const [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];\n            const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column\n                ? startPosition.delta(0, replacedIndentation.length)\n                : endPosition;\n            const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n            const suggestionWithoutIndentationChange = edit.text.startsWith(replacedIndentation)\n                // Adds more indentation without changing existing indentation: We can add ghost text for this\n                ? edit.text.substring(replacedIndentation.length)\n                // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n                : edit.text.substring(suggestionAddedIndentationLength);\n            edit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n        }\n        // This is a single line string\n        const valueToBeReplaced = model.getValueInRange(edit.range);\n        const changes = cachingDiff(valueToBeReplaced, edit.text);\n        if (!changes) {\n            // No ghost text in case the diff would be too slow to compute\n            return undefined;\n        }\n        const lineNumber = edit.range.startLineNumber;\n        const parts = new Array();\n        if (mode === 'prefix') {\n            const filteredChanges = changes.filter(c => c.originalLength === 0);\n            if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n                // Prefixes only have a single change.\n                return undefined;\n            }\n        }\n        const previewStartInCompletionText = edit.text.length - previewSuffixLength;\n        for (const c of changes) {\n            const insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;\n            if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {\n                // No ghost text before cursor\n                return undefined;\n            }\n            if (c.originalLength > 0) {\n                return undefined;\n            }\n            if (c.modifiedLength === 0) {\n                continue;\n            }\n            const modifiedEnd = c.modifiedStart + c.modifiedLength;\n            const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n            const nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);\n            const italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n            if (nonPreviewText.length > 0) {\n                const lines = splitLines(nonPreviewText);\n                parts.push(new GhostTextPart(insertColumn, lines, false));\n            }\n            if (italicText.length > 0) {\n                const lines = splitLines(italicText);\n                parts.push(new GhostTextPart(insertColumn, lines, true));\n            }\n        }\n        return new GhostText(lineNumber, parts);\n    }\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n    return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n        && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n    }\n    else {\n        let changes = smartDiff(originalValue, newValue, true);\n        if (changes) {\n            const deletedChars = deletedCharacters(changes);\n            if (deletedChars > 0) {\n                // For performance reasons, don't compute diff if there is nothing to improve\n                const newChanges = smartDiff(originalValue, newValue, false);\n                if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n                    // Disabling smartness seems to be better here\n                    changes = newChanges;\n                }\n            }\n        }\n        lastRequest = {\n            originalValue,\n            newValue,\n            changes\n        };\n        return changes;\n    }\n}\nfunction deletedCharacters(changes) {\n    let sum = 0;\n    for (const c of changes) {\n        sum += c.originalLength;\n    }\n    return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n    if (originalValue.length > 5000 || newValue.length > 5000) {\n        // We don't want to work on strings that are too big\n        return undefined;\n    }\n    function getMaxCharCode(val) {\n        let maxCharCode = 0;\n        for (let i = 0, len = val.length; i < len; i++) {\n            const charCode = val.charCodeAt(i);\n            if (charCode > maxCharCode) {\n                maxCharCode = charCode;\n            }\n        }\n        return maxCharCode;\n    }\n    const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n    function getUniqueCharCode(id) {\n        if (id < 0) {\n            throw new Error('unexpected');\n        }\n        return maxCharCode + id + 1;\n    }\n    function getElements(source) {\n        let level = 0;\n        let group = 0;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            // TODO support more brackets\n            if (smartBracketMatching && source[i] === '(') {\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id);\n                level++;\n            }\n            else if (smartBracketMatching && source[i] === ')') {\n                level = Math.max(level - 1, 0);\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id + 1);\n                if (level === 0) {\n                    group++;\n                }\n            }\n            else {\n                characters[i] = source.charCodeAt(i);\n            }\n        }\n        return characters;\n    }\n    const elements1 = getElements(originalValue);\n    const elements2 = getElements(newValue);\n    return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}