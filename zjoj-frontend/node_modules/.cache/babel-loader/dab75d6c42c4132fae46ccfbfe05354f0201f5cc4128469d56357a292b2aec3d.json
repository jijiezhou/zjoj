{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n  constructor(createLine) {\n    this._createLine = createLine;\n    this._set(1, []);\n  }\n  flush() {\n    this._set(1, []);\n  }\n  _set(rendLineNumberStart, lines) {\n    this._lines = lines;\n    this._rendLineNumberStart = rendLineNumberStart;\n  }\n  _get() {\n    return {\n      rendLineNumberStart: this._rendLineNumberStart,\n      lines: this._lines\n    };\n  }\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n  getStartLineNumber() {\n    return this._rendLineNumberStart;\n  }\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n  getEndLineNumber() {\n    return this._rendLineNumberStart + this._lines.length - 1;\n  }\n  getCount() {\n    return this._lines.length;\n  }\n  getLine(lineNumber) {\n    const lineIndex = lineNumber - this._rendLineNumberStart;\n    if (lineIndex < 0 || lineIndex >= this._lines.length) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._lines[lineIndex];\n  }\n  /**\n   * @returns Lines that were removed from this collection\n   */\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    if (deleteToLineNumber < startLineNumber) {\n      // deleting above the viewport\n      const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n      this._rendLineNumberStart -= deleteCnt;\n      return null;\n    }\n    if (deleteFromLineNumber > endLineNumber) {\n      // deleted below the viewport\n      return null;\n    }\n    // Record what needs to be deleted\n    let deleteStartIndex = 0;\n    let deleteCount = 0;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - this._rendLineNumberStart;\n      if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n        // this is a line to be deleted\n        if (deleteCount === 0) {\n          // this is the first line to be deleted\n          deleteStartIndex = lineIndex;\n          deleteCount = 1;\n        } else {\n          deleteCount++;\n        }\n      }\n    }\n    // Adjust this._rendLineNumberStart for lines deleted above\n    if (deleteFromLineNumber < startLineNumber) {\n      // Something was deleted above\n      let deleteAboveCount = 0;\n      if (deleteToLineNumber < startLineNumber) {\n        // the entire deleted lines are above\n        deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n      } else {\n        deleteAboveCount = startLineNumber - deleteFromLineNumber;\n      }\n      this._rendLineNumberStart -= deleteAboveCount;\n    }\n    const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n    return deleted;\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    const changeToLineNumber = changeFromLineNumber + changeCount - 1;\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    let someoneNotified = false;\n    for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n      if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n        // Notify the line\n        this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n        someoneNotified = true;\n      }\n    }\n    return someoneNotified;\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n    const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    if (insertFromLineNumber <= startLineNumber) {\n      // inserting above the viewport\n      this._rendLineNumberStart += insertCnt;\n      return null;\n    }\n    if (insertFromLineNumber > endLineNumber) {\n      // inserting below the viewport\n      return null;\n    }\n    if (insertCnt + insertFromLineNumber > endLineNumber) {\n      // insert inside the viewport in such a way that all remaining lines are pushed outside\n      const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n      return deleted;\n    }\n    // insert inside the viewport, push out some lines, but not all remaining lines\n    const newLines = [];\n    for (let i = 0; i < insertCnt; i++) {\n      newLines[i] = this._createLine();\n    }\n    const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n    const beforeLines = this._lines.slice(0, insertIndex);\n    const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n    const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n    this._lines = beforeLines.concat(newLines).concat(afterLines);\n    return deletedLines;\n  }\n  onTokensChanged(ranges) {\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    let notifiedSomeone = false;\n    for (let i = 0, len = ranges.length; i < len; i++) {\n      const rng = ranges[i];\n      if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n        // range outside viewport\n        continue;\n      }\n      const from = Math.max(startLineNumber, rng.fromLineNumber);\n      const to = Math.min(endLineNumber, rng.toLineNumber);\n      for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n        this._lines[lineIndex].onTokensChanged();\n        notifiedSomeone = true;\n      }\n    }\n    return notifiedSomeone;\n  }\n}\nexport class VisibleLinesCollection {\n  constructor(host) {\n    this._host = host;\n    this.domNode = this._createDomNode();\n    this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n  }\n  _createDomNode() {\n    const domNode = createFastDomNode(document.createElement('div'));\n    domNode.setClassName('view-layer');\n    domNode.setPosition('absolute');\n    domNode.domNode.setAttribute('role', 'presentation');\n    domNode.domNode.setAttribute('aria-hidden', 'true');\n    return domNode;\n  }\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    if (e.hasChanged(143 /* EditorOption.layoutInfo */)) {\n      return true;\n    }\n    return false;\n  }\n  onFlushed(e) {\n    this._linesCollection.flush();\n    // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n    return true;\n  }\n  onLinesChanged(e) {\n    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n  }\n  onLinesDeleted(e) {\n    const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    if (deleted) {\n      // Remove from DOM\n      for (let i = 0, len = deleted.length; i < len; i++) {\n        const lineDomNode = deleted[i].getDomNode();\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n    return true;\n  }\n  onLinesInserted(e) {\n    const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    if (deleted) {\n      // Remove from DOM\n      for (let i = 0, len = deleted.length; i < len; i++) {\n        const lineDomNode = deleted[i].getDomNode();\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n    return true;\n  }\n  onScrollChanged(e) {\n    return e.scrollTopChanged;\n  }\n  onTokensChanged(e) {\n    return this._linesCollection.onTokensChanged(e.ranges);\n  }\n  onZonesChanged(e) {\n    return true;\n  }\n  // ---- end view event handlers\n  getStartLineNumber() {\n    return this._linesCollection.getStartLineNumber();\n  }\n  getEndLineNumber() {\n    return this._linesCollection.getEndLineNumber();\n  }\n  getVisibleLine(lineNumber) {\n    return this._linesCollection.getLine(lineNumber);\n  }\n  renderLines(viewportData) {\n    const inp = this._linesCollection._get();\n    const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n    const ctx = {\n      rendLineNumberStart: inp.rendLineNumberStart,\n      lines: inp.lines,\n      linesLength: inp.lines.length\n    };\n    // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n    const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n    this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n  }\n}\nclass ViewLayerRenderer {\n  constructor(domNode, host, viewportData) {\n    this.domNode = domNode;\n    this.host = host;\n    this.viewportData = viewportData;\n  }\n  render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n    const ctx = {\n      rendLineNumberStart: inContext.rendLineNumberStart,\n      lines: inContext.lines.slice(0),\n      linesLength: inContext.linesLength\n    };\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber || stopLineNumber < ctx.rendLineNumberStart) {\n      // There is no overlap whatsoever\n      ctx.rendLineNumberStart = startLineNumber;\n      ctx.linesLength = stopLineNumber - startLineNumber + 1;\n      ctx.lines = [];\n      for (let x = startLineNumber; x <= stopLineNumber; x++) {\n        ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n      }\n      this._finishRendering(ctx, true, deltaTop);\n      return ctx;\n    }\n    // Update lines which will remain untouched\n    this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n    if (ctx.rendLineNumberStart > startLineNumber) {\n      // Insert lines before\n      const fromLineNumber = startLineNumber;\n      const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart < startLineNumber) {\n      // Remove lines before\n      const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n      if (removeCnt > 0) {\n        this._removeLinesBefore(ctx, removeCnt);\n        ctx.linesLength -= removeCnt;\n      }\n    }\n    ctx.rendLineNumberStart = startLineNumber;\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n      // Insert lines after\n      const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n      const toLineNumber = stopLineNumber;\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n      // Remove lines after\n      const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n      const toLineNumber = ctx.linesLength - 1;\n      const removeCnt = toLineNumber - fromLineNumber + 1;\n      if (removeCnt > 0) {\n        this._removeLinesAfter(ctx, removeCnt);\n        ctx.linesLength -= removeCnt;\n      }\n    }\n    this._finishRendering(ctx, false, deltaTop);\n    return ctx;\n  }\n  _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n    const rendLineNumberStart = ctx.rendLineNumberStart;\n    const lines = ctx.lines;\n    for (let i = startIndex; i <= endIndex; i++) {\n      const lineNumber = rendLineNumberStart + i;\n      lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n    }\n  }\n  _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    const newLines = [];\n    let newLinesLen = 0;\n    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n    ctx.lines = newLines.concat(ctx.lines);\n  }\n  _removeLinesBefore(ctx, removeCount) {\n    for (let i = 0; i < removeCount; i++) {\n      const lineDomNode = ctx.lines[i].getDomNode();\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n    ctx.lines.splice(0, removeCount);\n  }\n  _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    const newLines = [];\n    let newLinesLen = 0;\n    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n    ctx.lines = ctx.lines.concat(newLines);\n  }\n  _removeLinesAfter(ctx, removeCount) {\n    const removeIndex = ctx.linesLength - removeCount;\n    for (let i = 0; i < removeCount; i++) {\n      const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n    ctx.lines.splice(removeIndex, removeCount);\n  }\n  _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n    if (ViewLayerRenderer._ttPolicy) {\n      newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n    }\n    const lastChild = this.domNode.lastChild;\n    if (domNodeIsEmpty || !lastChild) {\n      this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n    } else {\n      lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n    }\n    let currChild = this.domNode.lastChild;\n    for (let i = ctx.linesLength - 1; i >= 0; i--) {\n      const line = ctx.lines[i];\n      if (wasNew[i]) {\n        line.setDomNode(currChild);\n        currChild = currChild.previousSibling;\n      }\n    }\n  }\n  _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n    const hugeDomNode = document.createElement('div');\n    if (ViewLayerRenderer._ttPolicy) {\n      invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n    }\n    hugeDomNode.innerHTML = invalidLinesHTML;\n    for (let i = 0; i < ctx.linesLength; i++) {\n      const line = ctx.lines[i];\n      if (wasInvalid[i]) {\n        const source = hugeDomNode.firstChild;\n        const lineDomNode = line.getDomNode();\n        lineDomNode.parentNode.replaceChild(source, lineDomNode);\n        line.setDomNode(source);\n      }\n    }\n  }\n  _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n    const sb = ViewLayerRenderer._sb;\n    const linesLength = ctx.linesLength;\n    const lines = ctx.lines;\n    const rendLineNumberStart = ctx.rendLineNumberStart;\n    const wasNew = [];\n    {\n      sb.reset();\n      let hadNewLine = false;\n      for (let i = 0; i < linesLength; i++) {\n        const line = lines[i];\n        wasNew[i] = false;\n        const lineDomNode = line.getDomNode();\n        if (lineDomNode) {\n          // line is not new\n          continue;\n        }\n        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n        wasNew[i] = true;\n        hadNewLine = true;\n      }\n      if (hadNewLine) {\n        this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n      }\n    }\n    {\n      sb.reset();\n      let hadInvalidLine = false;\n      const wasInvalid = [];\n      for (let i = 0; i < linesLength; i++) {\n        const line = lines[i];\n        wasInvalid[i] = false;\n        if (wasNew[i]) {\n          // line was new\n          continue;\n        }\n        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n        wasInvalid[i] = true;\n        hadInvalidLine = true;\n      }\n      if (hadInvalidLine) {\n        this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n      }\n    }\n  }\n}\nViewLayerRenderer._ttPolicy = createTrustedTypesPolicy('editorViewLayer', {\n  createHTML: value => value\n});\nViewLayerRenderer._sb = new StringBuilder(100000);","map":{"version":3,"names":["createFastDomNode","createTrustedTypesPolicy","BugIndicatingError","StringBuilder","RenderedLinesCollection","constructor","createLine","_createLine","_set","flush","rendLineNumberStart","lines","_lines","_rendLineNumberStart","_get","getStartLineNumber","getEndLineNumber","length","getCount","getLine","lineNumber","lineIndex","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","startLineNumber","endLineNumber","deleteCnt","deleteStartIndex","deleteCount","deleteAboveCount","deleted","splice","onLinesChanged","changeFromLineNumber","changeCount","changeToLineNumber","someoneNotified","changedLineNumber","onContentChanged","onLinesInserted","insertFromLineNumber","insertToLineNumber","insertCnt","newLines","i","insertIndex","beforeLines","slice","afterLines","deletedLines","concat","onTokensChanged","ranges","notifiedSomeone","len","rng","toLineNumber","fromLineNumber","from","Math","max","to","min","VisibleLinesCollection","host","_host","domNode","_createDomNode","_linesCollection","createVisibleLine","document","createElement","setClassName","setPosition","setAttribute","onConfigurationChanged","e","hasChanged","onFlushed","count","lineDomNode","getDomNode","removeChild","onScrollChanged","scrollTopChanged","onZonesChanged","getVisibleLine","renderLines","viewportData","inp","renderer","ViewLayerRenderer","ctx","linesLength","resCtx","render","relativeVerticalOffset","inContext","stopLineNumber","deltaTop","x","_finishRendering","_renderUntouchedLines","_insertLinesBefore","removeCnt","_removeLinesBefore","_insertLinesAfter","_removeLinesAfter","startIndex","endIndex","deltaLN","layoutLine","newLinesLen","removeCount","removeIndex","_finishRenderingNewLines","domNodeIsEmpty","newLinesHTML","wasNew","_ttPolicy","createHTML","lastChild","innerHTML","insertAdjacentHTML","currChild","line","setDomNode","previousSibling","_finishRenderingInvalidLines","invalidLinesHTML","wasInvalid","hugeDomNode","source","firstChild","parentNode","replaceChild","sb","_sb","reset","hadNewLine","renderResult","renderLine","build","hadInvalidLine","value"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/view/viewLayer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n    constructor(createLine) {\n        this._createLine = createLine;\n        this._set(1, []);\n    }\n    flush() {\n        this._set(1, []);\n    }\n    _set(rendLineNumberStart, lines) {\n        this._lines = lines;\n        this._rendLineNumberStart = rendLineNumberStart;\n    }\n    _get() {\n        return {\n            rendLineNumberStart: this._rendLineNumberStart,\n            lines: this._lines\n        };\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getStartLineNumber() {\n        return this._rendLineNumberStart;\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getEndLineNumber() {\n        return this._rendLineNumberStart + this._lines.length - 1;\n    }\n    getCount() {\n        return this._lines.length;\n    }\n    getLine(lineNumber) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n        if (lineIndex < 0 || lineIndex >= this._lines.length) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._lines[lineIndex];\n    }\n    /**\n     * @returns Lines that were removed from this collection\n     */\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (deleteToLineNumber < startLineNumber) {\n            // deleting above the viewport\n            const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n            this._rendLineNumberStart -= deleteCnt;\n            return null;\n        }\n        if (deleteFromLineNumber > endLineNumber) {\n            // deleted below the viewport\n            return null;\n        }\n        // Record what needs to be deleted\n        let deleteStartIndex = 0;\n        let deleteCount = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - this._rendLineNumberStart;\n            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n                // this is a line to be deleted\n                if (deleteCount === 0) {\n                    // this is the first line to be deleted\n                    deleteStartIndex = lineIndex;\n                    deleteCount = 1;\n                }\n                else {\n                    deleteCount++;\n                }\n            }\n        }\n        // Adjust this._rendLineNumberStart for lines deleted above\n        if (deleteFromLineNumber < startLineNumber) {\n            // Something was deleted above\n            let deleteAboveCount = 0;\n            if (deleteToLineNumber < startLineNumber) {\n                // the entire deleted lines are above\n                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n            }\n            else {\n                deleteAboveCount = startLineNumber - deleteFromLineNumber;\n            }\n            this._rendLineNumberStart -= deleteAboveCount;\n        }\n        const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n        return deleted;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        const changeToLineNumber = changeFromLineNumber + changeCount - 1;\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let someoneNotified = false;\n        for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n            if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n                // Notify the line\n                this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n                someoneNotified = true;\n            }\n        }\n        return someoneNotified;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (insertFromLineNumber <= startLineNumber) {\n            // inserting above the viewport\n            this._rendLineNumberStart += insertCnt;\n            return null;\n        }\n        if (insertFromLineNumber > endLineNumber) {\n            // inserting below the viewport\n            return null;\n        }\n        if (insertCnt + insertFromLineNumber > endLineNumber) {\n            // insert inside the viewport in such a way that all remaining lines are pushed outside\n            const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n            return deleted;\n        }\n        // insert inside the viewport, push out some lines, but not all remaining lines\n        const newLines = [];\n        for (let i = 0; i < insertCnt; i++) {\n            newLines[i] = this._createLine();\n        }\n        const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n        const beforeLines = this._lines.slice(0, insertIndex);\n        const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n        const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n        this._lines = beforeLines.concat(newLines).concat(afterLines);\n        return deletedLines;\n    }\n    onTokensChanged(ranges) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let notifiedSomeone = false;\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            const rng = ranges[i];\n            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n                // range outside viewport\n                continue;\n            }\n            const from = Math.max(startLineNumber, rng.fromLineNumber);\n            const to = Math.min(endLineNumber, rng.toLineNumber);\n            for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n                const lineIndex = lineNumber - this._rendLineNumberStart;\n                this._lines[lineIndex].onTokensChanged();\n                notifiedSomeone = true;\n            }\n        }\n        return notifiedSomeone;\n    }\n}\nexport class VisibleLinesCollection {\n    constructor(host) {\n        this._host = host;\n        this.domNode = this._createDomNode();\n        this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n    }\n    _createDomNode() {\n        const domNode = createFastDomNode(document.createElement('div'));\n        domNode.setClassName('view-layer');\n        domNode.setPosition('absolute');\n        domNode.domNode.setAttribute('role', 'presentation');\n        domNode.domNode.setAttribute('aria-hidden', 'true');\n        return domNode;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(143 /* EditorOption.layoutInfo */)) {\n            return true;\n        }\n        return false;\n    }\n    onFlushed(e) {\n        this._linesCollection.flush();\n        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n        return true;\n    }\n    onLinesChanged(e) {\n        return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n    }\n    onLinesDeleted(e) {\n        const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onLinesInserted(e) {\n        const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onTokensChanged(e) {\n        return this._linesCollection.onTokensChanged(e.ranges);\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    getStartLineNumber() {\n        return this._linesCollection.getStartLineNumber();\n    }\n    getEndLineNumber() {\n        return this._linesCollection.getEndLineNumber();\n    }\n    getVisibleLine(lineNumber) {\n        return this._linesCollection.getLine(lineNumber);\n    }\n    renderLines(viewportData) {\n        const inp = this._linesCollection._get();\n        const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n        const ctx = {\n            rendLineNumberStart: inp.rendLineNumberStart,\n            lines: inp.lines,\n            linesLength: inp.lines.length\n        };\n        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n        const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n    }\n}\nclass ViewLayerRenderer {\n    constructor(domNode, host, viewportData) {\n        this.domNode = domNode;\n        this.host = host;\n        this.viewportData = viewportData;\n    }\n    render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n        const ctx = {\n            rendLineNumberStart: inContext.rendLineNumberStart,\n            lines: inContext.lines.slice(0),\n            linesLength: inContext.linesLength\n        };\n        if ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n            // There is no overlap whatsoever\n            ctx.rendLineNumberStart = startLineNumber;\n            ctx.linesLength = stopLineNumber - startLineNumber + 1;\n            ctx.lines = [];\n            for (let x = startLineNumber; x <= stopLineNumber; x++) {\n                ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n            }\n            this._finishRendering(ctx, true, deltaTop);\n            return ctx;\n        }\n        // Update lines which will remain untouched\n        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n        if (ctx.rendLineNumberStart > startLineNumber) {\n            // Insert lines before\n            const fromLineNumber = startLineNumber;\n            const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart < startLineNumber) {\n            // Remove lines before\n            const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n            if (removeCnt > 0) {\n                this._removeLinesBefore(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        ctx.rendLineNumberStart = startLineNumber;\n        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n            // Insert lines after\n            const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n            const toLineNumber = stopLineNumber;\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n            // Remove lines after\n            const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n            const toLineNumber = ctx.linesLength - 1;\n            const removeCnt = toLineNumber - fromLineNumber + 1;\n            if (removeCnt > 0) {\n                this._removeLinesAfter(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        this._finishRendering(ctx, false, deltaTop);\n        return ctx;\n    }\n    _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const lines = ctx.lines;\n        for (let i = startIndex; i <= endIndex; i++) {\n            const lineNumber = rendLineNumberStart + i;\n            lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n        }\n    }\n    _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = newLines.concat(ctx.lines);\n    }\n    _removeLinesBefore(ctx, removeCount) {\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(0, removeCount);\n    }\n    _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = ctx.lines.concat(newLines);\n    }\n    _removeLinesAfter(ctx, removeCount) {\n        const removeIndex = ctx.linesLength - removeCount;\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(removeIndex, removeCount);\n    }\n    _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n        if (ViewLayerRenderer._ttPolicy) {\n            newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n        }\n        const lastChild = this.domNode.lastChild;\n        if (domNodeIsEmpty || !lastChild) {\n            this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n        }\n        else {\n            lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n        }\n        let currChild = this.domNode.lastChild;\n        for (let i = ctx.linesLength - 1; i >= 0; i--) {\n            const line = ctx.lines[i];\n            if (wasNew[i]) {\n                line.setDomNode(currChild);\n                currChild = currChild.previousSibling;\n            }\n        }\n    }\n    _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n        const hugeDomNode = document.createElement('div');\n        if (ViewLayerRenderer._ttPolicy) {\n            invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n        }\n        hugeDomNode.innerHTML = invalidLinesHTML;\n        for (let i = 0; i < ctx.linesLength; i++) {\n            const line = ctx.lines[i];\n            if (wasInvalid[i]) {\n                const source = hugeDomNode.firstChild;\n                const lineDomNode = line.getDomNode();\n                lineDomNode.parentNode.replaceChild(source, lineDomNode);\n                line.setDomNode(source);\n            }\n        }\n    }\n    _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n        const sb = ViewLayerRenderer._sb;\n        const linesLength = ctx.linesLength;\n        const lines = ctx.lines;\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const wasNew = [];\n        {\n            sb.reset();\n            let hadNewLine = false;\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasNew[i] = false;\n                const lineDomNode = line.getDomNode();\n                if (lineDomNode) {\n                    // line is not new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasNew[i] = true;\n                hadNewLine = true;\n            }\n            if (hadNewLine) {\n                this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n            }\n        }\n        {\n            sb.reset();\n            let hadInvalidLine = false;\n            const wasInvalid = [];\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasInvalid[i] = false;\n                if (wasNew[i]) {\n                    // line was new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasInvalid[i] = true;\n                hadInvalidLine = true;\n            }\n            if (hadInvalidLine) {\n                this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n            }\n        }\n    }\n}\nViewLayerRenderer._ttPolicy = createTrustedTypesPolicy('editorViewLayer', { createHTML: value => value });\nViewLayerRenderer._sb = new StringBuilder(100000);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}