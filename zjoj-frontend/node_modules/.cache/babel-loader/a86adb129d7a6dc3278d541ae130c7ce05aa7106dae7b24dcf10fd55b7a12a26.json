{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar ContentHoverController_1, ContentHoverWidget_1;\nimport * as dom from '../../../../base/browser/dom.js';\nimport { HoverAction, HoverWidget, getHoverAccessibleViewHint } from '../../../../base/browser/ui/hover/hoverWidget.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { TokenizationRegistry } from '../../../common/languages.js';\nimport { HoverOperation } from './hoverOperation.js';\nimport { HoverParticipantRegistry, HoverRangeAnchor } from './hoverTypes.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { AsyncIterableObject } from '../../../../base/common/async.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ResizableContentWidget } from './resizableContentWidget.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';\nconst $ = dom.$;\nlet ContentHoverController = ContentHoverController_1 = class ContentHoverController extends Disposable {\n  constructor(_editor, _instantiationService, _keybindingService) {\n    super();\n    this._editor = _editor;\n    this._instantiationService = _instantiationService;\n    this._keybindingService = _keybindingService;\n    this._currentResult = null;\n    this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));\n    // Instantiate participants and sort them by `hoverOrdinal` which is relevant for rendering order.\n    this._participants = [];\n    for (const participant of HoverParticipantRegistry.getAll()) {\n      this._participants.push(this._instantiationService.createInstance(participant, this._editor));\n    }\n    this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);\n    this._computer = new ContentHoverComputer(this._editor, this._participants);\n    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));\n    this._register(this._hoverOperation.onResult(result => {\n      if (!this._computer.anchor) {\n        // invalid state, ignore result\n        return;\n      }\n      const messages = result.hasLoadingMessage ? this._addLoadingMessage(result.value) : result.value;\n      this._withResult(new HoverResult(this._computer.anchor, messages, result.isComplete));\n    }));\n    this._register(dom.addStandardDisposableListener(this._widget.getDomNode(), 'keydown', e => {\n      if (e.equals(9 /* KeyCode.Escape */)) {\n        this.hide();\n      }\n    }));\n    this._register(TokenizationRegistry.onDidChange(() => {\n      if (this._widget.position && this._currentResult) {\n        this._setCurrentResult(this._currentResult); // render again\n      }\n    }));\n  }\n  get widget() {\n    return this._widget;\n  }\n  /**\n   * Returns true if the hover shows now or will show.\n   */\n  maybeShowAt(mouseEvent) {\n    if (this._widget.isResizing) {\n      return true;\n    }\n    const anchorCandidates = [];\n    for (const participant of this._participants) {\n      if (participant.suggestHoverAnchor) {\n        const anchor = participant.suggestHoverAnchor(mouseEvent);\n        if (anchor) {\n          anchorCandidates.push(anchor);\n        }\n      }\n    }\n    const target = mouseEvent.target;\n    if (target.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n      anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));\n    }\n    if (target.type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n      const epsilon = this._editor.getOption(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth / 2;\n      if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === 'number' && target.detail.horizontalDistanceToText < epsilon) {\n        // Let hover kick in even when the mouse is technically in the empty area after a line, given the distance is small enough\n        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));\n      }\n    }\n    if (anchorCandidates.length === 0) {\n      return this._startShowingOrUpdateHover(null, 0 /* HoverStartMode.Delayed */, 0 /* HoverStartSource.Mouse */, false, mouseEvent);\n    }\n    anchorCandidates.sort((a, b) => b.priority - a.priority);\n    return this._startShowingOrUpdateHover(anchorCandidates[0], 0 /* HoverStartMode.Delayed */, 0 /* HoverStartSource.Mouse */, false, mouseEvent);\n  }\n  startShowingAtRange(range, mode, source, focus) {\n    this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, undefined, undefined), mode, source, focus, null);\n  }\n  /**\n   * Returns true if the hover shows now or will show.\n   */\n  _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {\n    if (!this._widget.position || !this._currentResult) {\n      // The hover is not visible\n      if (anchor) {\n        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n        return true;\n      }\n      return false;\n    }\n    // The hover is currently visible\n    const hoverIsSticky = this._editor.getOption(60 /* EditorOption.hover */).sticky;\n    const isGettingCloser = hoverIsSticky && mouseEvent && this._widget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy);\n    if (isGettingCloser) {\n      // The mouse is getting closer to the hover, so we will keep the hover untouched\n      // But we will kick off a hover update at the new anchor, insisting on keeping the hover visible.\n      if (anchor) {\n        this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);\n      }\n      return true;\n    }\n    if (!anchor) {\n      this._setCurrentResult(null);\n      return false;\n    }\n    if (anchor && this._currentResult.anchor.equals(anchor)) {\n      // The widget is currently showing results for the exact same anchor, so no update is needed\n      return true;\n    }\n    if (!anchor.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position)) {\n      // The new anchor is not compatible with the previous anchor\n      this._setCurrentResult(null);\n      this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n      return true;\n    }\n    // We aren't getting any closer to the hover, so we will filter existing results\n    // and keep those which also apply to the new anchor.\n    this._setCurrentResult(this._currentResult.filter(anchor));\n    this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n    return true;\n  }\n  _startHoverOperationIfNecessary(anchor, mode, source, focus, insistOnKeepingHoverVisible) {\n    if (this._computer.anchor && this._computer.anchor.equals(anchor)) {\n      // We have to start a hover operation at the exact same anchor as before, so no work is needed\n      return;\n    }\n    this._hoverOperation.cancel();\n    this._computer.anchor = anchor;\n    this._computer.shouldFocus = focus;\n    this._computer.source = source;\n    this._computer.insistOnKeepingHoverVisible = insistOnKeepingHoverVisible;\n    this._hoverOperation.start(mode);\n  }\n  _setCurrentResult(hoverResult) {\n    if (this._currentResult === hoverResult) {\n      // avoid updating the DOM to avoid resetting the user selection\n      return;\n    }\n    if (hoverResult && hoverResult.messages.length === 0) {\n      hoverResult = null;\n    }\n    this._currentResult = hoverResult;\n    if (this._currentResult) {\n      this._renderMessages(this._currentResult.anchor, this._currentResult.messages);\n    } else {\n      this._widget.hide();\n    }\n  }\n  hide() {\n    this._computer.anchor = null;\n    this._hoverOperation.cancel();\n    this._setCurrentResult(null);\n  }\n  get isColorPickerVisible() {\n    return this._widget.isColorPickerVisible;\n  }\n  get isVisibleFromKeyboard() {\n    return this._widget.isVisibleFromKeyboard;\n  }\n  get isVisible() {\n    return this._widget.isVisible;\n  }\n  get isFocused() {\n    return this._widget.isFocused;\n  }\n  get isResizing() {\n    return this._widget.isResizing;\n  }\n  containsNode(node) {\n    return node ? this._widget.getDomNode().contains(node) : false;\n  }\n  _addLoadingMessage(result) {\n    if (this._computer.anchor) {\n      for (const participant of this._participants) {\n        if (participant.createLoadingMessage) {\n          const loadingMessage = participant.createLoadingMessage(this._computer.anchor);\n          if (loadingMessage) {\n            return result.slice(0).concat([loadingMessage]);\n          }\n        }\n      }\n    }\n    return result;\n  }\n  _withResult(hoverResult) {\n    if (this._widget.position && this._currentResult && this._currentResult.isComplete) {\n      // The hover is visible with a previous complete result.\n      if (!hoverResult.isComplete) {\n        // Instead of rendering the new partial result, we wait for the result to be complete.\n        return;\n      }\n      if (this._computer.insistOnKeepingHoverVisible && hoverResult.messages.length === 0) {\n        // The hover would now hide normally, so we'll keep the previous messages\n        return;\n      }\n    }\n    this._setCurrentResult(hoverResult);\n  }\n  _renderMessages(anchor, messages) {\n    const {\n      showAtPosition,\n      showAtSecondaryPosition,\n      highlightRange\n    } = ContentHoverController_1.computeHoverRanges(this._editor, anchor.range, messages);\n    const disposables = new DisposableStore();\n    const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));\n    const fragment = document.createDocumentFragment();\n    let colorPicker = null;\n    const context = {\n      fragment,\n      statusBar,\n      setColorPicker: widget => colorPicker = widget,\n      onContentsChanged: () => this._widget.onContentsChanged(),\n      setMinimumDimensions: dimensions => this._widget.setMinimumDimensions(dimensions),\n      hide: () => this.hide()\n    };\n    for (const participant of this._participants) {\n      const hoverParts = messages.filter(msg => msg.owner === participant);\n      if (hoverParts.length > 0) {\n        disposables.add(participant.renderHoverParts(context, hoverParts));\n      }\n    }\n    const isBeforeContent = messages.some(m => m.isBeforeContent);\n    if (statusBar.hasContent) {\n      fragment.appendChild(statusBar.hoverElement);\n    }\n    if (fragment.hasChildNodes()) {\n      if (highlightRange) {\n        const highlightDecoration = this._editor.createDecorationsCollection();\n        highlightDecoration.set([{\n          range: highlightRange,\n          options: ContentHoverController_1._DECORATION_OPTIONS\n        }]);\n        disposables.add(toDisposable(() => {\n          highlightDecoration.clear();\n        }));\n      }\n      this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker, showAtPosition, showAtSecondaryPosition, this._editor.getOption(60 /* EditorOption.hover */).above, this._computer.shouldFocus, this._computer.source, isBeforeContent, anchor.initialMousePosX, anchor.initialMousePosY, disposables));\n    } else {\n      disposables.dispose();\n    }\n  }\n  static computeHoverRanges(editor, anchorRange, messages) {\n    let startColumnBoundary = 1;\n    if (editor.hasModel()) {\n      // Ensure the range is on the current view line\n      const viewModel = editor._getViewModel();\n      const coordinatesConverter = viewModel.coordinatesConverter;\n      const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);\n      const anchorViewRangeStart = new Position(anchorViewRange.startLineNumber, viewModel.getLineMinColumn(anchorViewRange.startLineNumber));\n      startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;\n    }\n    // The anchor range is always on a single line\n    const anchorLineNumber = anchorRange.startLineNumber;\n    let renderStartColumn = anchorRange.startColumn;\n    let highlightRange = messages[0].range;\n    let forceShowAtRange = null;\n    for (const msg of messages) {\n      highlightRange = Range.plusRange(highlightRange, msg.range);\n      if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {\n        // this message has a range that is completely sitting on the line of the anchor\n        renderStartColumn = Math.max(Math.min(renderStartColumn, msg.range.startColumn), startColumnBoundary);\n      }\n      if (msg.forceShowAtRange) {\n        forceShowAtRange = msg.range;\n      }\n    }\n    return {\n      showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, anchorRange.startColumn),\n      showAtSecondaryPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, renderStartColumn),\n      highlightRange\n    };\n  }\n  focus() {\n    this._widget.focus();\n  }\n  scrollUp() {\n    this._widget.scrollUp();\n  }\n  scrollDown() {\n    this._widget.scrollDown();\n  }\n  scrollLeft() {\n    this._widget.scrollLeft();\n  }\n  scrollRight() {\n    this._widget.scrollRight();\n  }\n  pageUp() {\n    this._widget.pageUp();\n  }\n  pageDown() {\n    this._widget.pageDown();\n  }\n  goToTop() {\n    this._widget.goToTop();\n  }\n  goToBottom() {\n    this._widget.goToBottom();\n  }\n};\nContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({\n  description: 'content-hover-highlight',\n  className: 'hoverHighlight'\n});\nContentHoverController = ContentHoverController_1 = __decorate([__param(1, IInstantiationService), __param(2, IKeybindingService)], ContentHoverController);\nexport { ContentHoverController };\nclass HoverResult {\n  constructor(anchor, messages, isComplete) {\n    this.anchor = anchor;\n    this.messages = messages;\n    this.isComplete = isComplete;\n  }\n  filter(anchor) {\n    const filteredMessages = this.messages.filter(m => m.isValidForHoverAnchor(anchor));\n    if (filteredMessages.length === this.messages.length) {\n      return this;\n    }\n    return new FilteredHoverResult(this, this.anchor, filteredMessages, this.isComplete);\n  }\n}\nclass FilteredHoverResult extends HoverResult {\n  constructor(original, anchor, messages, isComplete) {\n    super(anchor, messages, isComplete);\n    this.original = original;\n  }\n  filter(anchor) {\n    return this.original.filter(anchor);\n  }\n}\nclass ContentHoverVisibleData {\n  constructor(colorPicker, showAtPosition, showAtSecondaryPosition, preferAbove, stoleFocus, source, isBeforeContent, initialMousePosX, initialMousePosY, disposables) {\n    this.colorPicker = colorPicker;\n    this.showAtPosition = showAtPosition;\n    this.showAtSecondaryPosition = showAtSecondaryPosition;\n    this.preferAbove = preferAbove;\n    this.stoleFocus = stoleFocus;\n    this.source = source;\n    this.isBeforeContent = isBeforeContent;\n    this.initialMousePosX = initialMousePosX;\n    this.initialMousePosY = initialMousePosY;\n    this.disposables = disposables;\n    this.closestMouseDistance = undefined;\n  }\n}\nconst HORIZONTAL_SCROLLING_BY = 30;\nconst SCROLLBAR_WIDTH = 10;\nconst CONTAINER_HEIGHT_PADDING = 6;\nlet ContentHoverWidget = ContentHoverWidget_1 = class ContentHoverWidget extends ResizableContentWidget {\n  get isColorPickerVisible() {\n    var _a;\n    return Boolean((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker);\n  }\n  get isVisibleFromKeyboard() {\n    var _a;\n    return ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.source) === 1 /* HoverStartSource.Keyboard */;\n  }\n  get isVisible() {\n    var _a;\n    return (_a = this._hoverVisibleKey.get()) !== null && _a !== void 0 ? _a : false;\n  }\n  get isFocused() {\n    var _a;\n    return (_a = this._hoverFocusedKey.get()) !== null && _a !== void 0 ? _a : false;\n  }\n  constructor(editor, contextKeyService, _configurationService, _accessibilityService, _keybindingService) {\n    const minimumHeight = editor.getOption(66 /* EditorOption.lineHeight */) + 8;\n    const minimumWidth = 150;\n    const minimumSize = new dom.Dimension(minimumWidth, minimumHeight);\n    super(editor, minimumSize);\n    this._configurationService = _configurationService;\n    this._accessibilityService = _accessibilityService;\n    this._keybindingService = _keybindingService;\n    this._hover = this._register(new HoverWidget());\n    this._minimumSize = minimumSize;\n    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(contextKeyService);\n    this._hoverFocusedKey = EditorContextKeys.hoverFocused.bindTo(contextKeyService);\n    dom.append(this._resizableNode.domNode, this._hover.containerDomNode);\n    this._resizableNode.domNode.style.zIndex = '50';\n    this._register(this._editor.onDidLayoutChange(() => {\n      if (this.isVisible) {\n        this._updateMaxDimensions();\n      }\n    }));\n    this._register(this._editor.onDidChangeConfiguration(e => {\n      if (e.hasChanged(50 /* EditorOption.fontInfo */)) {\n        this._updateFont();\n      }\n    }));\n    const focusTracker = this._register(dom.trackFocus(this._resizableNode.domNode));\n    this._register(focusTracker.onDidFocus(() => {\n      this._hoverFocusedKey.set(true);\n    }));\n    this._register(focusTracker.onDidBlur(() => {\n      this._hoverFocusedKey.set(false);\n    }));\n    this._setHoverData(undefined);\n    this._editor.addContentWidget(this);\n  }\n  dispose() {\n    var _a;\n    super.dispose();\n    (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();\n    this._editor.removeContentWidget(this);\n  }\n  getId() {\n    return ContentHoverWidget_1.ID;\n  }\n  static _applyDimensions(container, width, height) {\n    const transformedWidth = typeof width === 'number' ? `${width}px` : width;\n    const transformedHeight = typeof height === 'number' ? `${height}px` : height;\n    container.style.width = transformedWidth;\n    container.style.height = transformedHeight;\n  }\n  _setContentsDomNodeDimensions(width, height) {\n    const contentsDomNode = this._hover.contentsDomNode;\n    return ContentHoverWidget_1._applyDimensions(contentsDomNode, width, height);\n  }\n  _setContainerDomNodeDimensions(width, height) {\n    const containerDomNode = this._hover.containerDomNode;\n    return ContentHoverWidget_1._applyDimensions(containerDomNode, width, height);\n  }\n  _setHoverWidgetDimensions(width, height) {\n    this._setContentsDomNodeDimensions(width, height);\n    this._setContainerDomNodeDimensions(width, height);\n    this._layoutContentWidget();\n  }\n  static _applyMaxDimensions(container, width, height) {\n    const transformedWidth = typeof width === 'number' ? `${width}px` : width;\n    const transformedHeight = typeof height === 'number' ? `${height}px` : height;\n    container.style.maxWidth = transformedWidth;\n    container.style.maxHeight = transformedHeight;\n  }\n  _setHoverWidgetMaxDimensions(width, height) {\n    ContentHoverWidget_1._applyMaxDimensions(this._hover.contentsDomNode, width, height);\n    ContentHoverWidget_1._applyMaxDimensions(this._hover.containerDomNode, width, height);\n    this._hover.containerDomNode.style.setProperty('--vscode-hover-maxWidth', typeof width === 'number' ? `${width}px` : width);\n    this._layoutContentWidget();\n  }\n  _hasHorizontalScrollbar() {\n    const scrollDimensions = this._hover.scrollbar.getScrollDimensions();\n    const hasHorizontalScrollbar = scrollDimensions.scrollWidth > scrollDimensions.width;\n    return hasHorizontalScrollbar;\n  }\n  _adjustContentsBottomPadding() {\n    const contentsDomNode = this._hover.contentsDomNode;\n    const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;\n    if (contentsDomNode.style.paddingBottom !== extraBottomPadding) {\n      contentsDomNode.style.paddingBottom = extraBottomPadding;\n    }\n  }\n  _setAdjustedHoverWidgetDimensions(size) {\n    this._setHoverWidgetMaxDimensions('none', 'none');\n    const width = size.width;\n    const height = size.height;\n    this._setHoverWidgetDimensions(width, height);\n    // measure if widget has horizontal scrollbar after setting the dimensions\n    if (this._hasHorizontalScrollbar()) {\n      this._adjustContentsBottomPadding();\n      this._setContentsDomNodeDimensions(width, height - SCROLLBAR_WIDTH);\n    }\n  }\n  _updateResizableNodeMaxDimensions() {\n    var _a, _b;\n    const maxRenderingWidth = (_a = this._findMaximumRenderingWidth()) !== null && _a !== void 0 ? _a : Infinity;\n    const maxRenderingHeight = (_b = this._findMaximumRenderingHeight()) !== null && _b !== void 0 ? _b : Infinity;\n    this._resizableNode.maxSize = new dom.Dimension(maxRenderingWidth, maxRenderingHeight);\n    this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);\n  }\n  _resize(size) {\n    var _a, _b;\n    ContentHoverWidget_1._lastDimensions = new dom.Dimension(size.width, size.height);\n    this._setAdjustedHoverWidgetDimensions(size);\n    this._resizableNode.layout(size.height, size.width);\n    this._updateResizableNodeMaxDimensions();\n    this._hover.scrollbar.scanDomNode();\n    this._editor.layoutContentWidget(this);\n    (_b = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();\n  }\n  _findAvailableSpaceVertically() {\n    var _a;\n    const position = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition;\n    if (!position) {\n      return;\n    }\n    return this._positionPreference === 1 /* ContentWidgetPositionPreference.ABOVE */ ? this._availableVerticalSpaceAbove(position) : this._availableVerticalSpaceBelow(position);\n  }\n  _findMaximumRenderingHeight() {\n    const availableSpace = this._findAvailableSpaceVertically();\n    if (!availableSpace) {\n      return;\n    }\n    // Padding needed in order to stop the resizing down to a smaller height\n    let maximumHeight = CONTAINER_HEIGHT_PADDING;\n    Array.from(this._hover.contentsDomNode.children).forEach(hoverPart => {\n      maximumHeight += hoverPart.clientHeight;\n    });\n    if (this._hasHorizontalScrollbar()) {\n      maximumHeight += SCROLLBAR_WIDTH;\n    }\n    return Math.min(availableSpace, maximumHeight);\n  }\n  _isHoverTextOverflowing() {\n    // To find out if the text is overflowing, we will disable wrapping, check the widths, and then re-enable wrapping\n    this._hover.containerDomNode.style.setProperty('--vscode-hover-whiteSpace', 'nowrap');\n    this._hover.containerDomNode.style.setProperty('--vscode-hover-sourceWhiteSpace', 'nowrap');\n    const overflowing = Array.from(this._hover.contentsDomNode.children).some(hoverElement => {\n      return hoverElement.scrollWidth > hoverElement.clientWidth;\n    });\n    this._hover.containerDomNode.style.removeProperty('--vscode-hover-whiteSpace');\n    this._hover.containerDomNode.style.removeProperty('--vscode-hover-sourceWhiteSpace');\n    return overflowing;\n  }\n  _findMaximumRenderingWidth() {\n    if (!this._editor || !this._editor.hasModel()) {\n      return;\n    }\n    const overflowing = this._isHoverTextOverflowing();\n    const initialWidth = typeof this._contentWidth === 'undefined' ? 0 : this._contentWidth - 2 // - 2 for the borders\n    ;\n    if (overflowing || this._hover.containerDomNode.clientWidth < initialWidth) {\n      const bodyBoxWidth = dom.getClientArea(this._hover.containerDomNode.ownerDocument.body).width;\n      const horizontalPadding = 14;\n      return bodyBoxWidth - horizontalPadding;\n    } else {\n      return this._hover.containerDomNode.clientWidth + 2;\n    }\n  }\n  isMouseGettingCloser(posx, posy) {\n    if (!this._visibleData) {\n      return false;\n    }\n    if (typeof this._visibleData.initialMousePosX === 'undefined' || typeof this._visibleData.initialMousePosY === 'undefined') {\n      this._visibleData.initialMousePosX = posx;\n      this._visibleData.initialMousePosY = posy;\n      return false;\n    }\n    const widgetRect = dom.getDomNodePagePosition(this.getDomNode());\n    if (typeof this._visibleData.closestMouseDistance === 'undefined') {\n      this._visibleData.closestMouseDistance = computeDistanceFromPointToRectangle(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);\n    }\n    const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);\n    if (distance > this._visibleData.closestMouseDistance + 4 /* tolerance of 4 pixels */) {\n      // The mouse is getting farther away\n      return false;\n    }\n    this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, distance);\n    return true;\n  }\n  _setHoverData(hoverData) {\n    var _a;\n    (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();\n    this._visibleData = hoverData;\n    this._hoverVisibleKey.set(!!hoverData);\n    this._hover.containerDomNode.classList.toggle('hidden', !hoverData);\n  }\n  _updateFont() {\n    const {\n      fontSize,\n      lineHeight\n    } = this._editor.getOption(50 /* EditorOption.fontInfo */);\n    const contentsDomNode = this._hover.contentsDomNode;\n    contentsDomNode.style.fontSize = `${fontSize}px`;\n    contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;\n    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName('code'));\n    codeClasses.forEach(node => this._editor.applyFontInfo(node));\n  }\n  _updateContent(node) {\n    const contentsDomNode = this._hover.contentsDomNode;\n    contentsDomNode.style.paddingBottom = '';\n    contentsDomNode.textContent = '';\n    contentsDomNode.appendChild(node);\n  }\n  _layoutContentWidget() {\n    this._editor.layoutContentWidget(this);\n    this._hover.onContentsChanged();\n  }\n  _updateMaxDimensions() {\n    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250, ContentHoverWidget_1._lastDimensions.height);\n    const width = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, ContentHoverWidget_1._lastDimensions.width);\n    this._setHoverWidgetMaxDimensions(width, height);\n  }\n  _render(node, hoverData) {\n    this._setHoverData(hoverData);\n    this._updateFont();\n    this._updateContent(node);\n    this._updateMaxDimensions();\n    this.onContentsChanged();\n    // Simply force a synchronous render on the editor\n    // such that the widget does not really render with left = '0px'\n    this._editor.render();\n  }\n  getPosition() {\n    var _a;\n    if (!this._visibleData) {\n      return null;\n    }\n    return {\n      position: this._visibleData.showAtPosition,\n      secondaryPosition: this._visibleData.showAtSecondaryPosition,\n      positionAffinity: this._visibleData.isBeforeContent ? 3 /* PositionAffinity.LeftOfInjectedText */ : undefined,\n      preference: [(_a = this._positionPreference) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */]\n    };\n  }\n  showAt(node, hoverData) {\n    var _a, _b, _c, _d;\n    if (!this._editor || !this._editor.hasModel()) {\n      return;\n    }\n    this._render(node, hoverData);\n    const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);\n    const widgetPosition = hoverData.showAtPosition;\n    this._positionPreference = (_a = this._findPositionPreference(widgetHeight, widgetPosition)) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */;\n    // See https://github.com/microsoft/vscode/issues/140339\n    // TODO: Doing a second layout of the hover after force rendering the editor\n    this.onContentsChanged();\n    if (hoverData.stoleFocus) {\n      this._hover.containerDomNode.focus();\n    }\n    (_b = hoverData.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();\n    // The aria label overrides the label, so if we add to it, add the contents of the hover\n    const hoverFocused = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode;\n    const accessibleViewHint = hoverFocused && getHoverAccessibleViewHint(this._configurationService.getValue('accessibility.verbosity.hover') === true && this._accessibilityService.isScreenReaderOptimized(), (_d = (_c = this._keybindingService.lookupKeybinding('editor.action.accessibleView')) === null || _c === void 0 ? void 0 : _c.getAriaLabel()) !== null && _d !== void 0 ? _d : '');\n    if (accessibleViewHint) {\n      this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ', ' + accessibleViewHint;\n    }\n  }\n  hide() {\n    if (!this._visibleData) {\n      return;\n    }\n    const stoleFocus = this._visibleData.stoleFocus || this._hoverFocusedKey.get();\n    this._setHoverData(undefined);\n    this._resizableNode.maxSize = new dom.Dimension(Infinity, Infinity);\n    this._resizableNode.clearSashHoverState();\n    this._hoverFocusedKey.set(false);\n    this._editor.layoutContentWidget(this);\n    if (stoleFocus) {\n      this._editor.focus();\n    }\n  }\n  _removeConstraintsRenderNormally() {\n    // Added because otherwise the initial size of the hover content is smaller than should be\n    const layoutInfo = this._editor.getLayoutInfo();\n    this._resizableNode.layout(layoutInfo.height, layoutInfo.width);\n    this._setHoverWidgetDimensions('auto', 'auto');\n  }\n  _adjustHoverHeightForScrollbar(height) {\n    var _a;\n    const containerDomNode = this._hover.containerDomNode;\n    const contentsDomNode = this._hover.contentsDomNode;\n    const maxRenderingHeight = (_a = this._findMaximumRenderingHeight()) !== null && _a !== void 0 ? _a : Infinity;\n    this._setContainerDomNodeDimensions(dom.getTotalWidth(containerDomNode), Math.min(maxRenderingHeight, height));\n    this._setContentsDomNodeDimensions(dom.getTotalWidth(contentsDomNode), Math.min(maxRenderingHeight, height - SCROLLBAR_WIDTH));\n  }\n  setMinimumDimensions(dimensions) {\n    // We combine the new minimum dimensions with the previous ones\n    this._minimumSize = new dom.Dimension(Math.max(this._minimumSize.width, dimensions.width), Math.max(this._minimumSize.height, dimensions.height));\n    this._updateMinimumWidth();\n  }\n  _updateMinimumWidth() {\n    const width = typeof this._contentWidth === 'undefined' ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);\n    // We want to avoid that the hover is artificially large, so we use the content width as minimum width\n    this._resizableNode.minSize = new dom.Dimension(width, this._minimumSize.height);\n  }\n  onContentsChanged() {\n    var _a;\n    this._removeConstraintsRenderNormally();\n    const containerDomNode = this._hover.containerDomNode;\n    let height = dom.getTotalHeight(containerDomNode);\n    let width = dom.getTotalWidth(containerDomNode);\n    this._resizableNode.layout(height, width);\n    this._setHoverWidgetDimensions(width, height);\n    height = dom.getTotalHeight(containerDomNode);\n    width = dom.getTotalWidth(containerDomNode);\n    this._contentWidth = width;\n    this._updateMinimumWidth();\n    this._resizableNode.layout(height, width);\n    if (this._hasHorizontalScrollbar()) {\n      this._adjustContentsBottomPadding();\n      this._adjustHoverHeightForScrollbar(height);\n    }\n    if ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition) {\n      const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);\n      this._positionPreference = this._findPositionPreference(widgetHeight, this._visibleData.showAtPosition);\n    }\n    this._layoutContentWidget();\n  }\n  focus() {\n    this._hover.containerDomNode.focus();\n  }\n  scrollUp() {\n    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n    const fontInfo = this._editor.getOption(50 /* EditorOption.fontInfo */);\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: scrollTop - fontInfo.lineHeight\n    });\n  }\n  scrollDown() {\n    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n    const fontInfo = this._editor.getOption(50 /* EditorOption.fontInfo */);\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: scrollTop + fontInfo.lineHeight\n    });\n  }\n  scrollLeft() {\n    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;\n    this._hover.scrollbar.setScrollPosition({\n      scrollLeft: scrollLeft - HORIZONTAL_SCROLLING_BY\n    });\n  }\n  scrollRight() {\n    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;\n    this._hover.scrollbar.setScrollPosition({\n      scrollLeft: scrollLeft + HORIZONTAL_SCROLLING_BY\n    });\n  }\n  pageUp() {\n    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: scrollTop - scrollHeight\n    });\n  }\n  pageDown() {\n    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: scrollTop + scrollHeight\n    });\n  }\n  goToTop() {\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: 0\n    });\n  }\n  goToBottom() {\n    this._hover.scrollbar.setScrollPosition({\n      scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight\n    });\n  }\n};\nContentHoverWidget.ID = 'editor.contrib.resizableContentHoverWidget';\nContentHoverWidget._lastDimensions = new dom.Dimension(0, 0);\nContentHoverWidget = ContentHoverWidget_1 = __decorate([__param(1, IContextKeyService), __param(2, IConfigurationService), __param(3, IAccessibilityService), __param(4, IKeybindingService)], ContentHoverWidget);\nexport { ContentHoverWidget };\nlet EditorHoverStatusBar = class EditorHoverStatusBar extends Disposable {\n  get hasContent() {\n    return this._hasContent;\n  }\n  constructor(_keybindingService) {\n    super();\n    this._keybindingService = _keybindingService;\n    this._hasContent = false;\n    this.hoverElement = $('div.hover-row.status-bar');\n    this.actionsElement = dom.append(this.hoverElement, $('div.actions'));\n  }\n  addAction(actionOptions) {\n    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);\n    const keybindingLabel = keybinding ? keybinding.getLabel() : null;\n    this._hasContent = true;\n    return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));\n  }\n  append(element) {\n    const result = dom.append(this.actionsElement, element);\n    this._hasContent = true;\n    return result;\n  }\n};\nEditorHoverStatusBar = __decorate([__param(0, IKeybindingService)], EditorHoverStatusBar);\nexport { EditorHoverStatusBar };\nclass ContentHoverComputer {\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    this._anchor = value;\n  }\n  get shouldFocus() {\n    return this._shouldFocus;\n  }\n  set shouldFocus(value) {\n    this._shouldFocus = value;\n  }\n  get source() {\n    return this._source;\n  }\n  set source(value) {\n    this._source = value;\n  }\n  get insistOnKeepingHoverVisible() {\n    return this._insistOnKeepingHoverVisible;\n  }\n  set insistOnKeepingHoverVisible(value) {\n    this._insistOnKeepingHoverVisible = value;\n  }\n  constructor(_editor, _participants) {\n    this._editor = _editor;\n    this._participants = _participants;\n    this._anchor = null;\n    this._shouldFocus = false;\n    this._source = 0 /* HoverStartSource.Mouse */;\n    this._insistOnKeepingHoverVisible = false;\n  }\n  static _getLineDecorations(editor, anchor) {\n    if (anchor.type !== 1 /* HoverAnchorType.Range */ && !anchor.supportsMarkerHover) {\n      return [];\n    }\n    const model = editor.getModel();\n    const lineNumber = anchor.range.startLineNumber;\n    if (lineNumber > model.getLineCount()) {\n      // invalid line\n      return [];\n    }\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    return editor.getLineDecorations(lineNumber).filter(d => {\n      if (d.options.isWholeLine) {\n        return true;\n      }\n      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;\n      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;\n      if (d.options.showIfCollapsed) {\n        // Relax check around `showIfCollapsed` decorations to also include +/- 1 character\n        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {\n          return false;\n        }\n      } else {\n        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n  computeAsync(token) {\n    const anchor = this._anchor;\n    if (!this._editor.hasModel() || !anchor) {\n      return AsyncIterableObject.EMPTY;\n    }\n    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, anchor);\n    return AsyncIterableObject.merge(this._participants.map(participant => {\n      if (!participant.computeAsync) {\n        return AsyncIterableObject.EMPTY;\n      }\n      return participant.computeAsync(anchor, lineDecorations, token);\n    }));\n  }\n  computeSync() {\n    if (!this._editor.hasModel() || !this._anchor) {\n      return [];\n    }\n    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, this._anchor);\n    let result = [];\n    for (const participant of this._participants) {\n      result = result.concat(participant.computeSync(this._anchor, lineDecorations));\n    }\n    return coalesce(result);\n  }\n}\nfunction computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {\n  const x = left + width / 2; // x center of rectangle\n  const y = top + height / 2; // y center of rectangle\n  const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);\n  const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);\n  return Math.sqrt(dx * dx + dy * dy);\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ContentHoverController_1","ContentHoverWidget_1","dom","HoverAction","HoverWidget","getHoverAccessibleViewHint","coalesce","Disposable","DisposableStore","toDisposable","Position","Range","ModelDecorationOptions","TokenizationRegistry","HoverOperation","HoverParticipantRegistry","HoverRangeAnchor","IInstantiationService","IKeybindingService","AsyncIterableObject","EditorContextKeys","IContextKeyService","ResizableContentWidget","IConfigurationService","IAccessibilityService","$","ContentHoverController","constructor","_editor","_instantiationService","_keybindingService","_currentResult","_widget","_register","createInstance","ContentHoverWidget","_participants","participant","getAll","push","sort","p1","p2","hoverOrdinal","_computer","ContentHoverComputer","_hoverOperation","onResult","result","anchor","messages","hasLoadingMessage","_addLoadingMessage","value","_withResult","HoverResult","isComplete","addStandardDisposableListener","getDomNode","e","equals","hide","onDidChange","position","_setCurrentResult","widget","maybeShowAt","mouseEvent","isResizing","anchorCandidates","suggestHoverAnchor","type","range","event","posx","posy","epsilon","getOption","typicalHalfwidthCharacterWidth","detail","isAfterLines","horizontalDistanceToText","_startShowingOrUpdateHover","a","b","priority","startShowingAtRange","mode","source","focus","undefined","_startHoverOperationIfNecessary","hoverIsSticky","sticky","isGettingCloser","isMouseGettingCloser","canAdoptVisibleHover","filter","insistOnKeepingHoverVisible","cancel","shouldFocus","start","hoverResult","_renderMessages","isColorPickerVisible","isVisibleFromKeyboard","isVisible","isFocused","containsNode","node","contains","createLoadingMessage","loadingMessage","slice","concat","showAtPosition","showAtSecondaryPosition","highlightRange","computeHoverRanges","disposables","statusBar","add","EditorHoverStatusBar","fragment","document","createDocumentFragment","colorPicker","context","setColorPicker","onContentsChanged","setMinimumDimensions","dimensions","hoverParts","msg","owner","renderHoverParts","isBeforeContent","some","m","hasContent","appendChild","hoverElement","hasChildNodes","highlightDecoration","createDecorationsCollection","set","options","_DECORATION_OPTIONS","clear","showAt","ContentHoverVisibleData","above","initialMousePosX","initialMousePosY","dispose","editor","anchorRange","startColumnBoundary","hasModel","viewModel","_getViewModel","coordinatesConverter","anchorViewRange","convertModelRangeToViewRange","anchorViewRangeStart","startLineNumber","getLineMinColumn","convertViewPositionToModelPosition","column","anchorLineNumber","renderStartColumn","startColumn","forceShowAtRange","plusRange","endLineNumber","Math","max","min","getStartPosition","scrollUp","scrollDown","scrollLeft","scrollRight","pageUp","pageDown","goToTop","goToBottom","register","description","className","filteredMessages","isValidForHoverAnchor","FilteredHoverResult","original","preferAbove","stoleFocus","closestMouseDistance","HORIZONTAL_SCROLLING_BY","SCROLLBAR_WIDTH","CONTAINER_HEIGHT_PADDING","_a","Boolean","_visibleData","_hoverVisibleKey","get","_hoverFocusedKey","contextKeyService","_configurationService","_accessibilityService","minimumHeight","minimumWidth","minimumSize","Dimension","_hover","_minimumSize","hoverVisible","bindTo","hoverFocused","append","_resizableNode","domNode","containerDomNode","style","zIndex","onDidLayoutChange","_updateMaxDimensions","onDidChangeConfiguration","hasChanged","_updateFont","focusTracker","trackFocus","onDidFocus","onDidBlur","_setHoverData","addContentWidget","removeContentWidget","getId","ID","_applyDimensions","container","width","height","transformedWidth","transformedHeight","_setContentsDomNodeDimensions","contentsDomNode","_setContainerDomNodeDimensions","_setHoverWidgetDimensions","_layoutContentWidget","_applyMaxDimensions","maxWidth","maxHeight","_setHoverWidgetMaxDimensions","setProperty","_hasHorizontalScrollbar","scrollDimensions","scrollbar","getScrollDimensions","hasHorizontalScrollbar","scrollWidth","_adjustContentsBottomPadding","extraBottomPadding","horizontalScrollbarSize","paddingBottom","_setAdjustedHoverWidgetDimensions","size","_updateResizableNodeMaxDimensions","_b","maxRenderingWidth","_findMaximumRenderingWidth","Infinity","maxRenderingHeight","_findMaximumRenderingHeight","maxSize","_resize","_lastDimensions","layout","scanDomNode","layoutContentWidget","_findAvailableSpaceVertically","_positionPreference","_availableVerticalSpaceAbove","_availableVerticalSpaceBelow","availableSpace","maximumHeight","Array","from","children","forEach","hoverPart","clientHeight","_isHoverTextOverflowing","overflowing","clientWidth","removeProperty","initialWidth","_contentWidth","bodyBoxWidth","getClientArea","ownerDocument","body","horizontalPadding","widgetRect","getDomNodePagePosition","computeDistanceFromPointToRectangle","left","top","distance","hoverData","classList","toggle","fontSize","lineHeight","codeClasses","prototype","call","getElementsByClassName","applyFontInfo","_updateContent","textContent","getLayoutInfo","_render","render","getPosition","secondaryPosition","positionAffinity","preference","_c","_d","widgetHeight","getTotalHeight","widgetPosition","_findPositionPreference","activeElement","accessibleViewHint","getValue","isScreenReaderOptimized","lookupKeybinding","getAriaLabel","ariaLabel","clearSashHoverState","_removeConstraintsRenderNormally","layoutInfo","_adjustHoverHeightForScrollbar","getTotalWidth","_updateMinimumWidth","minSize","scrollTop","getScrollPosition","fontInfo","setScrollPosition","scrollHeight","_hasContent","actionsElement","addAction","actionOptions","keybinding","commandId","keybindingLabel","getLabel","element","_anchor","_shouldFocus","_source","_insistOnKeepingHoverVisible","_getLineDecorations","supportsMarkerHover","model","getModel","lineNumber","getLineCount","maxColumn","getLineMaxColumn","getLineDecorations","isWholeLine","endColumn","showIfCollapsed","computeAsync","token","EMPTY","lineDecorations","merge","map","computeSync","pointX","pointY","x","y","dx","abs","dy","sqrt"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ContentHoverController_1, ContentHoverWidget_1;\nimport * as dom from '../../../../base/browser/dom.js';\nimport { HoverAction, HoverWidget, getHoverAccessibleViewHint } from '../../../../base/browser/ui/hover/hoverWidget.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { TokenizationRegistry } from '../../../common/languages.js';\nimport { HoverOperation } from './hoverOperation.js';\nimport { HoverParticipantRegistry, HoverRangeAnchor } from './hoverTypes.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { AsyncIterableObject } from '../../../../base/common/async.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ResizableContentWidget } from './resizableContentWidget.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.js';\nconst $ = dom.$;\nlet ContentHoverController = ContentHoverController_1 = class ContentHoverController extends Disposable {\n    constructor(_editor, _instantiationService, _keybindingService) {\n        super();\n        this._editor = _editor;\n        this._instantiationService = _instantiationService;\n        this._keybindingService = _keybindingService;\n        this._currentResult = null;\n        this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));\n        // Instantiate participants and sort them by `hoverOrdinal` which is relevant for rendering order.\n        this._participants = [];\n        for (const participant of HoverParticipantRegistry.getAll()) {\n            this._participants.push(this._instantiationService.createInstance(participant, this._editor));\n        }\n        this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);\n        this._computer = new ContentHoverComputer(this._editor, this._participants);\n        this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));\n        this._register(this._hoverOperation.onResult((result) => {\n            if (!this._computer.anchor) {\n                // invalid state, ignore result\n                return;\n            }\n            const messages = (result.hasLoadingMessage ? this._addLoadingMessage(result.value) : result.value);\n            this._withResult(new HoverResult(this._computer.anchor, messages, result.isComplete));\n        }));\n        this._register(dom.addStandardDisposableListener(this._widget.getDomNode(), 'keydown', (e) => {\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                this.hide();\n            }\n        }));\n        this._register(TokenizationRegistry.onDidChange(() => {\n            if (this._widget.position && this._currentResult) {\n                this._setCurrentResult(this._currentResult); // render again\n            }\n        }));\n    }\n    get widget() {\n        return this._widget;\n    }\n    /**\n     * Returns true if the hover shows now or will show.\n     */\n    maybeShowAt(mouseEvent) {\n        if (this._widget.isResizing) {\n            return true;\n        }\n        const anchorCandidates = [];\n        for (const participant of this._participants) {\n            if (participant.suggestHoverAnchor) {\n                const anchor = participant.suggestHoverAnchor(mouseEvent);\n                if (anchor) {\n                    anchorCandidates.push(anchor);\n                }\n            }\n        }\n        const target = mouseEvent.target;\n        if (target.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n            anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));\n        }\n        if (target.type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n            const epsilon = this._editor.getOption(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth / 2;\n            if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === 'number' && target.detail.horizontalDistanceToText < epsilon) {\n                // Let hover kick in even when the mouse is technically in the empty area after a line, given the distance is small enough\n                anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));\n            }\n        }\n        if (anchorCandidates.length === 0) {\n            return this._startShowingOrUpdateHover(null, 0 /* HoverStartMode.Delayed */, 0 /* HoverStartSource.Mouse */, false, mouseEvent);\n        }\n        anchorCandidates.sort((a, b) => b.priority - a.priority);\n        return this._startShowingOrUpdateHover(anchorCandidates[0], 0 /* HoverStartMode.Delayed */, 0 /* HoverStartSource.Mouse */, false, mouseEvent);\n    }\n    startShowingAtRange(range, mode, source, focus) {\n        this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, undefined, undefined), mode, source, focus, null);\n    }\n    /**\n     * Returns true if the hover shows now or will show.\n     */\n    _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {\n        if (!this._widget.position || !this._currentResult) {\n            // The hover is not visible\n            if (anchor) {\n                this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n                return true;\n            }\n            return false;\n        }\n        // The hover is currently visible\n        const hoverIsSticky = this._editor.getOption(60 /* EditorOption.hover */).sticky;\n        const isGettingCloser = (hoverIsSticky && mouseEvent && this._widget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy));\n        if (isGettingCloser) {\n            // The mouse is getting closer to the hover, so we will keep the hover untouched\n            // But we will kick off a hover update at the new anchor, insisting on keeping the hover visible.\n            if (anchor) {\n                this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);\n            }\n            return true;\n        }\n        if (!anchor) {\n            this._setCurrentResult(null);\n            return false;\n        }\n        if (anchor && this._currentResult.anchor.equals(anchor)) {\n            // The widget is currently showing results for the exact same anchor, so no update is needed\n            return true;\n        }\n        if (!anchor.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position)) {\n            // The new anchor is not compatible with the previous anchor\n            this._setCurrentResult(null);\n            this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n            return true;\n        }\n        // We aren't getting any closer to the hover, so we will filter existing results\n        // and keep those which also apply to the new anchor.\n        this._setCurrentResult(this._currentResult.filter(anchor));\n        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);\n        return true;\n    }\n    _startHoverOperationIfNecessary(anchor, mode, source, focus, insistOnKeepingHoverVisible) {\n        if (this._computer.anchor && this._computer.anchor.equals(anchor)) {\n            // We have to start a hover operation at the exact same anchor as before, so no work is needed\n            return;\n        }\n        this._hoverOperation.cancel();\n        this._computer.anchor = anchor;\n        this._computer.shouldFocus = focus;\n        this._computer.source = source;\n        this._computer.insistOnKeepingHoverVisible = insistOnKeepingHoverVisible;\n        this._hoverOperation.start(mode);\n    }\n    _setCurrentResult(hoverResult) {\n        if (this._currentResult === hoverResult) {\n            // avoid updating the DOM to avoid resetting the user selection\n            return;\n        }\n        if (hoverResult && hoverResult.messages.length === 0) {\n            hoverResult = null;\n        }\n        this._currentResult = hoverResult;\n        if (this._currentResult) {\n            this._renderMessages(this._currentResult.anchor, this._currentResult.messages);\n        }\n        else {\n            this._widget.hide();\n        }\n    }\n    hide() {\n        this._computer.anchor = null;\n        this._hoverOperation.cancel();\n        this._setCurrentResult(null);\n    }\n    get isColorPickerVisible() {\n        return this._widget.isColorPickerVisible;\n    }\n    get isVisibleFromKeyboard() {\n        return this._widget.isVisibleFromKeyboard;\n    }\n    get isVisible() {\n        return this._widget.isVisible;\n    }\n    get isFocused() {\n        return this._widget.isFocused;\n    }\n    get isResizing() {\n        return this._widget.isResizing;\n    }\n    containsNode(node) {\n        return (node ? this._widget.getDomNode().contains(node) : false);\n    }\n    _addLoadingMessage(result) {\n        if (this._computer.anchor) {\n            for (const participant of this._participants) {\n                if (participant.createLoadingMessage) {\n                    const loadingMessage = participant.createLoadingMessage(this._computer.anchor);\n                    if (loadingMessage) {\n                        return result.slice(0).concat([loadingMessage]);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    _withResult(hoverResult) {\n        if (this._widget.position && this._currentResult && this._currentResult.isComplete) {\n            // The hover is visible with a previous complete result.\n            if (!hoverResult.isComplete) {\n                // Instead of rendering the new partial result, we wait for the result to be complete.\n                return;\n            }\n            if (this._computer.insistOnKeepingHoverVisible && hoverResult.messages.length === 0) {\n                // The hover would now hide normally, so we'll keep the previous messages\n                return;\n            }\n        }\n        this._setCurrentResult(hoverResult);\n    }\n    _renderMessages(anchor, messages) {\n        const { showAtPosition, showAtSecondaryPosition, highlightRange } = ContentHoverController_1.computeHoverRanges(this._editor, anchor.range, messages);\n        const disposables = new DisposableStore();\n        const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));\n        const fragment = document.createDocumentFragment();\n        let colorPicker = null;\n        const context = {\n            fragment,\n            statusBar,\n            setColorPicker: (widget) => colorPicker = widget,\n            onContentsChanged: () => this._widget.onContentsChanged(),\n            setMinimumDimensions: (dimensions) => this._widget.setMinimumDimensions(dimensions),\n            hide: () => this.hide()\n        };\n        for (const participant of this._participants) {\n            const hoverParts = messages.filter(msg => msg.owner === participant);\n            if (hoverParts.length > 0) {\n                disposables.add(participant.renderHoverParts(context, hoverParts));\n            }\n        }\n        const isBeforeContent = messages.some(m => m.isBeforeContent);\n        if (statusBar.hasContent) {\n            fragment.appendChild(statusBar.hoverElement);\n        }\n        if (fragment.hasChildNodes()) {\n            if (highlightRange) {\n                const highlightDecoration = this._editor.createDecorationsCollection();\n                highlightDecoration.set([{\n                        range: highlightRange,\n                        options: ContentHoverController_1._DECORATION_OPTIONS\n                    }]);\n                disposables.add(toDisposable(() => {\n                    highlightDecoration.clear();\n                }));\n            }\n            this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker, showAtPosition, showAtSecondaryPosition, this._editor.getOption(60 /* EditorOption.hover */).above, this._computer.shouldFocus, this._computer.source, isBeforeContent, anchor.initialMousePosX, anchor.initialMousePosY, disposables));\n        }\n        else {\n            disposables.dispose();\n        }\n    }\n    static computeHoverRanges(editor, anchorRange, messages) {\n        let startColumnBoundary = 1;\n        if (editor.hasModel()) {\n            // Ensure the range is on the current view line\n            const viewModel = editor._getViewModel();\n            const coordinatesConverter = viewModel.coordinatesConverter;\n            const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);\n            const anchorViewRangeStart = new Position(anchorViewRange.startLineNumber, viewModel.getLineMinColumn(anchorViewRange.startLineNumber));\n            startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;\n        }\n        // The anchor range is always on a single line\n        const anchorLineNumber = anchorRange.startLineNumber;\n        let renderStartColumn = anchorRange.startColumn;\n        let highlightRange = messages[0].range;\n        let forceShowAtRange = null;\n        for (const msg of messages) {\n            highlightRange = Range.plusRange(highlightRange, msg.range);\n            if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {\n                // this message has a range that is completely sitting on the line of the anchor\n                renderStartColumn = Math.max(Math.min(renderStartColumn, msg.range.startColumn), startColumnBoundary);\n            }\n            if (msg.forceShowAtRange) {\n                forceShowAtRange = msg.range;\n            }\n        }\n        return {\n            showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, anchorRange.startColumn),\n            showAtSecondaryPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, renderStartColumn),\n            highlightRange\n        };\n    }\n    focus() {\n        this._widget.focus();\n    }\n    scrollUp() {\n        this._widget.scrollUp();\n    }\n    scrollDown() {\n        this._widget.scrollDown();\n    }\n    scrollLeft() {\n        this._widget.scrollLeft();\n    }\n    scrollRight() {\n        this._widget.scrollRight();\n    }\n    pageUp() {\n        this._widget.pageUp();\n    }\n    pageDown() {\n        this._widget.pageDown();\n    }\n    goToTop() {\n        this._widget.goToTop();\n    }\n    goToBottom() {\n        this._widget.goToBottom();\n    }\n};\nContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({\n    description: 'content-hover-highlight',\n    className: 'hoverHighlight'\n});\nContentHoverController = ContentHoverController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IKeybindingService)\n], ContentHoverController);\nexport { ContentHoverController };\nclass HoverResult {\n    constructor(anchor, messages, isComplete) {\n        this.anchor = anchor;\n        this.messages = messages;\n        this.isComplete = isComplete;\n    }\n    filter(anchor) {\n        const filteredMessages = this.messages.filter((m) => m.isValidForHoverAnchor(anchor));\n        if (filteredMessages.length === this.messages.length) {\n            return this;\n        }\n        return new FilteredHoverResult(this, this.anchor, filteredMessages, this.isComplete);\n    }\n}\nclass FilteredHoverResult extends HoverResult {\n    constructor(original, anchor, messages, isComplete) {\n        super(anchor, messages, isComplete);\n        this.original = original;\n    }\n    filter(anchor) {\n        return this.original.filter(anchor);\n    }\n}\nclass ContentHoverVisibleData {\n    constructor(colorPicker, showAtPosition, showAtSecondaryPosition, preferAbove, stoleFocus, source, isBeforeContent, initialMousePosX, initialMousePosY, disposables) {\n        this.colorPicker = colorPicker;\n        this.showAtPosition = showAtPosition;\n        this.showAtSecondaryPosition = showAtSecondaryPosition;\n        this.preferAbove = preferAbove;\n        this.stoleFocus = stoleFocus;\n        this.source = source;\n        this.isBeforeContent = isBeforeContent;\n        this.initialMousePosX = initialMousePosX;\n        this.initialMousePosY = initialMousePosY;\n        this.disposables = disposables;\n        this.closestMouseDistance = undefined;\n    }\n}\nconst HORIZONTAL_SCROLLING_BY = 30;\nconst SCROLLBAR_WIDTH = 10;\nconst CONTAINER_HEIGHT_PADDING = 6;\nlet ContentHoverWidget = ContentHoverWidget_1 = class ContentHoverWidget extends ResizableContentWidget {\n    get isColorPickerVisible() {\n        var _a;\n        return Boolean((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker);\n    }\n    get isVisibleFromKeyboard() {\n        var _a;\n        return (((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.source) === 1 /* HoverStartSource.Keyboard */);\n    }\n    get isVisible() {\n        var _a;\n        return (_a = this._hoverVisibleKey.get()) !== null && _a !== void 0 ? _a : false;\n    }\n    get isFocused() {\n        var _a;\n        return (_a = this._hoverFocusedKey.get()) !== null && _a !== void 0 ? _a : false;\n    }\n    constructor(editor, contextKeyService, _configurationService, _accessibilityService, _keybindingService) {\n        const minimumHeight = editor.getOption(66 /* EditorOption.lineHeight */) + 8;\n        const minimumWidth = 150;\n        const minimumSize = new dom.Dimension(minimumWidth, minimumHeight);\n        super(editor, minimumSize);\n        this._configurationService = _configurationService;\n        this._accessibilityService = _accessibilityService;\n        this._keybindingService = _keybindingService;\n        this._hover = this._register(new HoverWidget());\n        this._minimumSize = minimumSize;\n        this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(contextKeyService);\n        this._hoverFocusedKey = EditorContextKeys.hoverFocused.bindTo(contextKeyService);\n        dom.append(this._resizableNode.domNode, this._hover.containerDomNode);\n        this._resizableNode.domNode.style.zIndex = '50';\n        this._register(this._editor.onDidLayoutChange(() => {\n            if (this.isVisible) {\n                this._updateMaxDimensions();\n            }\n        }));\n        this._register(this._editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(50 /* EditorOption.fontInfo */)) {\n                this._updateFont();\n            }\n        }));\n        const focusTracker = this._register(dom.trackFocus(this._resizableNode.domNode));\n        this._register(focusTracker.onDidFocus(() => {\n            this._hoverFocusedKey.set(true);\n        }));\n        this._register(focusTracker.onDidBlur(() => {\n            this._hoverFocusedKey.set(false);\n        }));\n        this._setHoverData(undefined);\n        this._editor.addContentWidget(this);\n    }\n    dispose() {\n        var _a;\n        super.dispose();\n        (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();\n        this._editor.removeContentWidget(this);\n    }\n    getId() {\n        return ContentHoverWidget_1.ID;\n    }\n    static _applyDimensions(container, width, height) {\n        const transformedWidth = typeof width === 'number' ? `${width}px` : width;\n        const transformedHeight = typeof height === 'number' ? `${height}px` : height;\n        container.style.width = transformedWidth;\n        container.style.height = transformedHeight;\n    }\n    _setContentsDomNodeDimensions(width, height) {\n        const contentsDomNode = this._hover.contentsDomNode;\n        return ContentHoverWidget_1._applyDimensions(contentsDomNode, width, height);\n    }\n    _setContainerDomNodeDimensions(width, height) {\n        const containerDomNode = this._hover.containerDomNode;\n        return ContentHoverWidget_1._applyDimensions(containerDomNode, width, height);\n    }\n    _setHoverWidgetDimensions(width, height) {\n        this._setContentsDomNodeDimensions(width, height);\n        this._setContainerDomNodeDimensions(width, height);\n        this._layoutContentWidget();\n    }\n    static _applyMaxDimensions(container, width, height) {\n        const transformedWidth = typeof width === 'number' ? `${width}px` : width;\n        const transformedHeight = typeof height === 'number' ? `${height}px` : height;\n        container.style.maxWidth = transformedWidth;\n        container.style.maxHeight = transformedHeight;\n    }\n    _setHoverWidgetMaxDimensions(width, height) {\n        ContentHoverWidget_1._applyMaxDimensions(this._hover.contentsDomNode, width, height);\n        ContentHoverWidget_1._applyMaxDimensions(this._hover.containerDomNode, width, height);\n        this._hover.containerDomNode.style.setProperty('--vscode-hover-maxWidth', typeof width === 'number' ? `${width}px` : width);\n        this._layoutContentWidget();\n    }\n    _hasHorizontalScrollbar() {\n        const scrollDimensions = this._hover.scrollbar.getScrollDimensions();\n        const hasHorizontalScrollbar = scrollDimensions.scrollWidth > scrollDimensions.width;\n        return hasHorizontalScrollbar;\n    }\n    _adjustContentsBottomPadding() {\n        const contentsDomNode = this._hover.contentsDomNode;\n        const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;\n        if (contentsDomNode.style.paddingBottom !== extraBottomPadding) {\n            contentsDomNode.style.paddingBottom = extraBottomPadding;\n        }\n    }\n    _setAdjustedHoverWidgetDimensions(size) {\n        this._setHoverWidgetMaxDimensions('none', 'none');\n        const width = size.width;\n        const height = size.height;\n        this._setHoverWidgetDimensions(width, height);\n        // measure if widget has horizontal scrollbar after setting the dimensions\n        if (this._hasHorizontalScrollbar()) {\n            this._adjustContentsBottomPadding();\n            this._setContentsDomNodeDimensions(width, height - SCROLLBAR_WIDTH);\n        }\n    }\n    _updateResizableNodeMaxDimensions() {\n        var _a, _b;\n        const maxRenderingWidth = (_a = this._findMaximumRenderingWidth()) !== null && _a !== void 0 ? _a : Infinity;\n        const maxRenderingHeight = (_b = this._findMaximumRenderingHeight()) !== null && _b !== void 0 ? _b : Infinity;\n        this._resizableNode.maxSize = new dom.Dimension(maxRenderingWidth, maxRenderingHeight);\n        this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);\n    }\n    _resize(size) {\n        var _a, _b;\n        ContentHoverWidget_1._lastDimensions = new dom.Dimension(size.width, size.height);\n        this._setAdjustedHoverWidgetDimensions(size);\n        this._resizableNode.layout(size.height, size.width);\n        this._updateResizableNodeMaxDimensions();\n        this._hover.scrollbar.scanDomNode();\n        this._editor.layoutContentWidget(this);\n        (_b = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();\n    }\n    _findAvailableSpaceVertically() {\n        var _a;\n        const position = (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition;\n        if (!position) {\n            return;\n        }\n        return this._positionPreference === 1 /* ContentWidgetPositionPreference.ABOVE */ ? this._availableVerticalSpaceAbove(position) : this._availableVerticalSpaceBelow(position);\n    }\n    _findMaximumRenderingHeight() {\n        const availableSpace = this._findAvailableSpaceVertically();\n        if (!availableSpace) {\n            return;\n        }\n        // Padding needed in order to stop the resizing down to a smaller height\n        let maximumHeight = CONTAINER_HEIGHT_PADDING;\n        Array.from(this._hover.contentsDomNode.children).forEach((hoverPart) => {\n            maximumHeight += hoverPart.clientHeight;\n        });\n        if (this._hasHorizontalScrollbar()) {\n            maximumHeight += SCROLLBAR_WIDTH;\n        }\n        return Math.min(availableSpace, maximumHeight);\n    }\n    _isHoverTextOverflowing() {\n        // To find out if the text is overflowing, we will disable wrapping, check the widths, and then re-enable wrapping\n        this._hover.containerDomNode.style.setProperty('--vscode-hover-whiteSpace', 'nowrap');\n        this._hover.containerDomNode.style.setProperty('--vscode-hover-sourceWhiteSpace', 'nowrap');\n        const overflowing = Array.from(this._hover.contentsDomNode.children).some((hoverElement) => {\n            return hoverElement.scrollWidth > hoverElement.clientWidth;\n        });\n        this._hover.containerDomNode.style.removeProperty('--vscode-hover-whiteSpace');\n        this._hover.containerDomNode.style.removeProperty('--vscode-hover-sourceWhiteSpace');\n        return overflowing;\n    }\n    _findMaximumRenderingWidth() {\n        if (!this._editor || !this._editor.hasModel()) {\n            return;\n        }\n        const overflowing = this._isHoverTextOverflowing();\n        const initialWidth = (typeof this._contentWidth === 'undefined'\n            ? 0\n            : this._contentWidth - 2 // - 2 for the borders\n        );\n        if (overflowing || this._hover.containerDomNode.clientWidth < initialWidth) {\n            const bodyBoxWidth = dom.getClientArea(this._hover.containerDomNode.ownerDocument.body).width;\n            const horizontalPadding = 14;\n            return bodyBoxWidth - horizontalPadding;\n        }\n        else {\n            return this._hover.containerDomNode.clientWidth + 2;\n        }\n    }\n    isMouseGettingCloser(posx, posy) {\n        if (!this._visibleData) {\n            return false;\n        }\n        if (typeof this._visibleData.initialMousePosX === 'undefined' || typeof this._visibleData.initialMousePosY === 'undefined') {\n            this._visibleData.initialMousePosX = posx;\n            this._visibleData.initialMousePosY = posy;\n            return false;\n        }\n        const widgetRect = dom.getDomNodePagePosition(this.getDomNode());\n        if (typeof this._visibleData.closestMouseDistance === 'undefined') {\n            this._visibleData.closestMouseDistance = computeDistanceFromPointToRectangle(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);\n        }\n        const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);\n        if (distance > this._visibleData.closestMouseDistance + 4 /* tolerance of 4 pixels */) {\n            // The mouse is getting farther away\n            return false;\n        }\n        this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, distance);\n        return true;\n    }\n    _setHoverData(hoverData) {\n        var _a;\n        (_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.disposables.dispose();\n        this._visibleData = hoverData;\n        this._hoverVisibleKey.set(!!hoverData);\n        this._hover.containerDomNode.classList.toggle('hidden', !hoverData);\n    }\n    _updateFont() {\n        const { fontSize, lineHeight } = this._editor.getOption(50 /* EditorOption.fontInfo */);\n        const contentsDomNode = this._hover.contentsDomNode;\n        contentsDomNode.style.fontSize = `${fontSize}px`;\n        contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;\n        const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName('code'));\n        codeClasses.forEach(node => this._editor.applyFontInfo(node));\n    }\n    _updateContent(node) {\n        const contentsDomNode = this._hover.contentsDomNode;\n        contentsDomNode.style.paddingBottom = '';\n        contentsDomNode.textContent = '';\n        contentsDomNode.appendChild(node);\n    }\n    _layoutContentWidget() {\n        this._editor.layoutContentWidget(this);\n        this._hover.onContentsChanged();\n    }\n    _updateMaxDimensions() {\n        const height = Math.max(this._editor.getLayoutInfo().height / 4, 250, ContentHoverWidget_1._lastDimensions.height);\n        const width = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, ContentHoverWidget_1._lastDimensions.width);\n        this._setHoverWidgetMaxDimensions(width, height);\n    }\n    _render(node, hoverData) {\n        this._setHoverData(hoverData);\n        this._updateFont();\n        this._updateContent(node);\n        this._updateMaxDimensions();\n        this.onContentsChanged();\n        // Simply force a synchronous render on the editor\n        // such that the widget does not really render with left = '0px'\n        this._editor.render();\n    }\n    getPosition() {\n        var _a;\n        if (!this._visibleData) {\n            return null;\n        }\n        return {\n            position: this._visibleData.showAtPosition,\n            secondaryPosition: this._visibleData.showAtSecondaryPosition,\n            positionAffinity: this._visibleData.isBeforeContent ? 3 /* PositionAffinity.LeftOfInjectedText */ : undefined,\n            preference: [(_a = this._positionPreference) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */]\n        };\n    }\n    showAt(node, hoverData) {\n        var _a, _b, _c, _d;\n        if (!this._editor || !this._editor.hasModel()) {\n            return;\n        }\n        this._render(node, hoverData);\n        const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);\n        const widgetPosition = hoverData.showAtPosition;\n        this._positionPreference = (_a = this._findPositionPreference(widgetHeight, widgetPosition)) !== null && _a !== void 0 ? _a : 1 /* ContentWidgetPositionPreference.ABOVE */;\n        // See https://github.com/microsoft/vscode/issues/140339\n        // TODO: Doing a second layout of the hover after force rendering the editor\n        this.onContentsChanged();\n        if (hoverData.stoleFocus) {\n            this._hover.containerDomNode.focus();\n        }\n        (_b = hoverData.colorPicker) === null || _b === void 0 ? void 0 : _b.layout();\n        // The aria label overrides the label, so if we add to it, add the contents of the hover\n        const hoverFocused = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode;\n        const accessibleViewHint = hoverFocused && getHoverAccessibleViewHint(this._configurationService.getValue('accessibility.verbosity.hover') === true && this._accessibilityService.isScreenReaderOptimized(), (_d = (_c = this._keybindingService.lookupKeybinding('editor.action.accessibleView')) === null || _c === void 0 ? void 0 : _c.getAriaLabel()) !== null && _d !== void 0 ? _d : '');\n        if (accessibleViewHint) {\n            this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ', ' + accessibleViewHint;\n        }\n    }\n    hide() {\n        if (!this._visibleData) {\n            return;\n        }\n        const stoleFocus = this._visibleData.stoleFocus || this._hoverFocusedKey.get();\n        this._setHoverData(undefined);\n        this._resizableNode.maxSize = new dom.Dimension(Infinity, Infinity);\n        this._resizableNode.clearSashHoverState();\n        this._hoverFocusedKey.set(false);\n        this._editor.layoutContentWidget(this);\n        if (stoleFocus) {\n            this._editor.focus();\n        }\n    }\n    _removeConstraintsRenderNormally() {\n        // Added because otherwise the initial size of the hover content is smaller than should be\n        const layoutInfo = this._editor.getLayoutInfo();\n        this._resizableNode.layout(layoutInfo.height, layoutInfo.width);\n        this._setHoverWidgetDimensions('auto', 'auto');\n    }\n    _adjustHoverHeightForScrollbar(height) {\n        var _a;\n        const containerDomNode = this._hover.containerDomNode;\n        const contentsDomNode = this._hover.contentsDomNode;\n        const maxRenderingHeight = (_a = this._findMaximumRenderingHeight()) !== null && _a !== void 0 ? _a : Infinity;\n        this._setContainerDomNodeDimensions(dom.getTotalWidth(containerDomNode), Math.min(maxRenderingHeight, height));\n        this._setContentsDomNodeDimensions(dom.getTotalWidth(contentsDomNode), Math.min(maxRenderingHeight, height - SCROLLBAR_WIDTH));\n    }\n    setMinimumDimensions(dimensions) {\n        // We combine the new minimum dimensions with the previous ones\n        this._minimumSize = new dom.Dimension(Math.max(this._minimumSize.width, dimensions.width), Math.max(this._minimumSize.height, dimensions.height));\n        this._updateMinimumWidth();\n    }\n    _updateMinimumWidth() {\n        const width = (typeof this._contentWidth === 'undefined'\n            ? this._minimumSize.width\n            : Math.min(this._contentWidth, this._minimumSize.width));\n        // We want to avoid that the hover is artificially large, so we use the content width as minimum width\n        this._resizableNode.minSize = new dom.Dimension(width, this._minimumSize.height);\n    }\n    onContentsChanged() {\n        var _a;\n        this._removeConstraintsRenderNormally();\n        const containerDomNode = this._hover.containerDomNode;\n        let height = dom.getTotalHeight(containerDomNode);\n        let width = dom.getTotalWidth(containerDomNode);\n        this._resizableNode.layout(height, width);\n        this._setHoverWidgetDimensions(width, height);\n        height = dom.getTotalHeight(containerDomNode);\n        width = dom.getTotalWidth(containerDomNode);\n        this._contentWidth = width;\n        this._updateMinimumWidth();\n        this._resizableNode.layout(height, width);\n        if (this._hasHorizontalScrollbar()) {\n            this._adjustContentsBottomPadding();\n            this._adjustHoverHeightForScrollbar(height);\n        }\n        if ((_a = this._visibleData) === null || _a === void 0 ? void 0 : _a.showAtPosition) {\n            const widgetHeight = dom.getTotalHeight(this._hover.containerDomNode);\n            this._positionPreference = this._findPositionPreference(widgetHeight, this._visibleData.showAtPosition);\n        }\n        this._layoutContentWidget();\n    }\n    focus() {\n        this._hover.containerDomNode.focus();\n    }\n    scrollUp() {\n        const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n        const fontInfo = this._editor.getOption(50 /* EditorOption.fontInfo */);\n        this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - fontInfo.lineHeight });\n    }\n    scrollDown() {\n        const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n        const fontInfo = this._editor.getOption(50 /* EditorOption.fontInfo */);\n        this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + fontInfo.lineHeight });\n    }\n    scrollLeft() {\n        const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;\n        this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft - HORIZONTAL_SCROLLING_BY });\n    }\n    scrollRight() {\n        const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;\n        this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft + HORIZONTAL_SCROLLING_BY });\n    }\n    pageUp() {\n        const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n        const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;\n        this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - scrollHeight });\n    }\n    pageDown() {\n        const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;\n        const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;\n        this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + scrollHeight });\n    }\n    goToTop() {\n        this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });\n    }\n    goToBottom() {\n        this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });\n    }\n};\nContentHoverWidget.ID = 'editor.contrib.resizableContentHoverWidget';\nContentHoverWidget._lastDimensions = new dom.Dimension(0, 0);\nContentHoverWidget = ContentHoverWidget_1 = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, IConfigurationService),\n    __param(3, IAccessibilityService),\n    __param(4, IKeybindingService)\n], ContentHoverWidget);\nexport { ContentHoverWidget };\nlet EditorHoverStatusBar = class EditorHoverStatusBar extends Disposable {\n    get hasContent() {\n        return this._hasContent;\n    }\n    constructor(_keybindingService) {\n        super();\n        this._keybindingService = _keybindingService;\n        this._hasContent = false;\n        this.hoverElement = $('div.hover-row.status-bar');\n        this.actionsElement = dom.append(this.hoverElement, $('div.actions'));\n    }\n    addAction(actionOptions) {\n        const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);\n        const keybindingLabel = keybinding ? keybinding.getLabel() : null;\n        this._hasContent = true;\n        return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));\n    }\n    append(element) {\n        const result = dom.append(this.actionsElement, element);\n        this._hasContent = true;\n        return result;\n    }\n};\nEditorHoverStatusBar = __decorate([\n    __param(0, IKeybindingService)\n], EditorHoverStatusBar);\nexport { EditorHoverStatusBar };\nclass ContentHoverComputer {\n    get anchor() { return this._anchor; }\n    set anchor(value) { this._anchor = value; }\n    get shouldFocus() { return this._shouldFocus; }\n    set shouldFocus(value) { this._shouldFocus = value; }\n    get source() { return this._source; }\n    set source(value) { this._source = value; }\n    get insistOnKeepingHoverVisible() { return this._insistOnKeepingHoverVisible; }\n    set insistOnKeepingHoverVisible(value) { this._insistOnKeepingHoverVisible = value; }\n    constructor(_editor, _participants) {\n        this._editor = _editor;\n        this._participants = _participants;\n        this._anchor = null;\n        this._shouldFocus = false;\n        this._source = 0 /* HoverStartSource.Mouse */;\n        this._insistOnKeepingHoverVisible = false;\n    }\n    static _getLineDecorations(editor, anchor) {\n        if (anchor.type !== 1 /* HoverAnchorType.Range */ && !anchor.supportsMarkerHover) {\n            return [];\n        }\n        const model = editor.getModel();\n        const lineNumber = anchor.range.startLineNumber;\n        if (lineNumber > model.getLineCount()) {\n            // invalid line\n            return [];\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return editor.getLineDecorations(lineNumber).filter((d) => {\n            if (d.options.isWholeLine) {\n                return true;\n            }\n            const startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;\n            const endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;\n            if (d.options.showIfCollapsed) {\n                // Relax check around `showIfCollapsed` decorations to also include +/- 1 character\n                if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {\n                    return false;\n                }\n            }\n            else {\n                if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n    computeAsync(token) {\n        const anchor = this._anchor;\n        if (!this._editor.hasModel() || !anchor) {\n            return AsyncIterableObject.EMPTY;\n        }\n        const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, anchor);\n        return AsyncIterableObject.merge(this._participants.map((participant) => {\n            if (!participant.computeAsync) {\n                return AsyncIterableObject.EMPTY;\n            }\n            return participant.computeAsync(anchor, lineDecorations, token);\n        }));\n    }\n    computeSync() {\n        if (!this._editor.hasModel() || !this._anchor) {\n            return [];\n        }\n        const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, this._anchor);\n        let result = [];\n        for (const participant of this._participants) {\n            result = result.concat(participant.computeSync(this._anchor, lineDecorations));\n        }\n        return coalesce(result);\n    }\n}\nfunction computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {\n    const x = (left + width / 2); // x center of rectangle\n    const y = (top + height / 2); // y center of rectangle\n    const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);\n    const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);\n    return Math.sqrt(dx * dx + dy * dy);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}