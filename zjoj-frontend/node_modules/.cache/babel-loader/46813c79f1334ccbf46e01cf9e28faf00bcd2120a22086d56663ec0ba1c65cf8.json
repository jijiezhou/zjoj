{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */\n\nimport { h, s } from 'hastscript';\nimport { html, svg, find } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype;\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const options_ = options || {};\n  /** @type {Options} */\n  let settings;\n  /** @type {VFile | undefined} */\n  let file;\n  if (isFile(options_)) {\n    file = options_;\n    settings = {};\n  } else {\n    file = options_.file || undefined;\n    settings = options_;\n  }\n  return one({\n    schema: settings.space === 'svg' ? svg : html,\n    file,\n    verbose: settings.verbose,\n    location: false\n  }, tree);\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Node} */\n  let result;\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        const reference = /** @type {P5Comment} */node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#document':\n    case '#document-fragment':\n      {\n        const reference = /** @type {P5Document | P5DocumentFragment} */node;\n        const quirksMode = 'mode' in reference ? reference.mode === 'quirks' || reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode\n          }\n        };\n        if (state.file && state.location) {\n          const doc = String(state.file);\n          const loc = location(doc);\n          const start = loc.toPoint(0);\n          const end = loc.toPoint(doc.length);\n          // @ts-expect-error: always defined as we give valid input.\n          result.position = {\n            start,\n            end\n          };\n        }\n        return result;\n      }\n    case '#documentType':\n      {\n        const reference = /** @type {P5DocumentType} */node;\n        // @ts-expect-error Types are out of date.\n        result = {\n          type: 'doctype'\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#text':\n      {\n        const reference = /** @type {P5Text} */node;\n        result = {\n          type: 'text',\n          value: reference.value\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    // Element.\n    default:\n      {\n        const reference = /** @type {P5Element} */node;\n        result = element(state, reference);\n        return result;\n      }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1;\n  /** @type {Array<Content>} */\n  const result = [];\n  while (++index < nodes.length) {\n    // @ts-expect-error Assume no roots in `nodes`.\n    result[index] = one(state, nodes[index]);\n  }\n  return result;\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema;\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html;\n\n  // Props.\n  let index = -1;\n  /** @type {Record<string, string>} */\n  const props = {};\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index];\n    const name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value;\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h;\n  const result = fn(node.tagName, props, all(state, node.childNodes));\n  patch(state, node, result);\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */node;\n    const pos = reference.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = one(state, reference.content);\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n    result.content = content;\n  }\n  state.schema = schema;\n  return result;\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation);\n    if (position) {\n      state.location = true;\n      to.position = position;\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location);\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1];\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {};\n      /** @type {string} */\n      let key;\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n      node.data = {\n        position: {\n          // @ts-expect-error: assume not `undefined`.\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n  // @ts-expect-error `undefined` is fine.\n  return start || end ? {\n    start,\n    end\n  } : undefined;\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}\n\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */\nfunction isFile(value) {\n  return 'messages' in value;\n}","map":{"version":3,"names":["h","s","html","svg","find","location","webNamespaces","own","hasOwnProperty","proto","Object","prototype","fromParse5","tree","options","options_","settings","file","isFile","undefined","one","schema","space","verbose","state","node","result","nodeName","reference","type","value","data","patch","quirksMode","mode","children","all","childNodes","doc","String","loc","start","toPoint","end","length","position","element","nodes","index","namespaceURI","props","attrs","attribute","name","prefix","call","fn","tagName","pos","sourceCodeLocation","startTag","endTag","content","from","to","createLocation","tail","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const options_ = options || {}\n  /** @type {Options} */\n  let settings\n  /** @type {VFile | undefined} */\n  let file\n\n  if (isFile(options_)) {\n    file = options_\n    settings = {}\n  } else {\n    file = options_.file || undefined\n    settings = options_\n  }\n\n  return one(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Node} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {P5Comment} */ (node)\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference = /** @type {P5Document | P5DocumentFragment} */ (node)\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const doc = String(state.file)\n        const loc = location(doc)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(doc.length)\n        // @ts-expect-error: always defined as we give valid input.\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {P5DocumentType} */ (node)\n      // @ts-expect-error Types are out of date.\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {P5Text} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {P5Element} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<Content>} */\n  const result = []\n\n  while (++index < nodes.length) {\n    // @ts-expect-error Assume no roots in `nodes`.\n    result[index] = one(state, nodes[index])\n  }\n\n  return result\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const props = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h\n  const result = fn(node.tagName, props, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = one(state, reference.content)\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      node.data = {\n        position: {\n          // @ts-expect-error: assume not `undefined`.\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `undefined` is fine.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}