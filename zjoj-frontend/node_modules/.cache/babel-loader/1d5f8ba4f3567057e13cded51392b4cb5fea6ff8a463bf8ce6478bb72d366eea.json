{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n  constructor(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n  equals(otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  }\n}\nexport class RenderLineInput {\n  constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 4 /* RenderWhitespace.All */ : renderWhitespace === 'boundary' ? 1 /* RenderWhitespace.Boundary */ : renderWhitespace === 'selection' ? 2 /* RenderWhitespace.Selection */ : renderWhitespace === 'trailing' ? 3 /* RenderWhitespace.Trailing */ : 0 /* RenderWhitespace.None */;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n    const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n    const middotDiff = Math.abs(middotWidth - spaceWidth);\n    if (wsmiddotDiff < middotDiff) {\n      this.renderSpaceWidth = wsmiddotWidth;\n      this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n    } else {\n      this.renderSpaceWidth = middotWidth;\n      this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n    }\n  }\n  sameSelection(otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n    if (otherSelections === null) {\n      return false;\n    }\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n    for (let i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  equals(other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  }\n}\nexport class DomPosition {\n  constructor(partIndex, charIndex) {\n    this.partIndex = partIndex;\n    this.charIndex = charIndex;\n  }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n  static getPartIndex(partData) {\n    return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n  }\n  static getCharIndex(partData) {\n    return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n  }\n  constructor(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._horizontalOffset = new Uint32Array(this.length);\n  }\n  setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n    const partData = (partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */ | charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */) >>> 0;\n    this._data[column - 1] = partData;\n    this._horizontalOffset[column - 1] = horizontalOffset;\n  }\n  getHorizontalOffset(column) {\n    if (this._horizontalOffset.length === 0) {\n      // No characters on this line\n      return 0;\n    }\n    return this._horizontalOffset[column - 1];\n  }\n  charOffsetToPartData(charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n    return this._data[charOffset];\n  }\n  getDomPosition(column) {\n    const partData = this.charOffsetToPartData(column - 1);\n    const partIndex = CharacterMapping.getPartIndex(partData);\n    const charIndex = CharacterMapping.getCharIndex(partData);\n    return new DomPosition(partIndex, charIndex);\n  }\n  getColumn(domPosition, partLength) {\n    const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n    return charOffset + 1;\n  }\n  partDataToCharOffset(partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n    const searchEntry = (partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */ | charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */) >>> 0;\n    let min = 0;\n    let max = this.length - 1;\n    while (min + 1 < max) {\n      const mid = min + max >>> 1;\n      const midEntry = this._data[mid];\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n    if (min === max) {\n      return min;\n    }\n    const minEntry = this._data[min];\n    const maxEntry = this._data[max];\n    if (minEntry === searchEntry) {\n      return min;\n    }\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n    const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    let maxCharIndex;\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n    const minEntryDistance = charIndex - minCharIndex;\n    const maxEntryDistance = maxCharIndex - charIndex;\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n    return max;\n  }\n}\nexport class RenderLineOutput {\n  constructor(characterMapping, containsRTL, containsForeignElements) {\n    this._renderLineOutputBrand = undefined;\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n}\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      sb.appendString(`<span>`);\n      let beforeCount = 0;\n      let afterCount = 0;\n      let containsForeignElements = 0 /* ForeignElementType.None */;\n      for (const lineDecoration of input.lineDecorations) {\n        if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n          sb.appendString(`<span class=\"`);\n          sb.appendString(lineDecoration.className);\n          sb.appendString(`\"></span>`);\n          if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n            containsForeignElements |= 1 /* ForeignElementType.Before */;\n            beforeCount++;\n          }\n          if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n            containsForeignElements |= 2 /* ForeignElementType.After */;\n            afterCount++;\n          }\n        }\n      }\n      sb.appendString(`</span>`);\n      const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n      characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n      return new RenderLineOutput(characterMapping, false, containsForeignElements);\n    }\n    // completely empty line\n    sb.appendString('<span><span></span></span>');\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n  }\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n  constructor(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n}\nexport function renderViewLine2(input) {\n  const sb = new StringBuilder(10000);\n  const out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n  constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.overflowingCharCount = overflowingCharCount;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.fauxIndentLength = fauxIndentLength;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.renderSpaceCharCode = renderSpaceCharCode;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters;\n    //\n  }\n}\nfunction resolveRenderLineInput(input) {\n  const lineContent = input.lineContent;\n  let isOverflowing;\n  let overflowingCharCount;\n  let len;\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    overflowingCharCount = 0;\n    len = lineContent.length;\n  }\n  let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n  if (input.renderControlCharacters && !input.isBasicASCII) {\n    // Calling `extractControlCharacters` before adding (possibly empty) line parts\n    // for inline decorations. `extractControlCharacters` removes empty line parts.\n    tokens = extractControlCharacters(lineContent, tokens);\n  }\n  if (input.renderWhitespace === 4 /* RenderWhitespace.All */ || input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ || input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine || input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine) {\n    tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n  }\n  let containsForeignElements = 0 /* ForeignElementType.None */;\n  if (input.lineDecorations.length > 0) {\n    for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n      const lineDecoration = input.lineDecorations[i];\n      if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n        // Pretend there are foreign elements... although not 100% accurate.\n        containsForeignElements |= 1 /* ForeignElementType.Before */;\n      } else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n        containsForeignElements |= 1 /* ForeignElementType.Before */;\n      } else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n        containsForeignElements |= 2 /* ForeignElementType.After */;\n      }\n    }\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n  const result = [];\n  let resultLen = 0;\n  // The faux indent part of the line should have no token type\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n  }\n  let startOffset = fauxIndentLength;\n  for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    const endIndex = tokens.getEndOffset(tokenIndex);\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n    const type = tokens.getClassName(tokenIndex);\n    if (endIndex >= len) {\n      const tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false;\n      result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n      break;\n    }\n    const tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false;\n    result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n    startOffset = endIndex;\n  }\n  return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  let lastTokenEndIndex = 0;\n  const result = [];\n  let resultLen = 0;\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n      if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        let lastSpaceOffset = -1;\n        let currTokenStart = lastTokenEndIndex;\n        for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n            lastSpaceOffset = j;\n          }\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n            // Split at `lastSpaceOffset` + 1\n            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n            currTokenStart = lastSpaceOffset + 1;\n            lastSpaceOffset = -1;\n          }\n        }\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n      const diff = tokenEndIndex - lastTokenEndIndex;\n      if (diff > 50 /* Constants.LongToken */) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n        for (let j = 1; j < piecesCount; j++) {\n          const pieceEndIndex = lastTokenEndIndex + j * 50 /* Constants.LongToken */;\n          result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n        result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n  return result;\n}\nfunction isControlCharacter(charCode) {\n  if (charCode < 32) {\n    return charCode !== 9 /* CharCode.Tab */;\n  }\n  if (charCode === 127) {\n    // DEL\n    return true;\n  }\n  if (charCode >= 0x202A && charCode <= 0x202E || charCode >= 0x2066 && charCode <= 0x2069 || charCode >= 0x200E && charCode <= 0x200F || charCode === 0x061C) {\n    // Unicode Directional Formatting Characters\n    // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n    // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n    // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n    // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n    // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n    // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n    // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n    // FSI\tU+2068\tFIRST STRONG ISOLATE\n    // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n    // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n    // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n    // ALM\tU+061C\tARABIC LETTER MARK\n    return true;\n  }\n  return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n  const result = [];\n  let lastLinePart = new LinePart(0, '', 0, false);\n  let charOffset = 0;\n  for (const token of tokens) {\n    const tokenEndIndex = token.endIndex;\n    for (; charOffset < tokenEndIndex; charOffset++) {\n      const charCode = lineContent.charCodeAt(charOffset);\n      if (isControlCharacter(charCode)) {\n        if (charOffset > lastLinePart.endIndex) {\n          // emit previous part if it has text\n          lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n          result.push(lastLinePart);\n        }\n        lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n        result.push(lastLinePart);\n      }\n    }\n    if (charOffset > lastLinePart.endIndex) {\n      // emit previous part if it has text\n      lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n      result.push(lastLinePart);\n    }\n  }\n  return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n  const continuesWithWrappedLine = input.continuesWithWrappedLine;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const useMonospaceOptimizations = input.useMonospaceOptimizations;\n  const selections = input.selectionsOnLine;\n  const onlyBoundary = input.renderWhitespace === 1 /* RenderWhitespace.Boundary */;\n  const onlyTrailing = input.renderWhitespace === 3 /* RenderWhitespace.Trailing */;\n  const generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;\n  const result = [];\n  let resultLen = 0;\n  let tokenIndex = 0;\n  let tokenType = tokens[tokenIndex].type;\n  let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n  let tokenEndIndex = tokens[tokenIndex].endIndex;\n  const tokensLength = tokens.length;\n  let lineIsEmptyOrWhitespace = false;\n  let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  let lastNonWhitespaceIndex;\n  if (firstNonWhitespaceIndex === -1) {\n    lineIsEmptyOrWhitespace = true;\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n  let wasInWhitespace = false;\n  let currentSelectionIndex = 0;\n  let currentSelection = selections && selections[currentSelectionIndex];\n  let tmpIndent = startVisibleColumn % tabSize;\n  for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    const chCode = lineContent.charCodeAt(charIndex);\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n    let isInWhitespace;\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9 /* CharCode.Tab */) {\n      // a tab character is rendered both in all and boundary cases\n      isInWhitespace = true;\n    } else if (chCode === 32 /* CharCode.Space */) {\n      // hit a space character\n      if (onlyBoundary) {\n        // rendering only boundary whitespace\n        if (wasInWhitespace) {\n          isInWhitespace = true;\n        } else {\n          const nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */;\n          isInWhitespace = nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */;\n        }\n      } else {\n        isInWhitespace = true;\n      }\n    } else {\n      isInWhitespace = false;\n    }\n    // If rendering whitespace on selection, check that the charIndex falls within a selection\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n    // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n    if (isInWhitespace && onlyTrailing) {\n      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n    }\n    if (isInWhitespace && tokenContainsRTL) {\n      // If the token contains RTL text, breaking it up into multiple line parts\n      // to render whitespace might affect the browser's bidi layout.\n      //\n      // We render whitespace in such tokens only if the whitespace\n      // is the leading or the trailing whitespace of the line,\n      // which doesn't affect the browser's bidi layout.\n      if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n        isInWhitespace = false;\n      }\n    }\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        if (generateLinePartForEachWhitespace) {\n          const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n          for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n            result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n          }\n        } else {\n          result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n    if (chCode === 9 /* CharCode.Tab */) {\n      tmpIndent = tabSize;\n    } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n    wasInWhitespace = isInWhitespace;\n    while (charIndex === tokenEndIndex) {\n      tokenIndex++;\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenContainsRTL = tokens[tokenIndex].containsRTL;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      } else {\n        break;\n      }\n    }\n  }\n  let generateWhitespace = false;\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      const lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */;\n      const prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */;\n      const isSingleTrailingSpace = lastCharCode === 32 /* CharCode.Space */ && prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */;\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n  if (generateWhitespace) {\n    if (generateLinePartForEachWhitespace) {\n      const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n      for (let i = lastEndIndex + 1; i <= len; i++) {\n        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n      }\n    } else {\n      result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n    }\n  } else {\n    result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n  }\n  return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n  const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  const lineDecorationsLen = lineDecorations.length;\n  let lineDecorationIndex = 0;\n  const result = [];\n  let resultLen = 0;\n  let lastResultEndIndex = 0;\n  for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n    const token = tokens[tokenIndex];\n    const tokenEndIndex = token.endIndex;\n    const tokenType = token.type;\n    const tokenMetadata = token.metadata;\n    const tokenContainsRTL = token.containsRTL;\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      const lineDecoration = lineDecorations[lineDecorationIndex];\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n      }\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n        break;\n      }\n    }\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n    }\n  }\n  const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      const lineDecoration = lineDecorations[lineDecorationIndex];\n      result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n      lineDecorationIndex++;\n    }\n  }\n  return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n  const fontIsMonospace = input.fontIsMonospace;\n  const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  const containsForeignElements = input.containsForeignElements;\n  const lineContent = input.lineContent;\n  const len = input.len;\n  const isOverflowing = input.isOverflowing;\n  const overflowingCharCount = input.overflowingCharCount;\n  const parts = input.parts;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const containsRTL = input.containsRTL;\n  const spaceWidth = input.spaceWidth;\n  const renderSpaceCharCode = input.renderSpaceCharCode;\n  const renderWhitespace = input.renderWhitespace;\n  const renderControlCharacters = input.renderControlCharacters;\n  const characterMapping = new CharacterMapping(len + 1, parts.length);\n  let lastCharacterMappingDefined = false;\n  let charIndex = 0;\n  let visibleColumn = startVisibleColumn;\n  let charOffsetInPart = 0; // the character offset in the current part\n  let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n  let partDisplacement = 0;\n  if (containsRTL) {\n    sb.appendString('<span dir=\"ltr\">');\n  } else {\n    sb.appendString('<span>');\n  }\n  for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    const part = parts[partIndex];\n    const partEndIndex = part.endIndex;\n    const partType = part.type;\n    const partContainsRTL = part.containsRTL;\n    const partRendersWhitespace = renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace();\n    const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n    const partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.isPseudoAfter();\n    charOffsetInPart = 0;\n    sb.appendString('<span ');\n    if (partContainsRTL) {\n      sb.appendString('style=\"unicode-bidi:isolate\" ');\n    }\n    sb.appendString('class=\"');\n    sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n    sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n    if (partRendersWhitespace) {\n      let partWidth = 0;\n      {\n        let _charIndex = charIndex;\n        let _visibleColumn = visibleColumn;\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          const charCode = lineContent.charCodeAt(_charIndex);\n          const charWidth = (charCode === 9 /* CharCode.Tab */ ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partWidth += charWidth;\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n      if (partRendersWhitespaceWithWidth) {\n        sb.appendString(' style=\"width:');\n        sb.appendString(String(spaceWidth * partWidth));\n        sb.appendString('px\"');\n      }\n      sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let producedCharacters;\n        let charWidth;\n        if (charCode === 9 /* CharCode.Tab */) {\n          producedCharacters = tabSize - visibleColumn % tabSize | 0;\n          charWidth = producedCharacters;\n          if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n            sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n          } else {\n            sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n          }\n          for (let space = 2; space <= charWidth; space++) {\n            sb.appendCharCode(0xA0); // &nbsp;\n          }\n        } else {\n          // must be CharCode.Space\n          producedCharacters = 2;\n          charWidth = 1;\n          sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n          sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n        }\n        charOffsetInPart += producedCharacters;\n        charHorizontalOffset += charWidth;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n    } else {\n      sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n          case 9 /* CharCode.Tab */:\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            charWidth = producedCharacters;\n            for (let space = 1; space <= producedCharacters; space++) {\n              sb.appendCharCode(0xA0); // &nbsp;\n            }\n            break;\n          case 32 /* CharCode.Space */:\n            sb.appendCharCode(0xA0); // &nbsp;\n            break;\n          case 60 /* CharCode.LessThan */:\n            sb.appendString('&lt;');\n            break;\n          case 62 /* CharCode.GreaterThan */:\n            sb.appendString('&gt;');\n            break;\n          case 38 /* CharCode.Ampersand */:\n            sb.appendString('&amp;');\n            break;\n          case 0 /* CharCode.Null */:\n            if (renderControlCharacters) {\n              // See https://unicode-table.com/en/blocks/control-pictures/\n              sb.appendCharCode(9216);\n            } else {\n              sb.appendString('&#00;');\n            }\n            break;\n          case 65279 /* CharCode.UTF8_BOM */:\n          case 8232 /* CharCode.LINE_SEPARATOR */:\n          case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n          case 133 /* CharCode.NEXT_LINE */:\n            sb.appendCharCode(0xFFFD);\n            break;\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              charWidth++;\n            }\n            // See https://unicode-table.com/en/blocks/control-pictures/\n            if (renderControlCharacters && charCode < 32) {\n              sb.appendCharCode(9216 + charCode);\n            } else if (renderControlCharacters && charCode === 127) {\n              // DEL\n              sb.appendCharCode(9249);\n            } else if (renderControlCharacters && isControlCharacter(charCode)) {\n              sb.appendString('[U+');\n              sb.appendString(to4CharHex(charCode));\n              sb.appendString(']');\n              producedCharacters = 8;\n              charWidth = producedCharacters;\n            } else {\n              sb.appendCharCode(charCode);\n            }\n        }\n        charOffsetInPart += producedCharacters;\n        charHorizontalOffset += charWidth;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n    }\n    if (partIsEmptyAndHasPseudoAfter) {\n      partDisplacement++;\n    } else {\n      partDisplacement = 0;\n    }\n    if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n      lastCharacterMappingDefined = true;\n      characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n    }\n    sb.appendString('</span>');\n  }\n  if (!lastCharacterMappingDefined) {\n    // When getting client rects for the last character, we will position the\n    // text range at the end of the span, insteaf of at the beginning of next span\n    characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n  }\n  if (isOverflowing) {\n    sb.appendString('<span class=\"mtkoverflow\">');\n    sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n    sb.appendString('</span>');\n  }\n  sb.appendString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n  return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n  if (n < 1024) {\n    return nls.localize('overflow.chars', \"{0} chars\", n);\n  }\n  if (n < 1024 * 1024) {\n    return `${(n / 1024).toFixed(1)} KB`;\n  }\n  return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}","map":{"version":3,"names":["nls","strings","StringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","LineRange","constructor","startIndex","endIndex","startOffset","endOffset","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","length","i","other","equalsArr","DomPosition","partIndex","charIndex","CharacterMapping","getPartIndex","partData","getCharIndex","partCount","_data","Uint32Array","_horizontalOffset","setColumnInfo","column","horizontalOffset","getHorizontalOffset","charOffsetToPartData","charOffset","getDomPosition","getColumn","domPosition","partLength","partDataToCharOffset","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","undefined","renderViewLine","input","sb","appendString","beforeCount","afterCount","lineDecoration","type","className","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","len","isOverflowing","overflowingCharCount","parts","tokens","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","lineContainsRTL","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","tokenContainsRTL","substring","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","metadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","isControlCharacter","charCode","lastLinePart","push","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","visibleColumn","charOffsetInPart","charHorizontalOffset","partDisplacement","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCIICharCode","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","appendCharCode","space","to4CharHex","localize","renderOverflowingCharCount","n","toString","toUpperCase","padStart","toFixed"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return nls.localize('overflow.chars', \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}