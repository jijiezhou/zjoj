{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport { ModelLineProjectionData } from '../../common/modelLineProjectionData.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nconst ttPolicy = createTrustedTypesPolicy('domLineBreaksComputer', {\n  createHTML: value => value\n});\nexport class DOMLineBreaksComputerFactory {\n  static create(targetWindow) {\n    return new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));\n  }\n  constructor(targetWindow) {\n    this.targetWindow = targetWindow;\n  }\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n    const requests = [];\n    const injectedTexts = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        requests.push(lineText);\n        injectedTexts.push(injectedText);\n      },\n      finalize: () => {\n        return createLineBreaks(assertIsDefined(this.targetWindow.deref()), requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak, injectedTexts);\n      }\n    };\n  }\n}\nfunction createLineBreaks(targetWindow, requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {\n  var _a;\n  function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n    const injectedTexts = injectedTextsPerLine[requestIdx];\n    if (injectedTexts) {\n      const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n      const injectionOptions = injectedTexts.map(t => t.options);\n      const injectionOffsets = injectedTexts.map(text => text.column - 1);\n      // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n      // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n      return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    } else {\n      return null;\n    }\n  }\n  if (firstLineBreakColumn === -1) {\n    const result = [];\n    for (let i = 0, len = requests.length; i < len; i++) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n    }\n    return result;\n  }\n  const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  const additionalIndent = wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0;\n  const additionalIndentSize = Math.round(tabSize * additionalIndent);\n  const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n  const containerDomNode = document.createElement('div');\n  applyFontInfo(containerDomNode, fontInfo);\n  const sb = new StringBuilder(10000);\n  const firstNonWhitespaceIndices = [];\n  const wrappedTextIndentLengths = [];\n  const renderLineContents = [];\n  const allCharOffsets = [];\n  const allVisibleColumns = [];\n  for (let i = 0; i < requests.length; i++) {\n    const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n    let firstNonWhitespaceIndex = 0;\n    let wrappedTextIndentLength = 0;\n    let width = overallWidth;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n          const charWidth = lineContent.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n        const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n        // Force sticking to beginning of line if no character would fit except for the indentation\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n    const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n  const html = sb.build();\n  const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  if (wordBreak === 'keepAll') {\n    // word-break: keep-all; overflow-wrap: anywhere\n    containerDomNode.style.wordBreak = 'keep-all';\n    containerDomNode.style.overflowWrap = 'anywhere';\n  } else {\n    // overflow-wrap: break-word\n    containerDomNode.style.wordBreak = 'inherit';\n    containerDomNode.style.overflowWrap = 'break-word';\n  }\n  targetWindow.document.body.appendChild(containerDomNode);\n  const range = document.createRange();\n  const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  const result = [];\n  for (let i = 0; i < requests.length; i++) {\n    const lineDomNode = lineDomNodes[i];\n    const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n    if (breakOffsets === null) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n      continue;\n    }\n    const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n    const visibleColumns = allVisibleColumns[i];\n    const breakOffsetsVisibleColumn = [];\n    for (let j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (let j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n    let injectionOptions;\n    let injectionOffsets;\n    const curInjectedTexts = injectedTextsPerLine[i];\n    if (curInjectedTexts) {\n      injectionOptions = curInjectedTexts.map(t => t.options);\n      injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n    } else {\n      injectionOptions = null;\n      injectionOffsets = null;\n    }\n    result[i] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n  }\n  targetWindow.document.body.removeChild(containerDomNode);\n  return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n  if (wrappingIndentLength !== 0) {\n    const hangingOffset = String(wrappingIndentLength);\n    sb.appendString('<div style=\"text-indent: -');\n    sb.appendString(hangingOffset);\n    sb.appendString('px; padding-left: ');\n    sb.appendString(hangingOffset);\n    sb.appendString('px; box-sizing: border-box; width:');\n  } else {\n    sb.appendString('<div style=\"width:');\n  }\n  sb.appendString(String(width));\n  sb.appendString('px;\">');\n  // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n  const len = lineContent.length;\n  let visibleColumn = initialVisibleColumn;\n  let charOffset = 0;\n  const charOffsets = [];\n  const visibleColumns = [];\n  let nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0 /* CharCode.Null */;\n  sb.appendString('<span>');\n  for (let charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384 /* Constants.SPAN_MODULO_LIMIT */ === 0) {\n      sb.appendString('</span><span>');\n    }\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    const charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */;\n    let producedCharacters = 1;\n    let charWidth = 1;\n    switch (charCode) {\n      case 9 /* CharCode.Tab */:\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n        for (let space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.appendCharCode(0xA0); // &nbsp;\n          } else {\n            sb.appendASCIICharCode(32 /* CharCode.Space */);\n          }\n        }\n        break;\n      case 32 /* CharCode.Space */:\n        if (nextCharCode === 32 /* CharCode.Space */) {\n          sb.appendCharCode(0xA0); // &nbsp;\n        } else {\n          sb.appendASCIICharCode(32 /* CharCode.Space */);\n        }\n        break;\n      case 60 /* CharCode.LessThan */:\n        sb.appendString('&lt;');\n        break;\n      case 62 /* CharCode.GreaterThan */:\n        sb.appendString('&gt;');\n        break;\n      case 38 /* CharCode.Ampersand */:\n        sb.appendString('&amp;');\n        break;\n      case 0 /* CharCode.Null */:\n        sb.appendString('&#00;');\n        break;\n      case 65279 /* CharCode.UTF8_BOM */:\n      case 8232 /* CharCode.LINE_SEPARATOR */:\n      case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n      case 133 /* CharCode.NEXT_LINE */:\n        sb.appendCharCode(0xFFFD);\n        break;\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n        if (charCode < 32) {\n          sb.appendCharCode(9216 + charCode);\n        } else {\n          sb.appendCharCode(charCode);\n        }\n    }\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n  sb.appendString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendString('</div>');\n  return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n  const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  const breakOffsets = [];\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  }\n  // there is at least one line break between these two offsets\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n  const mid = low + (high - low) / 2 | 0;\n  const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */ | 0].firstChild, startOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n  range.setEnd(spans[endOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */ | 0].firstChild, endOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n  return range.getClientRects();\n}","map":{"version":3,"names":["createTrustedTypesPolicy","strings","assertIsDefined","applyFontInfo","StringBuilder","ModelLineProjectionData","LineInjectedText","ttPolicy","createHTML","value","DOMLineBreaksComputerFactory","create","targetWindow","WeakRef","constructor","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","wordBreak","requests","injectedTexts","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","createLineBreaks","deref","firstLineBreakColumn","injectedTextsPerLine","_a","createEmptyLineBreakWithPossiblyInjectedText","requestIdx","applyInjectedText","injectionOptions","map","t","options","injectionOffsets","text","column","length","result","i","len","overallWidth","Math","round","typicalHalfwidthCharacterWidth","additionalIndent","additionalIndentSize","additionalIndentLength","ceil","spaceWidth","containerDomNode","document","createElement","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","overflowWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","curInjectedTexts","removeChild","initialVisibleColumn","wrappingIndentLength","hangingOffset","String","appendString","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","appendCharCode","appendASCIICharCode","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport { ModelLineProjectionData } from '../../common/modelLineProjectionData.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nconst ttPolicy = createTrustedTypesPolicy('domLineBreaksComputer', { createHTML: value => value });\nexport class DOMLineBreaksComputerFactory {\n    static create(targetWindow) {\n        return new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));\n    }\n    constructor(targetWindow) {\n        this.targetWindow = targetWindow;\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n            },\n            finalize: () => {\n                return createLineBreaks(assertIsDefined(this.targetWindow.deref()), requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak, injectedTexts);\n            }\n        };\n    }\n}\nfunction createLineBreaks(targetWindow, requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {\n    var _a;\n    function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n        const injectedTexts = injectedTextsPerLine[requestIdx];\n        if (injectedTexts) {\n            const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n            const injectionOptions = injectedTexts.map(t => t.options);\n            const injectionOffsets = injectedTexts.map(text => text.column - 1);\n            // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n            // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n            return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n        }\n        else {\n            return null;\n        }\n    }\n    if (firstLineBreakColumn === -1) {\n        const result = [];\n        for (let i = 0, len = requests.length; i < len; i++) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n        }\n        return result;\n    }\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    const additionalIndent = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n    const additionalIndentSize = Math.round(tabSize * additionalIndent);\n    const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n    const containerDomNode = document.createElement('div');\n    applyFontInfo(containerDomNode, fontInfo);\n    const sb = new StringBuilder(10000);\n    const firstNonWhitespaceIndices = [];\n    const wrappedTextIndentLengths = [];\n    const renderLineContents = [];\n    const allCharOffsets = [];\n    const allVisibleColumns = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n        let firstNonWhitespaceIndex = 0;\n        let wrappedTextIndentLength = 0;\n        let width = overallWidth;\n        if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            if (firstNonWhitespaceIndex === -1) {\n                // all whitespace line\n                firstNonWhitespaceIndex = 0;\n            }\n            else {\n                // Track existing indent\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* CharCode.Tab */\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\n                        : 1);\n                    wrappedTextIndentLength += charWidth;\n                }\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n                    firstNonWhitespaceIndex = 0;\n                    wrappedTextIndentLength = 0;\n                }\n                else {\n                    width = overallWidth - indentWidth;\n                }\n            }\n        }\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n        renderLineContents[i] = renderLineContent;\n        allCharOffsets[i] = tmp[0];\n        allVisibleColumns[i] = tmp[1];\n    }\n    const html = sb.build();\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n    containerDomNode.innerHTML = trustedhtml;\n    containerDomNode.style.position = 'absolute';\n    containerDomNode.style.top = '10000';\n    if (wordBreak === 'keepAll') {\n        // word-break: keep-all; overflow-wrap: anywhere\n        containerDomNode.style.wordBreak = 'keep-all';\n        containerDomNode.style.overflowWrap = 'anywhere';\n    }\n    else {\n        // overflow-wrap: break-word\n        containerDomNode.style.wordBreak = 'inherit';\n        containerDomNode.style.overflowWrap = 'break-word';\n    }\n    targetWindow.document.body.appendChild(containerDomNode);\n    const range = document.createRange();\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n    const result = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineDomNode = lineDomNodes[i];\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n        if (breakOffsets === null) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n            continue;\n        }\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n        const visibleColumns = allVisibleColumns[i];\n        const breakOffsetsVisibleColumn = [];\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n        }\n        if (firstNonWhitespaceIndex !== 0) {\n            // All break offsets are relative to the renderLineContent, make them absolute again\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\n                breakOffsets[j] += firstNonWhitespaceIndex;\n            }\n        }\n        let injectionOptions;\n        let injectionOffsets;\n        const curInjectedTexts = injectedTextsPerLine[i];\n        if (curInjectedTexts) {\n            injectionOptions = curInjectedTexts.map(t => t.options);\n            injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n        }\n        else {\n            injectionOptions = null;\n            injectionOffsets = null;\n        }\n        result[i] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n    }\n    targetWindow.document.body.removeChild(containerDomNode);\n    return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n    if (wrappingIndentLength !== 0) {\n        const hangingOffset = String(wrappingIndentLength);\n        sb.appendString('<div style=\"text-indent: -');\n        sb.appendString(hangingOffset);\n        sb.appendString('px; padding-left: ');\n        sb.appendString(hangingOffset);\n        sb.appendString('px; box-sizing: border-box; width:');\n    }\n    else {\n        sb.appendString('<div style=\"width:');\n    }\n    sb.appendString(String(width));\n    sb.appendString('px;\">');\n    // if (containsRTL) {\n    // \tsb.appendASCIIString('\" dir=\"ltr');\n    // }\n    const len = lineContent.length;\n    let visibleColumn = initialVisibleColumn;\n    let charOffset = 0;\n    const charOffsets = [];\n    const visibleColumns = [];\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* CharCode.Null */);\n    sb.appendString('<span>');\n    for (let charIndex = 0; charIndex < len; charIndex++) {\n        if (charIndex !== 0 && charIndex % 16384 /* Constants.SPAN_MODULO_LIMIT */ === 0) {\n            sb.appendString('</span><span>');\n        }\n        charOffsets[charIndex] = charOffset;\n        visibleColumns[charIndex] = visibleColumn;\n        const charCode = nextCharCode;\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n            case 9 /* CharCode.Tab */:\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\n                charWidth = producedCharacters;\n                for (let space = 1; space <= producedCharacters; space++) {\n                    if (space < producedCharacters) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                    else {\n                        sb.appendASCIICharCode(32 /* CharCode.Space */);\n                    }\n                }\n                break;\n            case 32 /* CharCode.Space */:\n                if (nextCharCode === 32 /* CharCode.Space */) {\n                    sb.appendCharCode(0xA0); // &nbsp;\n                }\n                else {\n                    sb.appendASCIICharCode(32 /* CharCode.Space */);\n                }\n                break;\n            case 60 /* CharCode.LessThan */:\n                sb.appendString('&lt;');\n                break;\n            case 62 /* CharCode.GreaterThan */:\n                sb.appendString('&gt;');\n                break;\n            case 38 /* CharCode.Ampersand */:\n                sb.appendString('&amp;');\n                break;\n            case 0 /* CharCode.Null */:\n                sb.appendString('&#00;');\n                break;\n            case 65279 /* CharCode.UTF8_BOM */:\n            case 8232 /* CharCode.LINE_SEPARATOR */:\n            case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n            case 133 /* CharCode.NEXT_LINE */:\n                sb.appendCharCode(0xFFFD);\n                break;\n            default:\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charWidth++;\n                }\n                if (charCode < 32) {\n                    sb.appendCharCode(9216 + charCode);\n                }\n                else {\n                    sb.appendCharCode(charCode);\n                }\n        }\n        charOffset += producedCharacters;\n        visibleColumn += charWidth;\n    }\n    sb.appendString('</span>');\n    charOffsets[lineContent.length] = charOffset;\n    visibleColumns[lineContent.length] = visibleColumn;\n    sb.appendString('</div>');\n    return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n    if (lineContent.length <= 1) {\n        return null;\n    }\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n    const breakOffsets = [];\n    try {\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n    }\n    catch (err) {\n        console.log(err);\n        return null;\n    }\n    if (breakOffsets.length === 0) {\n        return null;\n    }\n    breakOffsets.push(lineContent.length);\n    return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n    if (low === high) {\n        return;\n    }\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n        // same line\n        return;\n    }\n    // there is at least one line break between these two offsets\n    if (low + 1 === high) {\n        // the two characters are adjacent, so the line break must be exactly between them\n        result.push(high);\n        return;\n    }\n    const mid = low + ((high - low) / 2) | 0;\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n    range.setStart(spans[(startOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n    range.setEnd(spans[(endOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n    return range.getClientRects();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}