{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n  getInitialState: () => NullState,\n  tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport async function tokenizeToString(languageService, text, languageId) {\n  if (!languageId) {\n    return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n  }\n  const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n  return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n  let result = `<div>`;\n  let charIndex = startOffset;\n  let tabsCharDelta = 0;\n  let prevIsSpace = true;\n  for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n    const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n    if (tokenEndIndex <= startOffset) {\n      continue;\n    }\n    let partContent = '';\n    for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n      const charCode = text.charCodeAt(charIndex);\n      switch (charCode) {\n        case 9 /* CharCode.Tab */:\n          {\n            let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1;\n            while (insertSpacesCount > 0) {\n              if (useNbsp && prevIsSpace) {\n                partContent += '&#160;';\n                prevIsSpace = false;\n              } else {\n                partContent += ' ';\n                prevIsSpace = true;\n              }\n              insertSpacesCount--;\n            }\n            break;\n          }\n        case 60 /* CharCode.LessThan */:\n          partContent += '&lt;';\n          prevIsSpace = false;\n          break;\n        case 62 /* CharCode.GreaterThan */:\n          partContent += '&gt;';\n          prevIsSpace = false;\n          break;\n        case 38 /* CharCode.Ampersand */:\n          partContent += '&amp;';\n          prevIsSpace = false;\n          break;\n        case 0 /* CharCode.Null */:\n          partContent += '&#00;';\n          prevIsSpace = false;\n          break;\n        case 65279 /* CharCode.UTF8_BOM */:\n        case 8232 /* CharCode.LINE_SEPARATOR */:\n        case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n        case 133 /* CharCode.NEXT_LINE */:\n          partContent += '\\ufffd';\n          prevIsSpace = false;\n          break;\n        case 13 /* CharCode.CarriageReturn */:\n          // zero width space, because carriage return would introduce a line break\n          partContent += '&#8203';\n          prevIsSpace = false;\n          break;\n        case 32 /* CharCode.Space */:\n          if (useNbsp && prevIsSpace) {\n            partContent += '&#160;';\n            prevIsSpace = false;\n          } else {\n            partContent += ' ';\n            prevIsSpace = true;\n          }\n          break;\n        default:\n          partContent += String.fromCharCode(charCode);\n          prevIsSpace = false;\n      }\n    }\n    result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n    if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n      break;\n    }\n  }\n  result += `</div>`;\n  return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n  let result = `<div class=\"monaco-tokenized-source\">`;\n  const lines = strings.splitLines(text);\n  let currentState = tokenizationSupport.getInitialState();\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const line = lines[i];\n    if (i > 0) {\n      result += `<br/>`;\n    }\n    const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n    LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n    const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n    const viewLineTokens = lineTokens.inflate();\n    let startOffset = 0;\n    for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n      const type = viewLineTokens.getClassName(j);\n      const endIndex = viewLineTokens.getEndOffset(j);\n      result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n      startOffset = endIndex;\n    }\n    currentState = tokenizationResult.endState;\n  }\n  result += `</div>`;\n  return result;\n}","map":{"version":3,"names":["strings","LineTokens","TokenizationRegistry","NullState","nullTokenizeEncoded","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","state","tokenizeToString","languageService","text","languageId","_tokenizeToString","languageIdCodec","tokenizationSupport","getOrCreate","tokenizeLineToHTML","viewLineTokens","colorMap","startOffset","endOffset","tabSize","useNbsp","result","charIndex","tabsCharDelta","prevIsSpace","tokenIndex","tokenCount","getCount","tokenEndIndex","getEndOffset","partContent","charCode","charCodeAt","insertSpacesCount","String","fromCharCode","getInlineStyle","lines","splitLines","currentState","i","len","length","line","tokenizationResult","convertToEndOffset","tokens","lineTokens","inflate","j","lenJ","type","getClassName","endIndex","escape","substring","endState"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport async function tokenizeToString(languageService, text, languageId) {\n    if (!languageId) {\n        return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n    }\n    const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n    return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}