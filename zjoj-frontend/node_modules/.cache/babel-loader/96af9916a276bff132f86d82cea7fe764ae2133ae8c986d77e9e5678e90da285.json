{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nconst ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n  constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit, fallbackRangeProvider // used when all providers return null\n  ) {\n    this.editorModel = editorModel;\n    this.providers = providers;\n    this.handleFoldingRangesChange = handleFoldingRangesChange;\n    this.foldingRangesLimit = foldingRangesLimit;\n    this.fallbackRangeProvider = fallbackRangeProvider;\n    this.id = ID_SYNTAX_PROVIDER;\n    this.disposables = new DisposableStore();\n    if (fallbackRangeProvider) {\n      this.disposables.add(fallbackRangeProvider);\n    }\n    for (const provider of providers) {\n      if (typeof provider.onDidChange === 'function') {\n        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n      }\n    }\n  }\n  compute(cancellationToken) {\n    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n      var _a, _b;\n      if (ranges) {\n        const res = sanitizeRanges(ranges, this.foldingRangesLimit);\n        return res;\n      }\n      return (_b = (_a = this.fallbackRangeProvider) === null || _a === void 0 ? void 0 : _a.compute(cancellationToken)) !== null && _b !== void 0 ? _b : null;\n    });\n  }\n  dispose() {\n    this.disposables.dispose();\n  }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n  let rangeData = null;\n  const promises = providers.map((provider, i) => {\n    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n      if (cancellationToken.isCancellationRequested) {\n        return;\n      }\n      if (Array.isArray(ranges)) {\n        if (!Array.isArray(rangeData)) {\n          rangeData = [];\n        }\n        const nLines = model.getLineCount();\n        for (const r of ranges) {\n          if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n            rangeData.push({\n              start: r.start,\n              end: r.end,\n              rank: i,\n              kind: r.kind\n            });\n          }\n        }\n      }\n    }, onUnexpectedExternalError);\n  });\n  return Promise.all(promises).then(_ => {\n    return rangeData;\n  });\n}\nclass RangesCollector {\n  constructor(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._nestingLevels = [];\n    this._nestingLevelCounts = [];\n    this._types = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n  add(startLineNumber, endLineNumber, type, nestingLevel) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n    const index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._nestingLevels[index] = nestingLevel;\n    this._types[index] = type;\n    this._length++;\n    if (nestingLevel < 30) {\n      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n    }\n  }\n  toIndentRanges() {\n    const limit = this._foldingRangesLimit.limit;\n    if (this._length <= limit) {\n      this._foldingRangesLimit.update(this._length, false);\n      const startIndexes = new Uint32Array(this._length);\n      const endIndexes = new Uint32Array(this._length);\n      for (let i = 0; i < this._length; i++) {\n        startIndexes[i] = this._startIndexes[i];\n        endIndexes[i] = this._endIndexes[i];\n      }\n      return new FoldingRegions(startIndexes, endIndexes, this._types);\n    } else {\n      this._foldingRangesLimit.update(this._length, limit);\n      let entries = 0;\n      let maxLevel = this._nestingLevelCounts.length;\n      for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n        const n = this._nestingLevelCounts[i];\n        if (n) {\n          if (n + entries > limit) {\n            maxLevel = i;\n            break;\n          }\n          entries += n;\n        }\n      }\n      const startIndexes = new Uint32Array(limit);\n      const endIndexes = new Uint32Array(limit);\n      const types = [];\n      for (let i = 0, k = 0; i < this._length; i++) {\n        const level = this._nestingLevels[i];\n        if (level < maxLevel || level === maxLevel && entries++ < limit) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n          types[k] = this._types[i];\n          k++;\n        }\n      }\n      return new FoldingRegions(startIndexes, endIndexes, types);\n    }\n  }\n}\nexport function sanitizeRanges(rangeData, foldingRangesLimit) {\n  const sorted = rangeData.sort((d1, d2) => {\n    let diff = d1.start - d2.start;\n    if (diff === 0) {\n      diff = d1.rank - d2.rank;\n    }\n    return diff;\n  });\n  const collector = new RangesCollector(foldingRangesLimit);\n  let top = undefined;\n  const previous = [];\n  for (const entry of sorted) {\n    if (!top) {\n      top = entry;\n      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n    } else {\n      if (entry.start > top.start) {\n        if (entry.end <= top.end) {\n          previous.push(top);\n          top = entry;\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        } else {\n          if (entry.start > top.end) {\n            do {\n              top = previous.pop();\n            } while (top && entry.start > top.end);\n            if (top) {\n              previous.push(top);\n            }\n            top = entry;\n          }\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n      }\n    }\n  }\n  return collector.toIndentRanges();\n}","map":{"version":3,"names":["onUnexpectedExternalError","DisposableStore","FoldingRegions","MAX_LINE_NUMBER","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","constructor","editorModel","providers","handleFoldingRangesChange","foldingRangesLimit","fallbackRangeProvider","id","disposables","add","provider","onDidChange","compute","cancellationToken","collectSyntaxRanges","then","ranges","_a","_b","res","sanitizeRanges","dispose","model","rangeData","promises","map","i","Promise","resolve","provideFoldingRanges","isCancellationRequested","Array","isArray","nLines","getLineCount","r","start","end","push","rank","kind","all","_","RangesCollector","_startIndexes","_endIndexes","_nestingLevels","_nestingLevelCounts","_types","_length","_foldingRangesLimit","startLineNumber","endLineNumber","type","nestingLevel","index","toIndentRanges","limit","update","startIndexes","Uint32Array","endIndexes","entries","maxLevel","length","n","types","k","level","sorted","sort","d1","d2","diff","collector","top","undefined","previous","entry","value","pop"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nconst ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n    constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit, fallbackRangeProvider // used when all providers return null\n    ) {\n        this.editorModel = editorModel;\n        this.providers = providers;\n        this.handleFoldingRangesChange = handleFoldingRangesChange;\n        this.foldingRangesLimit = foldingRangesLimit;\n        this.fallbackRangeProvider = fallbackRangeProvider;\n        this.id = ID_SYNTAX_PROVIDER;\n        this.disposables = new DisposableStore();\n        if (fallbackRangeProvider) {\n            this.disposables.add(fallbackRangeProvider);\n        }\n        for (const provider of providers) {\n            if (typeof provider.onDidChange === 'function') {\n                this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n            }\n        }\n    }\n    compute(cancellationToken) {\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n            var _a, _b;\n            if (ranges) {\n                const res = sanitizeRanges(ranges, this.foldingRangesLimit);\n                return res;\n            }\n            return (_b = (_a = this.fallbackRangeProvider) === null || _a === void 0 ? void 0 : _a.compute(cancellationToken)) !== null && _b !== void 0 ? _b : null;\n        });\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n    let rangeData = null;\n    const promises = providers.map((provider, i) => {\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n            if (cancellationToken.isCancellationRequested) {\n                return;\n            }\n            if (Array.isArray(ranges)) {\n                if (!Array.isArray(rangeData)) {\n                    rangeData = [];\n                }\n                const nLines = model.getLineCount();\n                for (const r of ranges) {\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                    }\n                }\n            }\n        }, onUnexpectedExternalError);\n    });\n    return Promise.all(promises).then(_ => {\n        return rangeData;\n    });\n}\nclass RangesCollector {\n    constructor(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._nestingLevels = [];\n        this._nestingLevelCounts = [];\n        this._types = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    add(startLineNumber, endLineNumber, type, nestingLevel) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        const index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._nestingLevels[index] = nestingLevel;\n        this._types[index] = type;\n        this._length++;\n        if (nestingLevel < 30) {\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n        }\n    }\n    toIndentRanges() {\n        const limit = this._foldingRangesLimit.limit;\n        if (this._length <= limit) {\n            this._foldingRangesLimit.update(this._length, false);\n            const startIndexes = new Uint32Array(this._length);\n            const endIndexes = new Uint32Array(this._length);\n            for (let i = 0; i < this._length; i++) {\n                startIndexes[i] = this._startIndexes[i];\n                endIndexes[i] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\n        }\n        else {\n            this._foldingRangesLimit.update(this._length, limit);\n            let entries = 0;\n            let maxLevel = this._nestingLevelCounts.length;\n            for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n                const n = this._nestingLevelCounts[i];\n                if (n) {\n                    if (n + entries > limit) {\n                        maxLevel = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const startIndexes = new Uint32Array(limit);\n            const endIndexes = new Uint32Array(limit);\n            const types = [];\n            for (let i = 0, k = 0; i < this._length; i++) {\n                const level = this._nestingLevels[i];\n                if (level < maxLevel || (level === maxLevel && entries++ < limit)) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                    types[k] = this._types[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes, types);\n        }\n    }\n}\nexport function sanitizeRanges(rangeData, foldingRangesLimit) {\n    const sorted = rangeData.sort((d1, d2) => {\n        let diff = d1.start - d2.start;\n        if (diff === 0) {\n            diff = d1.rank - d2.rank;\n        }\n        return diff;\n    });\n    const collector = new RangesCollector(foldingRangesLimit);\n    let top = undefined;\n    const previous = [];\n    for (const entry of sorted) {\n        if (!top) {\n            top = entry;\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n        else {\n            if (entry.start > top.start) {\n                if (entry.end <= top.end) {\n                    previous.push(top);\n                    top = entry;\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n                else {\n                    if (entry.start > top.end) {\n                        do {\n                            top = previous.pop();\n                        } while (top && entry.start > top.end);\n                        if (top) {\n                            previous.push(top);\n                        }\n                        top = entry;\n                    }\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n            }\n        }\n    }\n    return collector.toIndentRanges();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}