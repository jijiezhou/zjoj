{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, _setRecomputeInitiallyAndOnChange, getDebugName, getFunctionName, subtransaction, transaction } from './base.js';\nimport { derived } from './derived.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n  return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  get debugName() {\n    return this.toString();\n  }\n  get() {\n    return this.value;\n  }\n  addObserver(observer) {\n    // NO OP\n  }\n  removeObserver(observer) {\n    // NO OP\n  }\n  toString() {\n    return `Const: ${this.value}`;\n  }\n}\nexport function waitForState(observable, predicate) {\n  return new Promise(resolve => {\n    let didRun = false;\n    let shouldDispose = false;\n    const stateObs = observable.map(state => ({\n      isFinished: predicate(state),\n      state\n    }));\n    const d = autorun(reader => {\n      /** @description waitForState */\n      const {\n        isFinished,\n        state\n      } = stateObs.read(reader);\n      if (isFinished) {\n        if (!didRun) {\n          shouldDispose = true;\n        } else {\n          d.dispose();\n        }\n        resolve(state);\n      }\n    });\n    didRun = true;\n    if (shouldDispose) {\n      d.dispose();\n    }\n  });\n}\nexport function observableFromEvent(event, getValue) {\n  return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n  constructor(event, _getValue) {\n    super();\n    this.event = event;\n    this._getValue = _getValue;\n    this.hasValue = false;\n    this.handleEvent = args => {\n      var _a;\n      const newValue = this._getValue(args);\n      const oldValue = this.value;\n      const didChange = !this.hasValue || oldValue !== newValue;\n      let didRunTransaction = false;\n      if (didChange) {\n        this.value = newValue;\n        if (this.hasValue) {\n          didRunTransaction = true;\n          subtransaction(FromEventObservable.globalTransaction, tx => {\n            var _a;\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n              oldValue,\n              newValue,\n              change: undefined,\n              didChange,\n              hadValue: this.hasValue\n            });\n            for (const o of this.observers) {\n              tx.updateObserver(o, this);\n              o.handleChange(this, undefined);\n            }\n          }, () => {\n            const name = this.getDebugName();\n            return 'Event fired' + (name ? `: ${name}` : '');\n          });\n        }\n        this.hasValue = true;\n      }\n      if (!didRunTransaction) {\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n          oldValue,\n          newValue,\n          change: undefined,\n          didChange,\n          hadValue: this.hasValue\n        });\n      }\n    };\n  }\n  getDebugName() {\n    return getFunctionName(this._getValue);\n  }\n  get debugName() {\n    const name = this.getDebugName();\n    return 'From Event' + (name ? `: ${name}` : '');\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n    this.hasValue = false;\n    this.value = undefined;\n  }\n  get() {\n    if (this.subscription) {\n      if (!this.hasValue) {\n        this.handleEvent(undefined);\n      }\n      return this.value;\n    } else {\n      // no cache, as there are no subscribers to keep it updated\n      return this._getValue(undefined);\n    }\n  }\n}\n(function (observableFromEvent) {\n  observableFromEvent.Observer = FromEventObservable;\n  function batchEventsGlobally(tx, fn) {\n    let didSet = false;\n    if (FromEventObservable.globalTransaction === undefined) {\n      FromEventObservable.globalTransaction = tx;\n      didSet = true;\n    }\n    try {\n      fn();\n    } finally {\n      if (didSet) {\n        FromEventObservable.globalTransaction = undefined;\n      }\n    }\n  }\n  observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n  return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n  constructor(debugName, event) {\n    super();\n    this.debugName = debugName;\n    this.event = event;\n    this.handleEvent = () => {\n      transaction(tx => {\n        for (const o of this.observers) {\n          tx.updateObserver(o, this);\n          o.handleChange(this, undefined);\n        }\n      }, () => this.debugName);\n    };\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n  }\n  get() {\n    // NO OP\n  }\n}\nexport function observableSignal(debugNameOrOwner) {\n  if (typeof debugNameOrOwner === 'string') {\n    return new ObservableSignal(debugNameOrOwner);\n  } else {\n    return new ObservableSignal(undefined, debugNameOrOwner);\n  }\n}\nclass ObservableSignal extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = getDebugName(this, this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n  }\n  constructor(_debugName, _owner) {\n    super();\n    this._debugName = _debugName;\n    this._owner = _owner;\n  }\n  trigger(tx, change) {\n    if (!tx) {\n      transaction(tx => {\n        this.trigger(tx, change);\n      }, () => `Trigger signal ${this.debugName}`);\n      return;\n    }\n    for (const o of this.observers) {\n      tx.updateObserver(o, this);\n      o.handleChange(this, change);\n    }\n  }\n  get() {\n    // NO OP\n  }\n}\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n  const o = new KeepAliveObserver(true, handleValue);\n  observable.addObserver(o);\n  if (handleValue) {\n    handleValue(observable.get());\n  } else {\n    observable.reportChanges();\n  }\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nclass KeepAliveObserver {\n  constructor(_forceRecompute, _handleValue) {\n    this._forceRecompute = _forceRecompute;\n    this._handleValue = _handleValue;\n    this._counter = 0;\n  }\n  beginUpdate(observable) {\n    this._counter++;\n  }\n  endUpdate(observable) {\n    this._counter--;\n    if (this._counter === 0 && this._forceRecompute) {\n      if (this._handleValue) {\n        this._handleValue(observable.get());\n      } else {\n        observable.reportChanges();\n      }\n    }\n  }\n  handlePossibleChange(observable) {\n    // NO OP\n  }\n  handleChange(observable, change) {\n    // NO OP\n  }\n}\nexport function derivedObservableWithCache(computeFn) {\n  let lastValue = undefined;\n  const observable = derived(reader => {\n    lastValue = computeFn(reader, lastValue);\n    return lastValue;\n  });\n  return observable;\n}","map":{"version":3,"names":["toDisposable","autorun","BaseObservable","ConvenientObservable","_setRecomputeInitiallyAndOnChange","getDebugName","getFunctionName","subtransaction","transaction","derived","getLogger","constObservable","value","ConstObservable","constructor","debugName","toString","get","addObserver","observer","removeObserver","waitForState","observable","predicate","Promise","resolve","didRun","shouldDispose","stateObs","map","state","isFinished","d","reader","read","dispose","observableFromEvent","event","getValue","FromEventObservable","_getValue","hasValue","handleEvent","args","_a","newValue","oldValue","didChange","didRunTransaction","globalTransaction","tx","handleFromEventObservableTriggered","change","undefined","hadValue","o","observers","updateObserver","handleChange","name","onFirstObserverAdded","subscription","onLastObserverRemoved","Observer","batchEventsGlobally","fn","didSet","observableSignalFromEvent","FromEventObservableSignal","observableSignal","debugNameOrOwner","ObservableSignal","_debugName","_owner","trigger","recomputeInitiallyAndOnChange","handleValue","KeepAliveObserver","reportChanges","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","computeFn","lastValue"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, _setRecomputeInitiallyAndOnChange, getDebugName, getFunctionName, subtransaction, transaction } from './base.js';\nimport { derived } from './derived.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function waitForState(observable, predicate) {\n    return new Promise(resolve => {\n        let didRun = false;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => ({ isFinished: predicate(state), state }));\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, state } = stateObs.read(reader);\n            if (isFinished) {\n                if (!didRun) {\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                resolve(state);\n            }\n        });\n        didRun = true;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\nexport function observableFromEvent(event, getValue) {\n    return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(event, _getValue) {\n        super();\n        this.event = event;\n        this._getValue = _getValue;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            var _a;\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || oldValue !== newValue;\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(FromEventObservable.globalTransaction, (tx) => {\n                        var _a;\n                        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return getFunctionName(this._getValue);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            return this._getValue(undefined);\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = getDebugName(this, this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nclass KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(computeFn) {\n    let lastValue = undefined;\n    const observable = derived(reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,cAAc,EAAEC,oBAAoB,EAAEC,iCAAiC,EAAEC,YAAY,EAAEC,eAAe,EAAEC,cAAc,EAAEC,WAAW,QAAQ,WAAW;AAC/J,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,SAAS,QAAQ,cAAc;AACxC;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,KAAK,EAAE;EACnC,OAAO,IAAIC,eAAe,CAACD,KAAK,CAAC;AACrC;AACA,MAAMC,eAAe,SAASV,oBAAoB,CAAC;EAC/CW,WAAWA,CAACF,KAAK,EAAE;IACf,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EACA,IAAIG,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC;EAC1B;EACAC,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACL,KAAK;EACrB;EACAM,WAAWA,CAACC,QAAQ,EAAE;IAClB;EAAA;EAEJC,cAAcA,CAACD,QAAQ,EAAE;IACrB;EAAA;EAEJH,QAAQA,CAAA,EAAG;IACP,OAAQ,UAAS,IAAI,CAACJ,KAAM,EAAC;EACjC;AACJ;AACA,OAAO,SAASS,YAAYA,CAACC,UAAU,EAAEC,SAAS,EAAE;EAChD,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;IAC1B,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAIC,aAAa,GAAG,KAAK;IACzB,MAAMC,QAAQ,GAAGN,UAAU,CAACO,GAAG,CAACC,KAAK,KAAK;MAAEC,UAAU,EAAER,SAAS,CAACO,KAAK,CAAC;MAAEA;IAAM,CAAC,CAAC,CAAC;IACnF,MAAME,CAAC,GAAG/B,OAAO,CAACgC,MAAM,IAAI;MACxB;MACA,MAAM;QAAEF,UAAU;QAAED;MAAM,CAAC,GAAGF,QAAQ,CAACM,IAAI,CAACD,MAAM,CAAC;MACnD,IAAIF,UAAU,EAAE;QACZ,IAAI,CAACL,MAAM,EAAE;UACTC,aAAa,GAAG,IAAI;QACxB,CAAC,MACI;UACDK,CAAC,CAACG,OAAO,CAAC,CAAC;QACf;QACAV,OAAO,CAACK,KAAK,CAAC;MAClB;IACJ,CAAC,CAAC;IACFJ,MAAM,GAAG,IAAI;IACb,IAAIC,aAAa,EAAE;MACfK,CAAC,CAACG,OAAO,CAAC,CAAC;IACf;EACJ,CAAC,CAAC;AACN;AACA,OAAO,SAASC,mBAAmBA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EACjD,OAAO,IAAIC,mBAAmB,CAACF,KAAK,EAAEC,QAAQ,CAAC;AACnD;AACA,OAAO,MAAMC,mBAAmB,SAASrC,cAAc,CAAC;EACpDY,WAAWA,CAACuB,KAAK,EAAEG,SAAS,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACG,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,WAAW,GAAIC,IAAI,IAAK;MACzB,IAAIC,EAAE;MACN,MAAMC,QAAQ,GAAG,IAAI,CAACL,SAAS,CAACG,IAAI,CAAC;MACrC,MAAMG,QAAQ,GAAG,IAAI,CAAClC,KAAK;MAC3B,MAAMmC,SAAS,GAAG,CAAC,IAAI,CAACN,QAAQ,IAAIK,QAAQ,KAAKD,QAAQ;MACzD,IAAIG,iBAAiB,GAAG,KAAK;MAC7B,IAAID,SAAS,EAAE;QACX,IAAI,CAACnC,KAAK,GAAGiC,QAAQ;QACrB,IAAI,IAAI,CAACJ,QAAQ,EAAE;UACfO,iBAAiB,GAAG,IAAI;UACxBzC,cAAc,CAACgC,mBAAmB,CAACU,iBAAiB,EAAGC,EAAE,IAAK;YAC1D,IAAIN,EAAE;YACN,CAACA,EAAE,GAAGlC,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIkC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,kCAAkC,CAAC,IAAI,EAAE;cAAEL,QAAQ;cAAED,QAAQ;cAAEO,MAAM,EAAEC,SAAS;cAAEN,SAAS;cAAEO,QAAQ,EAAE,IAAI,CAACb;YAAS,CAAC,CAAC;YAClL,KAAK,MAAMc,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;cAC5BN,EAAE,CAACO,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;cAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEL,SAAS,CAAC;YACnC;UACJ,CAAC,EAAE,MAAM;YACL,MAAMM,IAAI,GAAG,IAAI,CAACtD,YAAY,CAAC,CAAC;YAChC,OAAO,aAAa,IAAIsD,IAAI,GAAI,KAAIA,IAAK,EAAC,GAAG,EAAE,CAAC;UACpD,CAAC,CAAC;QACN;QACA,IAAI,CAAClB,QAAQ,GAAG,IAAI;MACxB;MACA,IAAI,CAACO,iBAAiB,EAAE;QACpB,CAACJ,EAAE,GAAGlC,SAAS,CAAC,CAAC,MAAM,IAAI,IAAIkC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,kCAAkC,CAAC,IAAI,EAAE;UAAEL,QAAQ;UAAED,QAAQ;UAAEO,MAAM,EAAEC,SAAS;UAAEN,SAAS;UAAEO,QAAQ,EAAE,IAAI,CAACb;QAAS,CAAC,CAAC;MACtL;IACJ,CAAC;EACL;EACApC,YAAYA,CAAA,EAAG;IACX,OAAOC,eAAe,CAAC,IAAI,CAACkC,SAAS,CAAC;EAC1C;EACA,IAAIzB,SAASA,CAAA,EAAG;IACZ,MAAM4C,IAAI,GAAG,IAAI,CAACtD,YAAY,CAAC,CAAC;IAChC,OAAO,YAAY,IAAIsD,IAAI,GAAI,KAAIA,IAAK,EAAC,GAAG,EAAE,CAAC;EACnD;EACAC,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACxB,KAAK,CAAC,IAAI,CAACK,WAAW,CAAC;EACpD;EACAoB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACD,YAAY,CAAC1B,OAAO,CAAC,CAAC;IAC3B,IAAI,CAAC0B,YAAY,GAAGR,SAAS;IAC7B,IAAI,CAACZ,QAAQ,GAAG,KAAK;IACrB,IAAI,CAAC7B,KAAK,GAAGyC,SAAS;EAC1B;EACApC,GAAGA,CAAA,EAAG;IACF,IAAI,IAAI,CAAC4C,YAAY,EAAE;MACnB,IAAI,CAAC,IAAI,CAACpB,QAAQ,EAAE;QAChB,IAAI,CAACC,WAAW,CAACW,SAAS,CAAC;MAC/B;MACA,OAAO,IAAI,CAACzC,KAAK;IACrB,CAAC,MACI;MACD;MACA,OAAO,IAAI,CAAC4B,SAAS,CAACa,SAAS,CAAC;IACpC;EACJ;AACJ;AACA,CAAC,UAAUjB,mBAAmB,EAAE;EAC5BA,mBAAmB,CAAC2B,QAAQ,GAAGxB,mBAAmB;EAClD,SAASyB,mBAAmBA,CAACd,EAAE,EAAEe,EAAE,EAAE;IACjC,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAI3B,mBAAmB,CAACU,iBAAiB,KAAKI,SAAS,EAAE;MACrDd,mBAAmB,CAACU,iBAAiB,GAAGC,EAAE;MAC1CgB,MAAM,GAAG,IAAI;IACjB;IACA,IAAI;MACAD,EAAE,CAAC,CAAC;IACR,CAAC,SACO;MACJ,IAAIC,MAAM,EAAE;QACR3B,mBAAmB,CAACU,iBAAiB,GAAGI,SAAS;MACrD;IACJ;EACJ;EACAjB,mBAAmB,CAAC4B,mBAAmB,GAAGA,mBAAmB;AACjE,CAAC,EAAE5B,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AACrD,OAAO,SAAS+B,yBAAyBA,CAACpD,SAAS,EAAEsB,KAAK,EAAE;EACxD,OAAO,IAAI+B,yBAAyB,CAACrD,SAAS,EAAEsB,KAAK,CAAC;AAC1D;AACA,MAAM+B,yBAAyB,SAASlE,cAAc,CAAC;EACnDY,WAAWA,CAACC,SAAS,EAAEsB,KAAK,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAACtB,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACsB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACK,WAAW,GAAG,MAAM;MACrBlC,WAAW,CAAE0C,EAAE,IAAK;QAChB,KAAK,MAAMK,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;UAC5BN,EAAE,CAACO,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;UAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEL,SAAS,CAAC;QACnC;MACJ,CAAC,EAAE,MAAM,IAAI,CAACtC,SAAS,CAAC;IAC5B,CAAC;EACL;EACA6C,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACxB,KAAK,CAAC,IAAI,CAACK,WAAW,CAAC;EACpD;EACAoB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACD,YAAY,CAAC1B,OAAO,CAAC,CAAC;IAC3B,IAAI,CAAC0B,YAAY,GAAGR,SAAS;EACjC;EACApC,GAAGA,CAAA,EAAG;IACF;EAAA;AAER;AACA,OAAO,SAASoD,gBAAgBA,CAACC,gBAAgB,EAAE;EAC/C,IAAI,OAAOA,gBAAgB,KAAK,QAAQ,EAAE;IACtC,OAAO,IAAIC,gBAAgB,CAACD,gBAAgB,CAAC;EACjD,CAAC,MACI;IACD,OAAO,IAAIC,gBAAgB,CAAClB,SAAS,EAAEiB,gBAAgB,CAAC;EAC5D;AACJ;AACA,MAAMC,gBAAgB,SAASrE,cAAc,CAAC;EAC1C,IAAIa,SAASA,CAAA,EAAG;IACZ,IAAI6B,EAAE;IACN,OAAO,CAACA,EAAE,GAAGvC,YAAY,CAAC,IAAI,EAAE,IAAI,CAACmE,UAAU,EAAEnB,SAAS,EAAE,IAAI,CAACoB,MAAM,EAAE,IAAI,CAAC,MAAM,IAAI,IAAI7B,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,mBAAmB;EACxI;EACA9B,WAAWA,CAAC0D,UAAU,EAAEC,MAAM,EAAE;IAC5B,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;EACxB;EACAC,OAAOA,CAACxB,EAAE,EAAEE,MAAM,EAAE;IAChB,IAAI,CAACF,EAAE,EAAE;MACL1C,WAAW,CAAC0C,EAAE,IAAI;QACd,IAAI,CAACwB,OAAO,CAACxB,EAAE,EAAEE,MAAM,CAAC;MAC5B,CAAC,EAAE,MAAO,kBAAiB,IAAI,CAACrC,SAAU,EAAC,CAAC;MAC5C;IACJ;IACA,KAAK,MAAMwC,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;MAC5BN,EAAE,CAACO,cAAc,CAACF,CAAC,EAAE,IAAI,CAAC;MAC1BA,CAAC,CAACG,YAAY,CAAC,IAAI,EAAEN,MAAM,CAAC;IAChC;EACJ;EACAnC,GAAGA,CAAA,EAAG;IACF;EAAA;AAER;AACA;AACA;AACA;AACA,OAAO,SAAS0D,6BAA6BA,CAACrD,UAAU,EAAEsD,WAAW,EAAE;EACnE,MAAMrB,CAAC,GAAG,IAAIsB,iBAAiB,CAAC,IAAI,EAAED,WAAW,CAAC;EAClDtD,UAAU,CAACJ,WAAW,CAACqC,CAAC,CAAC;EACzB,IAAIqB,WAAW,EAAE;IACbA,WAAW,CAACtD,UAAU,CAACL,GAAG,CAAC,CAAC,CAAC;EACjC,CAAC,MACI;IACDK,UAAU,CAACwD,aAAa,CAAC,CAAC;EAC9B;EACA,OAAO9E,YAAY,CAAC,MAAM;IACtBsB,UAAU,CAACF,cAAc,CAACmC,CAAC,CAAC;EAChC,CAAC,CAAC;AACN;AACAnD,iCAAiC,CAACuE,6BAA6B,CAAC;AAChE,MAAME,iBAAiB,CAAC;EACpB/D,WAAWA,CAACiE,eAAe,EAAEC,YAAY,EAAE;IACvC,IAAI,CAACD,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,QAAQ,GAAG,CAAC;EACrB;EACAC,WAAWA,CAAC5D,UAAU,EAAE;IACpB,IAAI,CAAC2D,QAAQ,EAAE;EACnB;EACAE,SAASA,CAAC7D,UAAU,EAAE;IAClB,IAAI,CAAC2D,QAAQ,EAAE;IACf,IAAI,IAAI,CAACA,QAAQ,KAAK,CAAC,IAAI,IAAI,CAACF,eAAe,EAAE;MAC7C,IAAI,IAAI,CAACC,YAAY,EAAE;QACnB,IAAI,CAACA,YAAY,CAAC1D,UAAU,CAACL,GAAG,CAAC,CAAC,CAAC;MACvC,CAAC,MACI;QACDK,UAAU,CAACwD,aAAa,CAAC,CAAC;MAC9B;IACJ;EACJ;EACAM,oBAAoBA,CAAC9D,UAAU,EAAE;IAC7B;EAAA;EAEJoC,YAAYA,CAACpC,UAAU,EAAE8B,MAAM,EAAE;IAC7B;EAAA;AAER;AACA,OAAO,SAASiC,0BAA0BA,CAACC,SAAS,EAAE;EAClD,IAAIC,SAAS,GAAGlC,SAAS;EACzB,MAAM/B,UAAU,GAAGb,OAAO,CAACwB,MAAM,IAAI;IACjCsD,SAAS,GAAGD,SAAS,CAACrD,MAAM,EAAEsD,SAAS,CAAC;IACxC,OAAOA,SAAS;EACpB,CAAC,CAAC;EACF,OAAOjE,UAAU;AACrB"},"metadata":{},"sourceType":"module","externalDependencies":[]}