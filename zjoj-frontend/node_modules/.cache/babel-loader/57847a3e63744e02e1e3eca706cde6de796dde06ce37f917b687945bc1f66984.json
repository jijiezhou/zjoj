{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n    this._lastState = null;\n    return null;\n  }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n  constructor() {\n    this._lastTypeTextLength = 0;\n  }\n  handleCompositionUpdate(text) {\n    text = text || '';\n    const typeInput = {\n      text: text,\n      replacePrevCharCnt: this._lastTypeTextLength,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n    this._lastTypeTextLength = text.length;\n    return typeInput;\n  }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nlet TextAreaInput = class TextAreaInput extends Disposable {\n  get textAreaState() {\n    return this._textAreaState;\n  }\n  constructor(_host, _textArea, _OS, _browser, _accessibilityService, _logService) {\n    super();\n    this._host = _host;\n    this._textArea = _textArea;\n    this._OS = _OS;\n    this._browser = _browser;\n    this._accessibilityService = _accessibilityService;\n    this._logService = _logService;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new MutableDisposable());\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    if (this._accessibilityService.isScreenReaderOptimized()) {\n      this.writeNativeTextAreaContent('ctor');\n    }\n    this._register(Event.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {\n      if (this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value) {\n        this._asyncFocusGainWriteScreenReaderContent.value = this._register(new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0));\n      } else {\n        this._asyncFocusGainWriteScreenReaderContent.clear();\n      }\n    }));\n    this._hasFocus = false;\n    this._currentComposition = null;\n    let lastKeyDown = null;\n    this._register(this._textArea.onKeyDown(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */ || this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n      if (e.equals(9 /* KeyCode.Escape */)) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n      lastKeyDown = e;\n      this._onKeyDown.fire(e);\n    }));\n    this._register(this._textArea.onKeyUp(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      this._onKeyUp.fire(e);\n    }));\n    this._register(this._textArea.onCompositionStart(e => {\n      if (_debugComposition) {\n        console.log(`[compositionstart]`, e);\n      }\n      const currentComposition = new CompositionContext();\n      if (this._currentComposition) {\n        // simply reset the composition context\n        this._currentComposition = currentComposition;\n        return;\n      }\n      this._currentComposition = currentComposition;\n      if (this._OS === 2 /* OperatingSystem.Macintosh */ && lastKeyDown && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n        // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n        if (_debugComposition) {\n          console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n        }\n        // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n        currentComposition.handleCompositionUpdate('x');\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      this._onCompositionStart.fire({\n        data: e.data\n      });\n    }));\n    this._register(this._textArea.onCompositionUpdate(e => {\n      if (_debugComposition) {\n        console.log(`[compositionupdate]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionUpdate.fire(e);\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      this._onType.fire(typeInput);\n      this._onCompositionUpdate.fire(e);\n    }));\n    this._register(this._textArea.onCompositionEnd(e => {\n      if (_debugComposition) {\n        console.log(`[compositionend]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // https://github.com/microsoft/monaco-editor/issues/1663\n        // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n        return;\n      }\n      this._currentComposition = null;\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionEnd.fire();\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      this._onType.fire(typeInput);\n      this._onCompositionEnd.fire();\n    }));\n    this._register(this._textArea.onInput(e => {\n      if (_debugComposition) {\n        console.log(`[input]`, e);\n      }\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n      if (this._currentComposition) {\n        return;\n      }\n      const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/this._OS === 2 /* OperatingSystem.Macintosh */);\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n        // one character was typed\n        if (strings.isHighSurrogate(typeInput.text.charCodeAt(0)) || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n          // Ignore invalid input but keep it around for next time\n          return;\n        }\n      }\n      this._textAreaState = newState;\n      if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0 || typeInput.replaceNextCharCnt !== 0 || typeInput.positionDelta !== 0) {\n        this._onType.fire(typeInput);\n      }\n    }));\n    // --- Clipboard operations\n    this._register(this._textArea.onCut(e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n      this._ensureClipboardGetsEditorSelection(e);\n      this._asyncTriggerCut.schedule();\n    }));\n    this._register(this._textArea.onCopy(e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n    this._register(this._textArea.onPaste(e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n      e.preventDefault();\n      if (!e.clipboardData) {\n        return;\n      }\n      let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n      if (!text) {\n        return;\n      }\n      // try the in-memory store\n      metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n      this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }));\n    this._register(this._textArea.onFocus(() => {\n      const hadFocus = this._hasFocus;\n      this._setHasFocus(true);\n      if (this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        if (!this._asyncFocusGainWriteScreenReaderContent.value) {\n          this._asyncFocusGainWriteScreenReaderContent.value = new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0);\n        }\n        this._asyncFocusGainWriteScreenReaderContent.value.schedule();\n      }\n    }));\n    this._register(this._textArea.onBlur(() => {\n      if (this._currentComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeNativeTextAreaContent('blurWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n      this._setHasFocus(false);\n    }));\n    this._register(this._textArea.onSyntheticTap(() => {\n      if (this._browser.isAndroid && this._currentComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeNativeTextAreaContent('tapWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n    }));\n  }\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', e => {\n      inputLatency.onSelectionChange();\n      if (!this._hasFocus) {\n        return;\n      }\n      if (this._currentComposition) {\n        return;\n      }\n      if (!this._browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n      this._textArea.resetSelectionChangeTime();\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n      if (!this._textAreaState.selection) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newValue = this._textArea.getValue();\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newSelectionStart = this._textArea.getSelectionStart();\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n  }\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true);\n    // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n    this.refreshFocusState();\n  }\n  isFocused() {\n    return this._hasFocus;\n  }\n  refreshFocusState() {\n    this._setHasFocus(this._textArea.hasFocus());\n  }\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n    this._hasFocus = newHasFocus;\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n    if (this._hasFocus) {\n      this.writeNativeTextAreaContent('focusgain');\n    }\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n  writeNativeTextAreaContent(reason) {\n    if (!this._accessibilityService.isScreenReaderOptimized() && reason === 'render' || this._currentComposition) {\n      // Do not write to the text on render unless a screen reader is being used #192278\n      // Do not write to the text area when doing composition\n      return;\n    }\n    this._logService.trace(`writeTextAreaState(reason: ${reason})`);\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n  }\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy();\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set(\n    // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n    e.preventDefault();\n    if (e.clipboardData) {\n      ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n  }\n};\nTextAreaInput = __decorate([__param(4, IAccessibilityService), __param(5, ILogService)], TextAreaInput);\nexport { TextAreaInput };\nexport const ClipboardEventUtils = {\n  getTextData(clipboardData) {\n    const text = clipboardData.getData(Mimes.text);\n    let metadata = null;\n    const rawmetadata = clipboardData.getData('vscode-editor-data');\n    if (typeof rawmetadata === 'string') {\n      try {\n        metadata = JSON.parse(rawmetadata);\n        if (metadata.version !== 1) {\n          metadata = null;\n        }\n      } catch (err) {\n        // no problem!\n      }\n    }\n    if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n      // no textual data pasted, generate text from file names\n      const files = Array.prototype.slice.call(clipboardData.files, 0);\n      return [files.map(file => file.name).join('\\n'), null];\n    }\n    return [text, metadata];\n  },\n  setTextData(clipboardData, text, html, metadata) {\n    clipboardData.setData(Mimes.text, text);\n    if (typeof html === 'string') {\n      clipboardData.setData('text/html', html);\n    }\n    clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n  }\n};\nexport class TextAreaWrapper extends Disposable {\n  get ownerDocument() {\n    return this._actual.ownerDocument;\n  }\n  constructor(_actual) {\n    super();\n    this._actual = _actual;\n    this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n    this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n    this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n    this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n    this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n    this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n    this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n    this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n    this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n    this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n    this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n    this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n    this._onSyntheticTap = this._register(new Emitter());\n    this.onSyntheticTap = this._onSyntheticTap.event;\n    this._ignoreSelectionChangeTime = 0;\n    this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n    this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n    this._register(this.onInput(() => inputLatency.onInput()));\n    this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n    this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n  }\n  hasFocus() {\n    const shadowRoot = dom.getShadowRoot(this._actual);\n    if (shadowRoot) {\n      return shadowRoot.activeElement === this._actual;\n    } else if (this._actual.isConnected) {\n      return this._actual.ownerDocument.activeElement === this._actual;\n    } else {\n      return false;\n    }\n  }\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.value;\n  }\n  setValue(reason, value) {\n    const textArea = this._actual;\n    if (textArea.value === value) {\n      // No change\n      return;\n    }\n    // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n  getSelectionStart() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n  }\n  getSelectionEnd() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n  }\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = textArea.ownerDocument.activeElement;\n    }\n    const activeWindow = dom.getWindow(activeElement);\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n        textArea.focus();\n      }\n      return;\n    }\n    // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n        textArea.focus();\n      }\n      return;\n    }\n    // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {\n      // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","browser","dom","DomEmitter","StandardKeyboardEvent","inputLatency","RunOnceScheduler","Emitter","Event","Disposable","MutableDisposable","Mimes","strings","TextAreaState","_debugComposition","Selection","IAccessibilityService","ILogService","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","text","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","TextAreaInput","textAreaState","_textAreaState","_host","_textArea","_OS","_browser","_accessibilityService","_logService","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncFocusGainWriteScreenReaderContent","_asyncTriggerCut","fire","EMPTY","_selectionChangeListener","isScreenReaderOptimized","writeNativeTextAreaContent","runAndSubscribe","onDidChangeScreenReaderOptimized","value","clear","_hasFocus","_currentComposition","lastKeyDown","_e","e","keyCode","stopPropagation","equals","preventDefault","console","log","currentComposition","selectionStart","selectionEnd","substr","code","isAndroid","newState","readFromTextArea","deduceAndroidCompositionInput","onInput","setIgnoreSelectionChangeTime","deduceInput","isHighSurrogate","charCodeAt","_ensureClipboardGetsEditorSelection","schedule","onCopy","clipboardData","metadata","ClipboardEventUtils","getTextData","hadFocus","_setHasFocus","isSafari","onSyntheticTap","_installSelectionChangeListener","previousSelectionChangeEventTime","addDisposableListener","ownerDocument","onSelectionChange","isChrome","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selection","newValue","getValue","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","lineNumber","column","dispose","focusTextArea","refreshFocusState","isFocused","hasFocus","newHasFocus","_setAndWriteTextAreaState","reason","collapseSelection","writeToTextArea","trace","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","isFirefox","replace","setTextData","html","getData","rawmetadata","JSON","parse","err","files","Array","prototype","slice","call","map","file","name","join","setData","stringify","TextAreaWrapper","_actual","onBeforeInput","_onSyntheticTap","_ignoreSelectionChangeTime","shadowRoot","getShadowRoot","activeElement","isConnected","setValue","textArea","selectionDirection","setSelectionRange","activeWindow","getWindow","currentIsFocused","currentSelectionStart","currentSelectionEnd","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nlet TextAreaInput = class TextAreaInput extends Disposable {\n    get textAreaState() {\n        return this._textAreaState;\n    }\n    constructor(_host, _textArea, _OS, _browser, _accessibilityService, _logService) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._accessibilityService = _accessibilityService;\n        this._logService = _logService;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new MutableDisposable());\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        if (this._accessibilityService.isScreenReaderOptimized()) {\n            this.writeNativeTextAreaContent('ctor');\n        }\n        this._register(Event.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {\n            if (this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value) {\n                this._asyncFocusGainWriteScreenReaderContent.value = this._register(new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0));\n            }\n            else {\n                this._asyncFocusGainWriteScreenReaderContent.clear();\n            }\n        }));\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n                // one character was typed\n                if (strings.isHighSurrogate(typeInput.text.charCodeAt(0))\n                    || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n                    // Ignore invalid input but keep it around for next time\n                    return;\n                }\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                if (!this._asyncFocusGainWriteScreenReaderContent.value) {\n                    this._asyncFocusGainWriteScreenReaderContent.value = new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0);\n                }\n                this._asyncFocusGainWriteScreenReaderContent.value.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', (e) => {\n            inputLatency.onSelectionChange();\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selection) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeNativeTextAreaContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeNativeTextAreaContent(reason) {\n        if ((!this._accessibilityService.isScreenReaderOptimized() && reason === 'render') || this._currentComposition) {\n            // Do not write to the text on render unless a screen reader is being used #192278\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._logService.trace(`writeTextAreaState(reason: ${reason})`);\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n};\nTextAreaInput = __decorate([\n    __param(4, IAccessibilityService),\n    __param(5, ILogService)\n], TextAreaInput);\nexport { TextAreaInput };\nexport const ClipboardEventUtils = {\n    getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    },\n    setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n};\nexport class TextAreaWrapper extends Disposable {\n    get ownerDocument() {\n        return this._actual.ownerDocument;\n    }\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n        this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n        this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n        this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n        this._register(this.onInput(() => inputLatency.onInput()));\n        this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (this._actual.isConnected) {\n            return this._actual.ownerDocument.activeElement === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = textArea.ownerDocument.activeElement;\n        }\n        const activeWindow = dom.getWindow(activeElement);\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}