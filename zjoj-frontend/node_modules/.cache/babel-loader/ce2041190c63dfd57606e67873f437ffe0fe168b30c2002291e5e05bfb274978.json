{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n  static fromRange(range) {\n    return new LineRange(range.startLineNumber, range.endLineNumber);\n  }\n  static fromRangeInclusive(range) {\n    return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n  }\n  /**\n   * @param lineRanges An array of sorted line ranges.\n   */\n  static joinMany(lineRanges) {\n    if (lineRanges.length === 0) {\n      return [];\n    }\n    let result = new LineRangeSet(lineRanges[0].slice());\n    for (let i = 1; i < lineRanges.length; i++) {\n      result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n    }\n    return result.ranges;\n  }\n  static ofLength(startLineNumber, length) {\n    return new LineRange(startLineNumber, startLineNumber + length);\n  }\n  /**\n   * @internal\n   */\n  static deserialize(lineRange) {\n    return new LineRange(lineRange[0], lineRange[1]);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber > endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  contains(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  deltaLength(offset) {\n    return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n  }\n  toString() {\n    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber <= endLineNumberExclusive) {\n      return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return undefined;\n  }\n  intersectsStrict(other) {\n    return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n  }\n  equals(b) {\n    return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  toExclusiveRange() {\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n  }\n  mapToLineArray(f) {\n    const result = [];\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      result.push(f(lineNumber));\n    }\n    return result;\n  }\n  forEach(f) {\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      f(lineNumber);\n    }\n  }\n  /**\n   * @internal\n   */\n  serialize() {\n    return [this.startLineNumber, this.endLineNumberExclusive];\n  }\n  includes(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n  /**\n   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n   * @internal\n   */\n  toOffsetRange() {\n    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n  }\n}\nexport class LineRangeSet {\n  constructor(\n  /**\n   * Sorted by start line number.\n   * No two line ranges are touching or intersecting.\n   */\n  _normalizedRanges = []) {\n    this._normalizedRanges = _normalizedRanges;\n  }\n  get ranges() {\n    return this._normalizedRanges;\n  }\n  addRange(range) {\n    if (range.length === 0) {\n      return;\n    }\n    // Idea: Find joinRange such that:\n    // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n    // idx of first element that touches range or that is after range\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n    // idx of element after { last element that touches range or that is before range }\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n      // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n      const joinRange = this._normalizedRanges[joinRangeStartIdx];\n      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n    } else {\n      // First and last element are different - we need to replace the entire range\n      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n    }\n  }\n  contains(lineNumber) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n  }\n  intersects(range) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n  }\n  getUnion(other) {\n    if (this._normalizedRanges.length === 0) {\n      return other;\n    }\n    if (other._normalizedRanges.length === 0) {\n      return this;\n    }\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    let current = null;\n    while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n      let next = null;\n      if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n        const lineRange1 = this._normalizedRanges[i1];\n        const lineRange2 = other._normalizedRanges[i2];\n        if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n          next = lineRange1;\n          i1++;\n        } else {\n          next = lineRange2;\n          i2++;\n        }\n      } else if (i1 < this._normalizedRanges.length) {\n        next = this._normalizedRanges[i1];\n        i1++;\n      } else {\n        next = other._normalizedRanges[i2];\n        i2++;\n      }\n      if (current === null) {\n        current = next;\n      } else {\n        if (current.endLineNumberExclusive >= next.startLineNumber) {\n          // merge\n          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n        } else {\n          // push\n          result.push(current);\n          current = next;\n        }\n      }\n    }\n    if (current !== null) {\n      result.push(current);\n    }\n    return new LineRangeSet(result);\n  }\n  /**\n   * Subtracts all ranges in this set from `range` and returns the result.\n   */\n  subtractFrom(range) {\n    // idx of first element that touches range or that is after range\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n    // idx of element after { last element that touches range or that is before range }\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      return new LineRangeSet([range]);\n    }\n    const result = [];\n    let startLineNumber = range.startLineNumber;\n    for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n      const r = this._normalizedRanges[i];\n      if (r.startLineNumber > startLineNumber) {\n        result.push(new LineRange(startLineNumber, r.startLineNumber));\n      }\n      startLineNumber = r.endLineNumberExclusive;\n    }\n    if (startLineNumber < range.endLineNumberExclusive) {\n      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n    }\n    return new LineRangeSet(result);\n  }\n  toString() {\n    return this._normalizedRanges.map(r => r.toString()).join(', ');\n  }\n  getIntersection(other) {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n      const r1 = this._normalizedRanges[i1];\n      const r2 = other._normalizedRanges[i2];\n      const i = r1.intersect(r2);\n      if (i && !i.isEmpty) {\n        result.push(i);\n      }\n      if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n        i1++;\n      } else {\n        i2++;\n      }\n    }\n    return new LineRangeSet(result);\n  }\n  getWithDelta(value) {\n    return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n  }\n}","map":{"version":3,"names":["BugIndicatingError","OffsetRange","Range","findFirstIdxMonotonousOrArrLen","findLastIdxMonotonous","findLastMonotonous","LineRange","fromRange","range","startLineNumber","endLineNumber","fromRangeInclusive","joinMany","lineRanges","length","result","LineRangeSet","slice","i","getUnion","ranges","ofLength","deserialize","lineRange","constructor","endLineNumberExclusive","contains","lineNumber","isEmpty","delta","offset","deltaLength","join","other","Math","min","max","toString","intersect","undefined","intersectsStrict","overlapOrTouch","equals","b","toInclusiveRange","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","push","forEach","serialize","includes","toOffsetRange","_normalizedRanges","addRange","joinRangeStartIdx","r","joinRangeEndIdxExclusive","splice","joinRange","rangeThatStartsBeforeEnd","intersects","i1","i2","current","next","lineRange1","lineRange2","subtractFrom","map","getIntersection","r1","r2","getWithDelta","value"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}