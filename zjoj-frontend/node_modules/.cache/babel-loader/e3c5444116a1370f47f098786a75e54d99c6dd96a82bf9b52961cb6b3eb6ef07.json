{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  // Sometimes, calling this function twice improves the result.\n  // Uncomment the second invocation and run the tests to see the difference.\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  const result = [];\n  result.push(sequenceDiffs[0]);\n  // First move them all to the left as much as possible and join them if possible\n  for (let i = 1; i < sequenceDiffs.length; i++) {\n    const prevResult = result[result.length - 1];\n    let cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      let d;\n      for (d = 1; d <= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        // Merge previous and current diff\n        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  const result2 = [];\n  // Then move them all to the right and join them again if possible\n  for (let i = 0; i < result.length - 1; i++) {\n    const nextResult = result[i + 1];\n    let cur = result[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n      let d;\n      for (d = 0; d < length; d++) {\n        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n          break;\n        }\n      }\n      if (d === length) {\n        // Merge previous and current diff, write to result!\n        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n        continue;\n      }\n      if (d > 0) {\n        cur = cur.delta(d);\n      }\n    }\n    result2.push(cur);\n  }\n  if (result.length > 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i < sequenceDiffs.length; i++) {\n    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : undefined;\n    const diff = sequenceDiffs[i];\n    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined;\n    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  const maxShiftLimit = 100; // To prevent performance issues\n  // don't touch previous or next!\n  let deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 && deltaAfter === 0) {\n    return diff;\n  }\n  // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n  // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n  let bestDelta = 0;\n  let bestScore = -1;\n  // find best scored delta\n  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n  const additional = [];\n  let lastModifiedWord = undefined;\n  function maybePushWordToAdditional() {\n    if (!lastModifiedWord) {\n      return;\n    }\n    const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n    const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n    if (originalLength1 !== originalLength2) {\n      // TODO figure out why this happens\n    }\n    if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n      additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n    }\n    lastModifiedWord = undefined;\n  }\n  for (const s of sequenceDiffs) {\n    function processWord(s1Range, s2Range) {\n      var _a, _b, _c, _d;\n      if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n        if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n          const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n          const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n          lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n          lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n          lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n          lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n        } else {\n          maybePushWordToAdditional();\n          lastModifiedWord = {\n            added: 0,\n            deleted: 0,\n            count: 0,\n            s1Range: s1Range,\n            s2Range: s2Range\n          };\n        }\n      }\n      const changedS1 = s1Range.intersect(s.seq1Range);\n      const changedS2 = s2Range.intersect(s.seq2Range);\n      lastModifiedWord.count++;\n      lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n      lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n    }\n    const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n    const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n    const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n    const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n    if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n      processWord(w1Before, w2Before);\n    } else {\n      if (w1Before && w2Before) {\n        processWord(w1Before, w2Before);\n      }\n      if (w1After && w2After) {\n        processWord(w1After, w2After);\n      }\n    }\n  }\n  maybePushWordToAdditional();\n  const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  const result = [];\n  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n    const sd1 = sequenceDiffs1[0];\n    const sd2 = sequenceDiffs2[0];\n    let next;\n    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [diffs[0]];\n    for (let i = 1; i < diffs.length; i++) {\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      function shouldJoinDiffs(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedText = sequence1.getText(unchangedRange);\n        const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n          return true;\n        }\n        return false;\n      }\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [diffs[0]];\n    for (let i = 1; i < diffs.length; i++) {\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      function shouldJoinDiffs(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n          return false;\n        }\n        const unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n          return false;\n        }\n        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        const beforeSeq1Length = before.seq1Range.length;\n        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        const beforeSeq2Length = before.seq2Range.length;\n        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        const afterSeq1Length = after.seq1Range.length;\n        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        const afterSeq2Length = after.seq2Range.length;\n        // TODO: Maybe a neural net can be used to derive the result from these numbers\n        const max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {\n          return true;\n        }\n        return false;\n      }\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  const newDiffs = [];\n  // Remove short suffixes/prefixes\n  forEachWithNeighbors(diffs, (prev, cur, next) => {\n    let newDiff = cur;\n    function shouldMarkAsChanged(text) {\n      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n    }\n    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n    if (shouldMarkAsChanged(prefix)) {\n      newDiff = newDiff.deltaStart(-prefix.length);\n    }\n    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n    if (shouldMarkAsChanged(suffix)) {\n      newDiff = newDiff.deltaEnd(suffix.length);\n    }\n    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n    const result = newDiff.intersect(availableSpace);\n    newDiffs.push(result);\n  });\n  return newDiffs;\n}","map":{"version":3,"names":["forEachWithNeighbors","OffsetRange","OffsetPair","SequenceDiff","optimizeSequenceDiffs","sequence1","sequence2","sequenceDiffs","result","joinSequenceDiffsByShifting","shiftSequenceDiffs","length","push","i","prevResult","cur","seq1Range","isEmpty","seq2Range","start","endExclusive","d","getElement","delta","result2","nextResult","isStronglyEqual","getBoundaryScore","prevDiff","undefined","diff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","swap","maxShiftLimit","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","removeShortMatches","s","last","join","extendDiffsToEntireWordIfAppropriate","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","originalLength2","s2Range","added","Math","max","count","processWord","_a","_b","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","intersect","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","equals","merged","mergeSequenceDiffs","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","removeVeryShortMatchingLinesBetweenDiffs","_sequence2","diffs","counter","shouldRepeat","lastResult","shouldJoinDiffs","before","after","unchangedRange","unchangedText","getText","unchangedTextWithoutWs","replace","shouldJoin","removeVeryShortMatchingTextBetweenLongDiffs","unchangedLineCount","countLinesIn","trim","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","v","min","pow","newDiffs","prev","newDiff","shouldMarkAsChanged","text","fullRange1","extendToFullLines","prefix","deltaStart","suffix","deltaEnd","availableSpace","fromOffsetPairs","getEndExclusives","zero","getStarts"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        newDiffs.push(result);\n    });\n    return newDiffs;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}