{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n  constructor(configuration, theme, tokensColorTracker) {\n    const options = configuration.options;\n    const pixelRatio = options.get(141 /* EditorOption.pixelRatio */);\n    const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n    const minimapLayout = layoutInfo.minimap;\n    const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    const minimapOpts = options.get(72 /* EditorOption.minimap */);\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(104 /* EditorOption.scrollBeyondLastLine */);\n    this.paddingTop = options.get(83 /* EditorOption.padding */).top;\n    this.paddingBottom = options.get(83 /* EditorOption.padding */).bottom;\n    this.showSlider = minimapOpts.showSlider;\n    this.autohide = minimapOpts.autohide;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(66 /* EditorOption.lineHeight */);\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n    this.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n    this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n    this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n  }\n  static _getMinimapBackground(theme, defaultBackgroundColor) {\n    const themeColor = theme.getColor(minimapBackground);\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n    }\n    return defaultBackgroundColor;\n  }\n  static _getMinimapForegroundOpacity(theme) {\n    const themeColor = theme.getColor(minimapForegroundOpacity);\n    if (themeColor) {\n      return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n    }\n    return 255;\n  }\n  equals(other) {\n    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.paddingTop === other.paddingTop && this.paddingBottom === other.paddingBottom && this.showSlider === other.showSlider && this.autohide === other.autohide && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;\n  }\n}\nclass MinimapLayout {\n  constructor(\n  /**\n   * The given editor scrollTop (input).\n   */\n  scrollTop,\n  /**\n   * The given editor scrollHeight (input).\n   */\n  scrollHeight, sliderNeeded, _computedSliderRatio,\n  /**\n   * slider dom node top (in CSS px)\n   */\n  sliderTop,\n  /**\n   * slider dom node height (in CSS px)\n   */\n  sliderHeight,\n  /**\n   * empty lines to reserve at the top of the minimap.\n   */\n  topPaddingLineCount,\n  /**\n   * minimap render start line number.\n   */\n  startLineNumber,\n  /**\n   * minimap render end line number.\n   */\n  endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = _computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.topPaddingLineCount = topPaddingLineCount;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n  getDesiredScrollTopFromDelta(delta) {\n    return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n  }\n  getDesiredScrollTopFromTouchLocation(pageY) {\n    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n  }\n  /**\n   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n   */\n  intersectWithViewport(range) {\n    const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n    const endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n    if (startLineNumber > endLineNumber) {\n      // entirely outside minimap's viewport\n      return null;\n    }\n    return [startLineNumber, endLineNumber];\n  }\n  /**\n   * Get the inner minimap y coordinate for a line number.\n   */\n  getYForLineNumber(lineNumber, minimapLineHeight) {\n    return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n  }\n  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n    const pixelRatio = options.pixelRatio;\n    const minimapLineHeight = options.minimapLineHeight;\n    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    const lineHeight = options.lineHeight;\n    if (options.minimapHeightIsEditorHeight) {\n      let logicalScrollHeight = realLineCount * options.lineHeight + options.paddingTop + options.paddingBottom;\n      if (options.scrollBeyondLastLine) {\n        logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n      }\n      const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n      const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n      // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n      const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      const sliderTop = scrollTop * computedSliderRatio;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n      const topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n    }\n    // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n    let sliderHeight;\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n    const extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n    let extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n    if (options.scrollBeyondLastLine) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n    }\n    let maxMinimapSliderTop;\n    if (extraLinesAtTheBottom > 0) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n    // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    const sliderTop = scrollTop * computedSliderRatio;\n    if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n    } else {\n      let consideringStartLineNumber;\n      if (viewportStartLineNumber > 1) {\n        consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n      } else {\n        consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n      }\n      let topPaddingLineCount;\n      let startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n      if (startLineNumber < extraLinesAtTheTop) {\n        topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n        startLineNumber = 1;\n      } else {\n        topPaddingLineCount = 0;\n        startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n      }\n      // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n          topPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n        }\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n          topPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n        }\n      }\n      const endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n      const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n      let sliderTopAligned;\n      if (scrollTop >= options.paddingTop) {\n        sliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n      } else {\n        sliderTopAligned = scrollTop / options.paddingTop * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n      }\n      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n    }\n  }\n}\nclass MinimapLine {\n  constructor(dy) {\n    this.dy = dy;\n  }\n  onContentChanged() {\n    this.dy = -1;\n  }\n  onTokensChanged() {\n    this.dy = -1;\n  }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n  constructor(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n  linesEquals(layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n    const tmp = this._renderedLines._get();\n    const lines = tmp.lines;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Check if the current RenderData matches the new layout's scroll position\n   */\n  scrollEquals(layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  }\n  _get() {\n    const tmp = this._renderedLines._get();\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n  }\n  onTokensChanged(ranges) {\n    return this._renderedLines.onTokensChanged(ranges);\n  }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n  constructor(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n  getBuffer() {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    const result = this._buffers[this._lastUsedBuffer];\n    // fill with background color\n    result.data.set(this._backgroundFillData);\n    return result;\n  }\n  static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n    const backgroundR = background.r;\n    const backgroundG = background.g;\n    const backgroundB = background.b;\n    const backgroundA = background.a;\n    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    let offset = 0;\n    for (let i = 0; i < HEIGHT; i++) {\n      for (let j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = backgroundA;\n        offset += 4;\n      }\n    }\n    return result;\n  }\n}\nclass MinimapSamplingState {\n  static compute(options, viewLineCount, oldSamplingState) {\n    if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n      return [null, []];\n    }\n    // ratio is intentionally not part of the layout to avoid the layout changing all the time\n    // so we need to recompute it again...\n    const {\n      minimapLineCount\n    } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n      viewLineCount: viewLineCount,\n      scrollBeyondLastLine: options.scrollBeyondLastLine,\n      paddingTop: options.paddingTop,\n      paddingBottom: options.paddingBottom,\n      height: options.editorHeight,\n      lineHeight: options.lineHeight,\n      pixelRatio: options.pixelRatio\n    });\n    const ratio = viewLineCount / minimapLineCount;\n    const halfRatio = ratio / 2;\n    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n      const result = [];\n      result[0] = 1;\n      if (minimapLineCount > 1) {\n        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n          result[i] = Math.round(i * ratio + halfRatio);\n        }\n        result[minimapLineCount - 1] = viewLineCount;\n      }\n      return [new MinimapSamplingState(ratio, result), []];\n    }\n    const oldMinimapLines = oldSamplingState.minimapLines;\n    const oldLength = oldMinimapLines.length;\n    const result = [];\n    let oldIndex = 0;\n    let oldDeltaLineCount = 0;\n    let minViewLineNumber = 1;\n    const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n    let events = [];\n    let lastEvent = null;\n    for (let i = 0; i < minimapLineCount; i++) {\n      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: oldMinimapLineNumber,\n              deleteToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount--;\n        }\n        oldIndex++;\n      }\n      let selectedViewLineNumber;\n      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n        // reuse the old sampled line\n        selectedViewLineNumber = oldMinimapLines[oldIndex];\n        oldIndex++;\n      } else {\n        if (i === 0) {\n          selectedViewLineNumber = 1;\n        } else if (i + 1 === minimapLineCount) {\n          selectedViewLineNumber = viewLineCount;\n        } else {\n          selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n            lastEvent.insertToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'inserted',\n              _i: i,\n              insertFromLineNumber: oldMinimapLineNumber,\n              insertToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount++;\n        }\n      }\n      result[i] = selectedViewLineNumber;\n      minViewLineNumber = selectedViewLineNumber;\n    }\n    if (events.length < MAX_EVENT_COUNT) {\n      while (oldIndex < oldLength) {\n        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n        if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n          lastEvent.deleteToLineNumber++;\n        } else {\n          lastEvent = {\n            type: 'deleted',\n            _oldIndex: oldIndex,\n            deleteFromLineNumber: oldMinimapLineNumber,\n            deleteToLineNumber: oldMinimapLineNumber\n          };\n          events.push(lastEvent);\n        }\n        oldDeltaLineCount--;\n        oldIndex++;\n      }\n    } else {\n      // too many events, just give up\n      events = [{\n        type: 'flush'\n      }];\n    }\n    return [new MinimapSamplingState(ratio, result), events];\n  }\n  constructor(samplingRatio, minimapLines) {\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n  modelLineToMinimapLine(lineNumber) {\n    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n  }\n  /**\n   * Will return null if the model line ranges are not intersecting with a sampled model line.\n   */\n  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n      fromLineIndex--;\n    }\n    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n      toLineIndex++;\n    }\n    if (fromLineIndex === toLineIndex) {\n      const sampledLineNumber = this.minimapLines[fromLineIndex];\n      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n        // This line is not part of the sampled lines ==> nothing to do\n        return null;\n      }\n    }\n    return [fromLineIndex + 1, toLineIndex + 1];\n  }\n  /**\n   * Will always return a range, even if it is not intersecting with a sampled model line.\n   */\n  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n      if (minimapLineEnd === this.minimapLines.length) {\n        if (minimapLineStart > 1) {\n          minimapLineStart--;\n        }\n      } else {\n        minimapLineEnd++;\n      }\n    }\n    return [minimapLineStart, minimapLineEnd];\n  }\n  onLinesDeleted(e) {\n    // have the mapping be sticky\n    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    let changeStartIndex = this.minimapLines.length;\n    let changeEndIndex = 0;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      if (this.minimapLines[i] <= e.toLineNumber) {\n        // this line got deleted => move to previous available\n        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n        changeStartIndex = Math.min(changeStartIndex, i);\n        changeEndIndex = Math.max(changeEndIndex, i);\n      } else {\n        this.minimapLines[i] -= deletedLineCount;\n      }\n    }\n    return [changeStartIndex, changeEndIndex];\n  }\n  onLinesInserted(e) {\n    // have the mapping be sticky\n    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      this.minimapLines[i] += insertedLineCount;\n    }\n  }\n}\nexport class Minimap extends ViewPart {\n  constructor(context) {\n    super(context);\n    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    this._selections = [];\n    this._minimapSelections = null;\n    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n    this._samplingState = samplingState;\n    this._shouldCheckSampling = false;\n    this._actual = new InnerMinimap(context.theme, this);\n  }\n  dispose() {\n    this._actual.dispose();\n    super.dispose();\n  }\n  getDomNode() {\n    return this._actual.getDomNode();\n  }\n  _onOptionsMaybeChanged() {\n    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    if (this.options.equals(opts)) {\n      return false;\n    }\n    this.options = opts;\n    this._recreateLineSampling();\n    this._actual.onDidChangeOptions();\n    return true;\n  }\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections;\n    this._minimapSelections = null;\n    return this._actual.onSelectionChanged();\n  }\n  onDecorationsChanged(e) {\n    if (e.affectsMinimap) {\n      return this._actual.onDecorationsChanged();\n    }\n    return false;\n  }\n  onFlushed(e) {\n    if (this._samplingState) {\n      this._shouldCheckSampling = true;\n    }\n    return this._actual.onFlushed();\n  }\n  onLinesChanged(e) {\n    if (this._samplingState) {\n      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n      if (minimapLineRange) {\n        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n    }\n  }\n  onLinesDeleted(e) {\n    if (this._samplingState) {\n      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n      if (changeStartIndex <= changeEndIndex) {\n        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n      }\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onLinesInserted(e) {\n    if (this._samplingState) {\n      this._samplingState.onLinesInserted(e);\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onScrollChanged(e) {\n    return this._actual.onScrollChanged();\n  }\n  onThemeChanged(e) {\n    this._actual.onThemeChanged();\n    this._onOptionsMaybeChanged();\n    return true;\n  }\n  onTokensChanged(e) {\n    if (this._samplingState) {\n      const ranges = [];\n      for (const range of e.ranges) {\n        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n        if (minimapLineRange) {\n          ranges.push({\n            fromLineNumber: minimapLineRange[0],\n            toLineNumber: minimapLineRange[1]\n          });\n        }\n      }\n      if (ranges.length) {\n        return this._actual.onTokensChanged(ranges);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onTokensChanged(e.ranges);\n    }\n  }\n  onTokensColorsChanged(e) {\n    this._onOptionsMaybeChanged();\n    return this._actual.onTokensColorsChanged();\n  }\n  onZonesChanged(e) {\n    return this._actual.onZonesChanged();\n  }\n  // --- end event handlers\n  prepareRender(ctx) {\n    if (this._shouldCheckSampling) {\n      this._shouldCheckSampling = false;\n      this._recreateLineSampling();\n    }\n  }\n  render(ctx) {\n    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n    if (this._samplingState) {\n      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n    }\n    const minimapCtx = {\n      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n      scrollWidth: ctx.scrollWidth,\n      scrollHeight: ctx.scrollHeight,\n      viewportStartLineNumber: viewportStartLineNumber,\n      viewportEndLineNumber: viewportEndLineNumber,\n      viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n      scrollTop: ctx.scrollTop,\n      scrollLeft: ctx.scrollLeft,\n      viewportWidth: ctx.viewportWidth,\n      viewportHeight: ctx.viewportHeight\n    };\n    this._actual.render(minimapCtx);\n  }\n  //#region IMinimapModel\n  _recreateLineSampling() {\n    this._minimapSelections = null;\n    const wasSampling = Boolean(this._samplingState);\n    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n    this._samplingState = samplingState;\n    if (wasSampling && this._samplingState) {\n      // was sampling, is sampling\n      for (const event of events) {\n        switch (event.type) {\n          case 'deleted':\n            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n            break;\n          case 'inserted':\n            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n            break;\n          case 'flush':\n            this._actual.onFlushed();\n            break;\n        }\n      }\n    }\n  }\n  getLineCount() {\n    if (this._samplingState) {\n      return this._samplingState.minimapLines.length;\n    }\n    return this._context.viewModel.getLineCount();\n  }\n  getRealLineCount() {\n    return this._context.viewModel.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineContent(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineMaxColumn(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    if (this._samplingState) {\n      const result = [];\n      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n        } else {\n          result[lineIndex] = null;\n        }\n      }\n      return result;\n    }\n    return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n  }\n  getSelections() {\n    if (this._minimapSelections === null) {\n      if (this._samplingState) {\n        this._minimapSelections = [];\n        for (const selection of this._selections) {\n          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n        }\n      } else {\n        this._minimapSelections = this._selections;\n      }\n    }\n    return this._minimapSelections;\n  }\n  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    let visibleRange;\n    if (this._samplingState) {\n      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n    } else {\n      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n    }\n    const decorations = this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n    if (this._samplingState) {\n      const result = [];\n      for (const decoration of decorations) {\n        if (!decoration.options.minimap) {\n          continue;\n        }\n        const range = decoration.range;\n        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n      }\n      return result;\n    }\n    return decorations;\n  }\n  getOptions() {\n    return this._context.viewModel.model.getOptions();\n  }\n  revealLineNumber(lineNumber) {\n    if (this._samplingState) {\n      lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n    }\n    this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n  }\n  setScrollTop(scrollTop) {\n    this._context.viewModel.viewLayout.setScrollPosition({\n      scrollTop: scrollTop\n    }, 1 /* ScrollType.Immediate */);\n  }\n}\nclass InnerMinimap extends Disposable {\n  constructor(theme, model) {\n    super();\n    this._renderDecorations = false;\n    this._gestureInProgress = false;\n    this._theme = theme;\n    this._model = model;\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this._domNode, 8 /* PartFingerprint.Minimap */);\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    this._domNode.setPosition('absolute');\n    this._domNode.setAttribute('role', 'presentation');\n    this._domNode.setAttribute('aria-hidden', 'true');\n    this._shadow = createFastDomNode(document.createElement('div'));\n    this._shadow.setClassName('minimap-shadow-hidden');\n    this._domNode.appendChild(this._shadow);\n    this._canvas = createFastDomNode(document.createElement('canvas'));\n    this._canvas.setPosition('absolute');\n    this._canvas.setLeft(0);\n    this._domNode.appendChild(this._canvas);\n    this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n    this._decorationsCanvas.setPosition('absolute');\n    this._decorationsCanvas.setClassName('minimap-decorations-layer');\n    this._decorationsCanvas.setLeft(0);\n    this._domNode.appendChild(this._decorationsCanvas);\n    this._slider = createFastDomNode(document.createElement('div'));\n    this._slider.setPosition('absolute');\n    this._slider.setClassName('minimap-slider');\n    this._slider.setLayerHinting(true);\n    this._slider.setContain('strict');\n    this._domNode.appendChild(this._slider);\n    this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n    this._sliderHorizontal.setPosition('absolute');\n    this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n    this._slider.appendChild(this._sliderHorizontal);\n    this._applyLayout();\n    this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      const renderMinimap = this._model.options.renderMinimap;\n      if (renderMinimap === 0 /* RenderMinimap.None */) {\n        return;\n      }\n      if (!this._lastRenderData) {\n        return;\n      }\n      if (this._model.options.size !== 'proportional') {\n        if (e.button === 0 && this._lastRenderData) {\n          // pretend the click occurred in the center of the slider\n          const position = dom.getDomNodePagePosition(this._slider.domNode);\n          const initialPosY = position.top + position.height / 2;\n          this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n        }\n        return;\n      }\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.offsetY;\n      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n      lineNumber = Math.min(lineNumber, this._model.getLineCount());\n      this._model.revealLineNumber(lineNumber);\n    });\n    this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n    this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.button === 0 && this._lastRenderData) {\n        this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n      }\n    });\n    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n    this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData) {\n        this._slider.toggleClassName('active', true);\n        this._gestureInProgress = true;\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData && this._gestureInProgress) {\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      this._gestureInProgress = false;\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  _startSliderDragging(e, initialPosY, initialSliderState) {\n    if (!e.target || !(e.target instanceof Element)) {\n      return;\n    }\n    const initialPosX = e.pageX;\n    this._slider.toggleClassName('active', true);\n    const handlePointerMove = (posy, posx) => {\n      const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n      const pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n      if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n        // The pointer has wondered away from the scrollbar => reset dragging\n        this._model.setScrollTop(initialSliderState.scrollTop);\n        return;\n      }\n      const pointerDelta = posy - initialPosY;\n      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n    };\n    if (e.pageY !== initialPosY) {\n      handlePointerMove(e.pageY, initialPosX);\n    }\n    this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  scrollDueToTouchEvent(touch) {\n    const startY = this._domNode.domNode.getBoundingClientRect().top;\n    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n    this._model.setScrollTop(scrollTop);\n  }\n  dispose() {\n    this._pointerDownListener.dispose();\n    this._sliderPointerMoveMonitor.dispose();\n    this._sliderPointerDownListener.dispose();\n    this._gestureDisposable.dispose();\n    this._sliderTouchStartListener.dispose();\n    this._sliderTouchMoveListener.dispose();\n    this._sliderTouchEndListener.dispose();\n    super.dispose();\n  }\n  _getMinimapDomNodeClassName() {\n    const class_ = ['minimap'];\n    if (this._model.options.showSlider === 'always') {\n      class_.push('slider-always');\n    } else {\n      class_.push('slider-mouseover');\n    }\n    if (this._model.options.autohide) {\n      class_.push('autohide');\n    }\n    return class_.join(' ');\n  }\n  getDomNode() {\n    return this._domNode;\n  }\n  _applyLayout() {\n    this._domNode.setLeft(this._model.options.minimapLeft);\n    this._domNode.setWidth(this._model.options.minimapWidth);\n    this._domNode.setHeight(this._model.options.minimapHeight);\n    this._shadow.setHeight(this._model.options.minimapHeight);\n    this._canvas.setWidth(this._model.options.canvasOuterWidth);\n    this._canvas.setHeight(this._model.options.canvasOuterHeight);\n    this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._slider.setWidth(this._model.options.minimapWidth);\n  }\n  _getBuffer() {\n    if (!this._buffers) {\n      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n      }\n    }\n    return this._buffers ? this._buffers.getBuffer() : null;\n  }\n  // ---- begin view event handlers\n  onDidChangeOptions() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._applyLayout();\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n  }\n  onSelectionChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onDecorationsChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onFlushed() {\n    this._lastRenderData = null;\n    return true;\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    return false;\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    return true;\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    return true;\n  }\n  onScrollChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onThemeChanged() {\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._renderDecorations = true;\n    return true;\n  }\n  onTokensChanged(ranges) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(ranges);\n    }\n    return false;\n  }\n  onTokensColorsChanged() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  }\n  onZonesChanged() {\n    this._lastRenderData = null;\n    return true;\n  }\n  // --- end event handlers\n  render(renderingCtx) {\n    const renderMinimap = this._model.options.renderMinimap;\n    if (renderMinimap === 0 /* RenderMinimap.None */) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n      this._sliderHorizontal.setWidth(0);\n      this._sliderHorizontal.setHeight(0);\n      return;\n    }\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n    const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n    this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n    this._slider.setTop(layout.sliderTop);\n    this._slider.setHeight(layout.sliderHeight);\n    // Compute horizontal slider coordinates\n    this._sliderHorizontal.setLeft(0);\n    this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n    this._sliderHorizontal.setTop(0);\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  }\n  renderDecorations(layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n      const selections = this._model.getSelections();\n      selections.sort(Range.compareRangesUsingStarts);\n      const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n      decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n      const {\n        canvasInnerWidth,\n        canvasInnerHeight\n      } = this._model.options;\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const minimapCharWidth = this._model.options.minimapCharWidth;\n      const tabSize = this._model.getOptions().tabSize;\n      const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n      // We first need to render line highlights and then render decorations on top of those.\n      // But we need to pick a single color for each line, and use that as a line highlight.\n      // This needs to be the color of the decoration with the highest `zIndex`, but priority\n      // is given to the selection.\n      const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n      this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n      this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n      const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n      this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n      this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n    }\n  }\n  _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n    let y1 = 0;\n    let y2 = 0;\n    for (const selection of selections) {\n      const intersection = layout.intersectWithViewport(selection);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        highlightedLines.set(line, true);\n      }\n      const yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n      const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n      if (y2 >= yy1) {\n        // merge into previous\n        y2 = yy2;\n      } else {\n        if (y2 > y1) {\n          // flush\n          canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n        y1 = yy1;\n        y2 = yy2;\n      }\n    }\n    if (y2 > y1) {\n      // flush\n      canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n    }\n  }\n  _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n    const highlightColors = new Map();\n    // Loop backwards to hit first decorations with higher `zIndex`\n    for (let i = decorations.length - 1; i >= 0; i--) {\n      const decoration = decorations[i];\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n        continue;\n      }\n      const intersection = layout.intersectWithViewport(decoration.range);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      let highlightColor = highlightColors.get(decorationColor.toString());\n      if (!highlightColor) {\n        highlightColor = decorationColor.transparent(0.5).toString();\n        highlightColors.set(decorationColor.toString(), highlightColor);\n      }\n      canvasContext.fillStyle = highlightColor;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        if (highlightedLines.has(line)) {\n          continue;\n        }\n        highlightedLines.set(line, true);\n        const y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n      }\n    }\n  }\n  _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    for (const selection of selections) {\n      const intersection = layout.intersectWithViewport(selection);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n      }\n    }\n  }\n  _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    // Loop forwards to hit first decorations with lower `zIndex`\n    for (const decoration of decorations) {\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions) {\n        continue;\n      }\n      const intersection = layout.intersectWithViewport(decoration.range);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        switch (minimapOptions.position) {\n          case MinimapPosition.Inline:\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n            continue;\n          case MinimapPosition.Gutter:\n            {\n              const y = layout.getYForLineNumber(line, minimapLineHeight);\n              const x = 2;\n              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n              continue;\n            }\n        }\n      }\n    }\n  }\n  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n    const y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n    // Skip rendering the line if it's vertically outside our viewport\n    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n      return;\n    }\n    const {\n      startLineNumber,\n      endLineNumber\n    } = decorationRange;\n    const startColumn = startLineNumber === lineNumber ? decorationRange.startColumn : 1;\n    const endColumn = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);\n    const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n    const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n    this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n  }\n  getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n    if (column === 1) {\n      return MINIMAP_GUTTER_WIDTH;\n    }\n    const minimumXOffset = (column - 1) * charWidth;\n    if (minimumXOffset >= canvasInnerWidth) {\n      // there is no need to look at actual characters,\n      // as this column is certainly after the minimap width\n      return canvasInnerWidth;\n    }\n    // Cache line offset data so that it is only read once per line\n    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n    if (!lineIndexToXOffset) {\n      const lineData = this._model.getLineContent(lineNumber);\n      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n      let prevx = MINIMAP_GUTTER_WIDTH;\n      for (let i = 1; i < lineData.length + 1; i++) {\n        const charCode = lineData.charCodeAt(i - 1);\n        const dx = charCode === 9 /* CharCode.Tab */ ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        const x = prevx + dx;\n        if (x >= canvasInnerWidth) {\n          // no need to keep on going, as we've hit the canvas width\n          lineIndexToXOffset[i] = canvasInnerWidth;\n          break;\n        }\n        lineIndexToXOffset[i] = x;\n        prevx = x;\n      }\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n    if (column - 1 < lineIndexToXOffset.length) {\n      return lineIndexToXOffset[column - 1];\n    }\n    // goes over the canvas width\n    return canvasInnerWidth;\n  }\n  renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  }\n  renderLines(layout) {\n    const startLineNumber = layout.startLineNumber;\n    const endLineNumber = layout.endLineNumber;\n    const minimapLineHeight = this._model.options.minimapLineHeight;\n    // Check if nothing changed w.r.t. lines from last frame\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      const _lastData = this._lastRenderData._get();\n      // Nice!! Nothing changed from last frame\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    }\n    // Oh well!! We need to repaint some lines...\n    const imageData = this._getBuffer();\n    if (!imageData) {\n      // 0 width or 0 height canvas, nothing to do\n      return null;\n    }\n    // Render untouched lines by using last rendered data.\n    const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n    // Fetch rendering info from view model for rest of lines that need rendering.\n    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n    const tabSize = this._model.getOptions().tabSize;\n    const defaultBackground = this._model.options.defaultBackgroundColor;\n    const background = this._model.options.backgroundColor;\n    const foregroundAlpha = this._model.options.foregroundAlpha;\n    const tokensColorTracker = this._model.tokensColorTracker;\n    const useLighterFont = tokensColorTracker.backgroundIsLight();\n    const renderMinimap = this._model.options.renderMinimap;\n    const charRenderer = this._model.options.charRenderer();\n    const fontScale = this._model.options.fontScale;\n    const minimapCharWidth = this._model.options.minimapCharWidth;\n    const baseCharHeight = renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1;\n    const renderMinimapLineHeight = baseCharHeight * fontScale;\n    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;\n    // Render the rest of lines\n    const backgroundA = background.a / 255;\n    const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n    let dy = layout.topPaddingLineCount * minimapLineHeight;\n    const renderedLines = [];\n    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n      }\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    const dirtyHeight = dirtyY2 - dirtyY1;\n    // Finally, paint to the canvas\n    const ctx = this._canvas.domNode.getContext('2d');\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n    // Save rendered data for reuse on next frame if possible\n    return new RenderData(layout, imageData, renderedLines);\n  }\n  static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    const needed = [];\n    if (!lastRenderData) {\n      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n      return [-1, -1, needed];\n    }\n    const _lastData = lastRenderData._get();\n    const lastTargetData = _lastData.imageData.data;\n    const lastStartLineNumber = _lastData.rendLineNumberStart;\n    const lastLines = _lastData.lines;\n    const lastLinesLength = lastLines.length;\n    const WIDTH = target.width;\n    const targetData = target.data;\n    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n    let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n    let copySourceStart = -1;\n    let copySourceEnd = -1;\n    let copyDestStart = -1;\n    let copyDestEnd = -1;\n    let dest_dy = topPaddingLineCount * minimapLineHeight;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - startLineNumber;\n      const lastLineIndex = lineNumber - lastStartLineNumber;\n      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n      const sourceStart = source_dy * WIDTH * 4;\n      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      const destStart = dest_dy * WIDTH * 4;\n      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  }\n  static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n    const content = lineData.content;\n    const tokens = lineData.tokens;\n    const maxDx = target.width - charWidth;\n    const force1pxHeight = minimapLineHeight === 1;\n    let dx = MINIMAP_GUTTER_WIDTH;\n    let charIndex = 0;\n    let tabsCharDelta = 0;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      const tokenColorId = tokens.getForeground(tokenIndex);\n      const tokenColor = colorTracker.getColor(tokenColorId);\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n        const charCode = content.charCodeAt(charIndex);\n        if (charCode === 9 /* CharCode.Tab */) {\n          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1;\n          // No need to render anything since tab is invisible\n          dx += insertSpacesCount * charWidth;\n        } else if (charCode === 32 /* CharCode.Space */) {\n          // No need to render anything since space is invisible\n          dx += charWidth;\n        } else {\n          // Render twice for a full width character\n          const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n          for (let i = 0; i < count; i++) {\n            if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n            } else {\n              // RenderMinimap.Text\n              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n            }\n            dx += charWidth;\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\nclass ContiguousLineMap {\n  constructor(startLineNumber, endLineNumber, defaultValue) {\n    this._startLineNumber = startLineNumber;\n    this._endLineNumber = endLineNumber;\n    this._defaultValue = defaultValue;\n    this._values = [];\n    for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n      this._values[i] = defaultValue;\n    }\n  }\n  has(lineNumber) {\n    return this.get(lineNumber) !== this._defaultValue;\n  }\n  set(lineNumber, value) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return;\n    }\n    this._values[lineNumber - this._startLineNumber] = value;\n  }\n  get(lineNumber) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return this._defaultValue;\n    }\n    return this._values[lineNumber - this._startLineNumber];\n  }\n}","map":{"version":3,"names":["dom","createFastDomNode","GlobalPointerMoveMonitor","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","minimapBackground","minimapForegroundOpacity","Selection","EventType","Gesture","MinimapCharRendererFactory","MinimapPosition","createSingleCallFunction","POINTER_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","constructor","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","paddingTop","top","paddingBottom","bottom","showSlider","autohide","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","create","fontFamily","defaultBackgroundColor","getColor","backgroundColor","_getMinimapBackground","foregroundAlpha","_getMinimapForegroundOpacity","themeColor","rgba","r","g","b","Math","round","a","_clamp","equals","other","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","_computedSliderRatio","sliderTop","sliderHeight","topPaddingLineCount","startLineNumber","endLineNumber","getDesiredScrollTopFromDelta","delta","getDesiredScrollTopFromTouchLocation","pageY","intersectWithViewport","range","max","min","getYForLineNumber","lineNumber","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","maxMinimapSliderTop","computedSliderRatio","maxLinesFitting","viewportLineCount","expectedViewportLineCount","extraLinesAtTheTop","extraLinesAtTheBottom","consideringStartLineNumber","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeCount","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","backgroundA","Uint8ClampedArray","offset","j","MinimapSamplingState","compute","viewLineCount","oldSamplingState","minimapLineCount","computeContainedMinimapLineCount","ratio","halfRatio","minimapLines","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","samplingRatio","modelLineToMinimapLine","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","context","getInstance","_selections","_minimapSelections","_context","samplingState","viewModel","getLineCount","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","count","onScrollChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","event","getRealLineCount","getLineContent","getLineMaxColumn","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","selection","startColumn","endColumn","getMinimapDecorationsInViewport","modelStartLineNumber","modelEndLineNumber","decorations","getMinimapDecorationsInRange","decoration","minimapStartLineNumber","minimapEndLineNumber","getOptions","model","revealLineNumber","revealRange","setScrollTop","viewLayout","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_pointerDownListener","addStandardDisposableListener","domNode","POINTER_DOWN","preventDefault","button","position","getDomNodePagePosition","initialPosY","_startSliderDragging","internalOffsetY","offsetY","_sliderPointerMoveMonitor","_sliderPointerDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialSliderState","target","Element","initialPosX","pageX","handlePointerMove","posy","posx","minimapPosition","pointerOrthogonalDelta","abs","left","width","isWindows","pointerDelta","startMonitoring","pointerId","buttons","pointerMoveData","touch","startY","getBoundingClientRect","class_","join","setWidth","setHeight","_getBuffer","getContext","_a","renderingCtx","setDisplay","setTop","renderDecorations","renderLines","sort","compareRangesUsingStarts","zIndex","tabSize","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","isTransparent","fillStyle","transparent","toString","y1","y2","intersection","line","yy1","yy2","fillRect","canvas","highlightColors","Map","minimapOptions","Inline","decorationColor","value","highlightColor","has","y","characterWidth","renderDecorationOnLine","Gutter","x","renderDecoration","decorationRange","charWidth","x1","getXOffsetForPosition","x2","column","minimumXOffset","lineIndexToXOffset","lineData","prevx","charCode","charCodeAt","dx","isFullWidthCharacter","_lastData","_dirtyY1","_dirtyY2","_renderUntouchedLines","lineInfo","defaultBackground","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","backgroundAlpha","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","blockRenderChar","renderChar","defaultValue","_startLineNumber","_endLineNumber","_defaultValue","_values"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(141 /* EditorOption.pixelRatio */);\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const minimapOpts = options.get(72 /* EditorOption.minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(104 /* EditorOption.scrollBeyondLastLine */);\n        this.paddingTop = options.get(83 /* EditorOption.padding */).top;\n        this.paddingBottom = options.get(83 /* EditorOption.padding */).bottom;\n        this.showSlider = minimapOpts.showSlider;\n        this.autohide = minimapOpts.autohide;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(66 /* EditorOption.lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n        this.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n        this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n    }\n    static _getMinimapBackground(theme, defaultBackgroundColor) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultBackgroundColor;\n    }\n    static _getMinimapForegroundOpacity(theme) {\n        const themeColor = theme.getColor(minimapForegroundOpacity);\n        if (themeColor) {\n            return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n        }\n        return 255;\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.paddingTop === other.paddingTop\n            && this.paddingBottom === other.paddingBottom\n            && this.showSlider === other.showSlider\n            && this.autohide === other.autohide\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n            && this.foregroundAlpha === other.foregroundAlpha);\n    }\n}\nclass MinimapLayout {\n    constructor(\n    /**\n     * The given editor scrollTop (input).\n     */\n    scrollTop, \n    /**\n     * The given editor scrollHeight (input).\n     */\n    scrollHeight, sliderNeeded, _computedSliderRatio, \n    /**\n     * slider dom node top (in CSS px)\n     */\n    sliderTop, \n    /**\n     * slider dom node height (in CSS px)\n     */\n    sliderHeight, \n    /**\n     * empty lines to reserve at the top of the minimap.\n     */\n    topPaddingLineCount, \n    /**\n     * minimap render start line number.\n     */\n    startLineNumber, \n    /**\n     * minimap render end line number.\n     */\n    endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = _computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.topPaddingLineCount = topPaddingLineCount;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    /**\n     * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n     */\n    intersectWithViewport(range) {\n        const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n        const endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n        if (startLineNumber > endLineNumber) {\n            // entirely outside minimap's viewport\n            return null;\n        }\n        return [startLineNumber, endLineNumber];\n    }\n    /**\n     * Get the inner minimap y coordinate for a line number.\n     */\n    getYForLineNumber(lineNumber, minimapLineHeight) {\n        return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            let logicalScrollHeight = (realLineCount * options.lineHeight\n                + options.paddingTop\n                + options.paddingBottom);\n            if (options.scrollBeyondLastLine) {\n                logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n            }\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            const topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        const extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n        let extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n        }\n        let maxMinimapSliderTop;\n        if (extraLinesAtTheBottom > 0) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n        }\n        else {\n            let consideringStartLineNumber;\n            if (viewportStartLineNumber > 1) {\n                consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n            }\n            else {\n                consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n            }\n            let topPaddingLineCount;\n            let startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            if (startLineNumber < extraLinesAtTheTop) {\n                topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n                startLineNumber = 1;\n            }\n            else {\n                topPaddingLineCount = 0;\n                startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n            }\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            let sliderTopAligned;\n            if (scrollTop >= options.paddingTop) {\n                sliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            else {\n                sliderTopAligned = (scrollTop / options.paddingTop) * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const backgroundA = background.a;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = backgroundA;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: options.scrollBeyondLastLine,\n            paddingTop: options.paddingTop,\n            paddingBottom: options.paddingBottom,\n            height: options.editorHeight,\n            lineHeight: options.lineHeight,\n            pixelRatio: options.pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            const result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        const result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    constructor(samplingRatio, minimapLines) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            const ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.viewModel.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.viewModel.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineContent(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineMaxColumn(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            const result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n        }\n        const decorations = this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n        if (this._samplingState) {\n            const result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getOptions() {\n        return this._context.viewModel.model.getOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.viewModel.viewLayout.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* ScrollType.Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 8 /* PartFingerprint.Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* RenderMinimap.None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.button === 0 && this._lastRenderData) {\n                    // pretend the click occurred in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n        this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.button === 0 && this._lastRenderData) {\n                this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(e, initialPosY, initialSliderState) {\n        if (!e.target || !(e.target instanceof Element)) {\n            return;\n        }\n        const initialPosX = e.pageX;\n        this._slider.toggleClassName('active', true);\n        const handlePointerMove = (posy, posx) => {\n            const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n            const pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n            if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n                // The pointer has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const pointerDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n        };\n        if (e.pageY !== initialPosY) {\n            handlePointerMove(e.pageY, initialPosX);\n        }\n        this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._pointerDownListener.dispose();\n        this._sliderPointerMoveMonitor.dispose();\n        this._sliderPointerDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        const class_ = ['minimap'];\n        if (this._model.options.showSlider === 'always') {\n            class_.push('slider-always');\n        }\n        else {\n            class_.push('slider-mouseover');\n        }\n        if (this._model.options.autohide) {\n            class_.push('autohide');\n        }\n        return class_.join(' ');\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* RenderMinimap.None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        this._sliderHorizontal.setLeft(0);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            selections.sort(Range.compareRangesUsingStarts);\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const minimapCharWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            // We first need to render line highlights and then render decorations on top of those.\n            // But we need to pick a single color for each line, and use that as a line highlight.\n            // This needs to be the color of the decoration with the highest `zIndex`, but priority\n            // is given to the selection.\n            const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n            this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n            this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n            const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n            this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n            this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n        }\n    }\n    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n        let y1 = 0;\n        let y2 = 0;\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                highlightedLines.set(line, true);\n            }\n            const yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n            const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n            if (y2 >= yy1) {\n                // merge into previous\n                y2 = yy2;\n            }\n            else {\n                if (y2 > y1) {\n                    // flush\n                    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n                }\n                y1 = yy1;\n                y2 = yy2;\n            }\n        }\n        if (y2 > y1) {\n            // flush\n            canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n    }\n    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n        const highlightColors = new Map();\n        // Loop backwards to hit first decorations with higher `zIndex`\n        for (let i = decorations.length - 1; i >= 0; i--) {\n            const decoration = decorations[i];\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            let highlightColor = highlightColors.get(decorationColor.toString());\n            if (!highlightColor) {\n                highlightColor = decorationColor.transparent(0.5).toString();\n                highlightColors.set(decorationColor.toString(), highlightColor);\n            }\n            canvasContext.fillStyle = highlightColor;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                if (highlightedLines.has(line)) {\n                    continue;\n                }\n                highlightedLines.set(line, true);\n                const y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n                canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n            }\n        }\n    }\n    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            }\n        }\n    }\n    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        // Loop forwards to hit first decorations with lower `zIndex`\n        for (const decoration of decorations) {\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                switch (minimapOptions.position) {\n                    case MinimapPosition.Inline:\n                        this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n                        continue;\n                    case MinimapPosition.Gutter: {\n                        const y = layout.getYForLineNumber(line, minimapLineHeight);\n                        const x = 2;\n                        this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n        const y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        const { startLineNumber, endLineNumber } = decorationRange;\n        const startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n        const endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n        const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n        const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n        this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n        if (column === 1) {\n            return MINIMAP_GUTTER_WIDTH;\n        }\n        const minimumXOffset = (column - 1) * charWidth;\n        if (minimumXOffset >= canvasInnerWidth) {\n            // there is no need to look at actual characters,\n            // as this column is certainly after the minimap width\n            return canvasInnerWidth;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            let prevx = MINIMAP_GUTTER_WIDTH;\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* CharCode.Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                const x = prevx + dx;\n                if (x >= canvasInnerWidth) {\n                    // no need to keep on going, as we've hit the canvas width\n                    lineIndexToXOffset[i] = canvasInnerWidth;\n                    break;\n                }\n                lineIndexToXOffset[i] = x;\n                prevx = x;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        if (column - 1 < lineIndexToXOffset.length) {\n            return lineIndexToXOffset[column - 1];\n        }\n        // goes over the canvas width\n        return canvasInnerWidth;\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const defaultBackground = this._model.options.defaultBackgroundColor;\n        const background = this._model.options.backgroundColor;\n        const foregroundAlpha = this._model.options.foregroundAlpha;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        const backgroundA = background.a / 255;\n        const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n        let dy = layout.topPaddingLineCount * minimapLineHeight;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = topPaddingLineCount * minimapLineHeight;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* CharCode.Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* CharCode.Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass ContiguousLineMap {\n    constructor(startLineNumber, endLineNumber, defaultValue) {\n        this._startLineNumber = startLineNumber;\n        this._endLineNumber = endLineNumber;\n        this._defaultValue = defaultValue;\n        this._values = [];\n        for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n            this._values[i] = defaultValue;\n        }\n    }\n    has(lineNumber) {\n        return (this.get(lineNumber) !== this._defaultValue);\n    }\n    set(lineNumber, value) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return;\n        }\n        this._values[lineNumber - this._startLineNumber] = value;\n    }\n    get(lineNumber) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return this._defaultValue;\n        }\n        return this._values[lineNumber - this._startLineNumber];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}