{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport async function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n  // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n  const defaultReplaceRange = getDefaultRange(position, model);\n  const providers = registry.all(model);\n  const multiMap = new SetMap();\n  for (const provider of providers) {\n    if (provider.groupId) {\n      multiMap.add(provider.groupId, provider);\n    }\n  }\n  function getPreferredProviders(provider) {\n    if (!provider.yieldsToGroupIds) {\n      return [];\n    }\n    const result = [];\n    for (const groupId of provider.yieldsToGroupIds || []) {\n      const providers = multiMap.get(groupId);\n      for (const p of providers) {\n        result.push(p);\n      }\n    }\n    return result;\n  }\n  const states = new Map();\n  const seen = new Set();\n  function findPreferredProviderCircle(provider, stack) {\n    stack = [...stack, provider];\n    if (seen.has(provider)) {\n      return stack;\n    }\n    seen.add(provider);\n    try {\n      const preferred = getPreferredProviders(provider);\n      for (const p of preferred) {\n        const c = findPreferredProviderCircle(p, stack);\n        if (c) {\n          return c;\n        }\n      }\n    } finally {\n      seen.delete(provider);\n    }\n    return undefined;\n  }\n  function processProvider(provider) {\n    const state = states.get(provider);\n    if (state) {\n      return state;\n    }\n    const circle = findPreferredProviderCircle(provider, []);\n    if (circle) {\n      onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : '' + s).join(' -> ')}`));\n    }\n    const deferredPromise = new DeferredPromise();\n    states.set(provider, deferredPromise.p);\n    (async () => {\n      if (!circle) {\n        const preferred = getPreferredProviders(provider);\n        for (const p of preferred) {\n          const result = await processProvider(p);\n          if (result && result.items.length > 0) {\n            // Skip provider\n            return undefined;\n          }\n        }\n      }\n      try {\n        const completions = await provider.provideInlineCompletions(model, position, context, token);\n        return completions;\n      } catch (e) {\n        onUnexpectedExternalError(e);\n        return undefined;\n      }\n    })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n    return deferredPromise.p;\n  }\n  const providerResults = await Promise.all(providers.map(async provider => ({\n    provider,\n    completions: await processProvider(provider)\n  })));\n  const itemsByHash = new Map();\n  const lists = [];\n  for (const result of providerResults) {\n    const completions = result.completions;\n    if (!completions) {\n      continue;\n    }\n    const list = new InlineCompletionList(completions, result.provider);\n    lists.push(list);\n    for (const item of completions.items) {\n      const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n      itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n    }\n  }\n  return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\nexport class InlineCompletionProviderResult {\n  constructor(\n  /**\n   * Free of duplicates.\n   */\n  completions, hashs, providerResults) {\n    this.completions = completions;\n    this.hashs = hashs;\n    this.providerResults = providerResults;\n  }\n  has(item) {\n    return this.hashs.has(item.hash());\n  }\n  dispose() {\n    for (const result of this.providerResults) {\n      result.removeRef();\n    }\n  }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n  constructor(inlineCompletions, provider) {\n    this.inlineCompletions = inlineCompletions;\n    this.provider = provider;\n    this.refCount = 1;\n  }\n  addRef() {\n    this.refCount++;\n  }\n  removeRef() {\n    this.refCount--;\n    if (this.refCount === 0) {\n      this.provider.freeInlineCompletions(this.inlineCompletions);\n    }\n  }\n}\nexport class InlineCompletionItem {\n  static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n    let insertText;\n    let snippetInfo;\n    let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n    if (typeof inlineCompletion.insertText === 'string') {\n      insertText = inlineCompletion.insertText;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = insertText.length - inlineCompletion.insertText.length;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      snippetInfo = undefined;\n    } else if ('snippet' in inlineCompletion.insertText) {\n      const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n      if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n        insertText = snippet.children[0].value;\n        snippetInfo = undefined;\n      } else {\n        insertText = snippet.toString();\n        snippetInfo = {\n          snippet: inlineCompletion.insertText.snippet,\n          range: range\n        };\n      }\n    } else {\n      assertNever(inlineCompletion.insertText);\n    }\n    return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n  }\n  constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits,\n  /**\n   * A reference to the original inline completion this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  sourceInlineCompletion,\n  /**\n   * A reference to the original inline completion list this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  source) {\n    this.filterText = filterText;\n    this.command = command;\n    this.range = range;\n    this.insertText = insertText;\n    this.snippetInfo = snippetInfo;\n    this.additionalTextEdits = additionalTextEdits;\n    this.sourceInlineCompletion = sourceInlineCompletion;\n    this.source = source;\n    filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n  }\n  withRange(updatedRange) {\n    return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n  }\n  hash() {\n    return JSON.stringify({\n      insertText: this.insertText,\n      range: this.range.toString()\n    });\n  }\n}\nfunction getDefaultRange(position, model) {\n  const word = model.getWordAtPosition(position);\n  const maxColumn = model.getLineMaxColumn(position.lineNumber);\n  // By default, always replace up until the end of the current line.\n  // This default might be subject to change!\n  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n  const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n  const newLine = lineStart + text;\n  const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n  const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n  if (!slicedTokens) {\n    return text;\n  }\n  const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n  return newText;\n}","map":{"version":3,"names":["assertNever","DeferredPromise","CancellationToken","SetMap","onUnexpectedExternalError","Range","fixBracketsInLine","getReadonlyEmptyArray","SnippetParser","Text","provideInlineCompletions","registry","position","model","context","token","None","languageConfigurationService","defaultReplaceRange","getDefaultRange","providers","all","multiMap","provider","groupId","add","getPreferredProviders","yieldsToGroupIds","result","get","p","push","states","Map","seen","Set","findPreferredProviderCircle","stack","has","preferred","c","delete","undefined","processProvider","state","circle","Error","map","s","toString","join","deferredPromise","set","items","length","completions","e","then","complete","error","providerResults","Promise","itemsByHash","lists","list","InlineCompletionList","item","inlineCompletionItem","InlineCompletionItem","from","hash","InlineCompletionProviderResult","Array","values","keys","constructor","hashs","dispose","removeRef","inlineCompletions","refCount","addRef","freeInlineCompletions","inlineCompletion","source","textModel","insertText","snippetInfo","range","lift","completeBracketPairs","closeBrackets","getStartPosition","diff","startLineNumber","startColumn","endLineNumber","endColumn","preBracketCompletionLength","snippet","parse","children","value","command","additionalTextEdits","filterText","sourceInlineCompletion","replace","withRange","updatedRange","JSON","stringify","word","getWordAtPosition","maxColumn","getLineMaxColumn","lineNumber","fromPositions","with","text","lineStart","getLineContent","substring","column","newLine","newTokens","tokenization","tokenizeLineWithEdit","slicedTokens","sliceAndInflate","newText"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport async function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n    // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n    const defaultReplaceRange = getDefaultRange(position, model);\n    const providers = registry.all(model);\n    const multiMap = new SetMap();\n    for (const provider of providers) {\n        if (provider.groupId) {\n            multiMap.add(provider.groupId, provider);\n        }\n    }\n    function getPreferredProviders(provider) {\n        if (!provider.yieldsToGroupIds) {\n            return [];\n        }\n        const result = [];\n        for (const groupId of provider.yieldsToGroupIds || []) {\n            const providers = multiMap.get(groupId);\n            for (const p of providers) {\n                result.push(p);\n            }\n        }\n        return result;\n    }\n    const states = new Map();\n    const seen = new Set();\n    function findPreferredProviderCircle(provider, stack) {\n        stack = [...stack, provider];\n        if (seen.has(provider)) {\n            return stack;\n        }\n        seen.add(provider);\n        try {\n            const preferred = getPreferredProviders(provider);\n            for (const p of preferred) {\n                const c = findPreferredProviderCircle(p, stack);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n        finally {\n            seen.delete(provider);\n        }\n        return undefined;\n    }\n    function processProvider(provider) {\n        const state = states.get(provider);\n        if (state) {\n            return state;\n        }\n        const circle = findPreferredProviderCircle(provider, []);\n        if (circle) {\n            onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n        }\n        const deferredPromise = new DeferredPromise();\n        states.set(provider, deferredPromise.p);\n        (async () => {\n            if (!circle) {\n                const preferred = getPreferredProviders(provider);\n                for (const p of preferred) {\n                    const result = await processProvider(p);\n                    if (result && result.items.length > 0) {\n                        // Skip provider\n                        return undefined;\n                    }\n                }\n            }\n            try {\n                const completions = await provider.provideInlineCompletions(model, position, context, token);\n                return completions;\n            }\n            catch (e) {\n                onUnexpectedExternalError(e);\n                return undefined;\n            }\n        })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n        return deferredPromise.p;\n    }\n    const providerResults = await Promise.all(providers.map(async (provider) => ({ provider, completions: await processProvider(provider) })));\n    const itemsByHash = new Map();\n    const lists = [];\n    for (const result of providerResults) {\n        const completions = result.completions;\n        if (!completions) {\n            continue;\n        }\n        const list = new InlineCompletionList(completions, result.provider);\n        lists.push(list);\n        for (const item of completions.items) {\n            const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n            itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n        }\n    }\n    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\nexport class InlineCompletionProviderResult {\n    constructor(\n    /**\n     * Free of duplicates.\n     */\n    completions, hashs, providerResults) {\n        this.completions = completions;\n        this.hashs = hashs;\n        this.providerResults = providerResults;\n    }\n    has(item) {\n        return this.hashs.has(item.hash());\n    }\n    dispose() {\n        for (const result of this.providerResults) {\n            result.removeRef();\n        }\n    }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n    constructor(inlineCompletions, provider) {\n        this.inlineCompletions = inlineCompletions;\n        this.provider = provider;\n        this.refCount = 1;\n    }\n    addRef() {\n        this.refCount++;\n    }\n    removeRef() {\n        this.refCount--;\n        if (this.refCount === 0) {\n            this.provider.freeInlineCompletions(this.inlineCompletions);\n        }\n    }\n}\nexport class InlineCompletionItem {\n    static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n        let insertText;\n        let snippetInfo;\n        let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n        if (typeof inlineCompletion.insertText === 'string') {\n            insertText = inlineCompletion.insertText;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = insertText.length - inlineCompletion.insertText.length;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            snippetInfo = undefined;\n        }\n        else if ('snippet' in inlineCompletion.insertText) {\n            const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n            if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n                insertText = snippet.children[0].value;\n                snippetInfo = undefined;\n            }\n            else {\n                insertText = snippet.toString();\n                snippetInfo = {\n                    snippet: inlineCompletion.insertText.snippet,\n                    range: range\n                };\n            }\n        }\n        else {\n            assertNever(inlineCompletion.insertText);\n        }\n        return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n    }\n    constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits, \n    /**\n     * A reference to the original inline completion this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    sourceInlineCompletion, \n    /**\n     * A reference to the original inline completion list this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    source) {\n        this.filterText = filterText;\n        this.command = command;\n        this.range = range;\n        this.insertText = insertText;\n        this.snippetInfo = snippetInfo;\n        this.additionalTextEdits = additionalTextEdits;\n        this.sourceInlineCompletion = sourceInlineCompletion;\n        this.source = source;\n        filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n        insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    }\n    withRange(updatedRange) {\n        return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n    }\n    hash() {\n        return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n    }\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n    const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n    const newLine = lineStart + text;\n    const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n    const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n    if (!slicedTokens) {\n        return text;\n    }\n    const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n    return newText;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}