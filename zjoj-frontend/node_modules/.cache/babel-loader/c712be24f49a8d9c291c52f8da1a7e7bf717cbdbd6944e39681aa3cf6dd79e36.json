{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nexport class FoldingModel {\n  get regions() {\n    return this._regions;\n  }\n  get textModel() {\n    return this._textModel;\n  }\n  constructor(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n  }\n  toggleCollapseState(toggledRegions) {\n    if (!toggledRegions.length) {\n      return;\n    }\n    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n    const processed = {};\n    this._decorationProvider.changeDecorations(accessor => {\n      let k = 0; // index from [0 ... this.regions.length]\n      let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n      let lastHiddenLine = -1; // the end of the last hidden lines\n      const updateDecorationsUntil = index => {\n        while (k < index) {\n          const endLineNumber = this._regions.getEndLineNumber(k);\n          const isCollapsed = this._regions.isCollapsed(k);\n          if (endLineNumber <= dirtyRegionEndLine) {\n            const isManual = this.regions.getSource(k) !== 0 /* FoldSource.provider */;\n            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n          }\n          if (isCollapsed && endLineNumber > lastHiddenLine) {\n            lastHiddenLine = endLineNumber;\n          }\n          k++;\n        }\n      };\n      for (const region of toggledRegions) {\n        const index = region.regionIndex;\n        const editorDecorationId = this._editorDecorationIds[index];\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n          const newCollapseState = !this._regions.isCollapsed(index);\n          this._regions.setCollapsed(index, newCollapseState);\n          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n        }\n      }\n      updateDecorationsUntil(this._regions.length);\n    });\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: toggledRegions\n    });\n  }\n  removeManualRanges(ranges) {\n    const newFoldingRanges = new Array();\n    const intersects = foldRange => {\n      for (const range of ranges) {\n        if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    for (let i = 0; i < this._regions.length; i++) {\n      const foldRange = this._regions.toFoldRange(i);\n      if (foldRange.source === 0 /* FoldSource.provider */ || !intersects(foldRange)) {\n        newFoldingRanges.push(foldRange);\n      }\n    }\n    this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n  }\n  update(newRegions, blockedLineNumers = []) {\n    const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n    const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n  }\n  updatePost(newRegions) {\n    const newEditorDecorations = [];\n    let lastHiddenLine = -1;\n    for (let index = 0, limit = newRegions.length; index < limit; index++) {\n      const startLineNumber = newRegions.getStartLineNumber(index);\n      const endLineNumber = newRegions.getEndLineNumber(index);\n      const isCollapsed = newRegions.isCollapsed(index);\n      const isManual = newRegions.getSource(index) !== 0 /* FoldSource.provider */;\n      const decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: this._textModel.getLineMaxColumn(startLineNumber),\n        endLineNumber: endLineNumber,\n        endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual)\n      });\n      if (isCollapsed && endLineNumber > lastHiddenLine) {\n        lastHiddenLine = endLineNumber;\n      }\n    }\n    this._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n    this._regions = newRegions;\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  }\n  _currentFoldedOrManualRanges(blockedLineNumers = []) {\n    const isBlocked = (startLineNumber, endLineNumber) => {\n      for (const blockedLineNumber of blockedLineNumers) {\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n      return false;\n    };\n    const foldedRanges = [];\n    for (let i = 0, limit = this._regions.length; i < limit; i++) {\n      let isCollapsed = this.regions.isCollapsed(i);\n      const source = this.regions.getSource(i);\n      if (isCollapsed || source !== 0 /* FoldSource.provider */) {\n        const foldRange = this._regions.toFoldRange(i);\n        const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n        if (decRange) {\n          if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n            isCollapsed = false; // uncollapse is the range is blocked\n          }\n          foldedRanges.push({\n            startLineNumber: decRange.startLineNumber,\n            endLineNumber: decRange.endLineNumber,\n            type: foldRange.type,\n            isCollapsed,\n            source\n          });\n        }\n      }\n    }\n    return foldedRanges;\n  }\n  /**\n   * Collapse state memento, for persistence only\n   */\n  getMemento() {\n    const foldedOrManualRanges = this._currentFoldedOrManualRanges();\n    const result = [];\n    const maxLineNumber = this._textModel.getLineCount();\n    for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n      const range = foldedOrManualRanges[i];\n      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n        continue;\n      }\n      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n      result.push({\n        startLineNumber: range.startLineNumber,\n        endLineNumber: range.endLineNumber,\n        isCollapsed: range.isCollapsed,\n        source: range.source,\n        checksum: checksum\n      });\n    }\n    return result.length > 0 ? result : undefined;\n  }\n  /**\n   * Apply persisted state, for persistence only\n   */\n  applyMemento(state) {\n    var _a, _b;\n    if (!Array.isArray(state)) {\n      return;\n    }\n    const rangesToRestore = [];\n    const maxLineNumber = this._textModel.getLineCount();\n    for (const range of state) {\n      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n        continue;\n      }\n      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n      if (!range.checksum || checksum === range.checksum) {\n        rangesToRestore.push({\n          startLineNumber: range.startLineNumber,\n          endLineNumber: range.endLineNumber,\n          type: undefined,\n          isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,\n          source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */\n        });\n      }\n    }\n    const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n  }\n  _getLinesChecksum(lineNumber1, lineNumber2) {\n    const h = hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2));\n    return h % 1000000; // 6 digits is plenty\n  }\n  dispose() {\n    this._decorationProvider.removeDecorations(this._editorDecorationIds);\n  }\n  getAllRegionsAtLine(lineNumber, filter) {\n    const result = [];\n    if (this._regions) {\n      let index = this._regions.findRange(lineNumber);\n      let level = 1;\n      while (index >= 0) {\n        const current = this._regions.toRegion(index);\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n        level++;\n        index = current.parentIndex;\n      }\n    }\n    return result;\n  }\n  getRegionAtLine(lineNumber) {\n    if (this._regions) {\n      const index = this._regions.findRange(lineNumber);\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n    return null;\n  }\n  getRegionsInside(region, filter) {\n    const result = [];\n    const index = region ? region.regionIndex + 1 : 0;\n    const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n    if (filter && filter.length === 2) {\n      const levelStack = [];\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        const current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n          levelStack.push(current);\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        const current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  const toToggle = [];\n  for (const lineNumber of lineNumbers) {\n    const region = foldingModel.getRegionAtLine(lineNumber);\n    if (region) {\n      const doCollapse = !region.isCollapsed;\n      toToggle.push(region);\n      if (levels > 1) {\n        const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n  const toToggle = [];\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (const lineNumber of lineNumbers) {\n      const region = foldingModel.getRegionAtLine(lineNumber);\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n        if (levels > 1) {\n          const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n          toToggle.push(...regionsInside);\n        }\n      }\n    }\n  } else {\n    const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n    toToggle.push(...regionsInside);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  const toToggle = [];\n  for (const lineNumber of lineNumbers) {\n    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n    toToggle.push(...regions);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  const toToggle = [];\n  for (const lineNumber of lineNumbers) {\n    const regions = foldingModel.getAllRegionsAtLine(lineNumber, region => region.isCollapsed !== doCollapse);\n    if (regions.length > 0) {\n      toToggle.push(regions[0]);\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n  const toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n  const filteredRegions = [];\n  for (const lineNumber of blockedLineNumbers) {\n    const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n    if (regions.length > 0) {\n      filteredRegions.push(regions[0]);\n    }\n  }\n  const filter = region => filteredRegions.every(filteredRegion => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n  const toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  const editorModel = foldingModel.textModel;\n  const regions = foldingModel.regions;\n  const toToggle = [];\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      const startLineNumber = regions.getStartLineNumber(i);\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  const regions = foldingModel.regions;\n  const toToggle = [];\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n  let startLineNumber = null;\n  const foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  if (foldingRegion !== null) {\n    startLineNumber = foldingRegion.startLineNumber;\n    // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n    if (lineNumber === startLineNumber) {\n      const parentFoldingIdx = foldingRegion.parentIndex;\n      if (parentFoldingIdx !== -1) {\n        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n      } else {\n        startLineNumber = null;\n      }\n    }\n  }\n  return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  // If on the folding range start line, go to previous sibling.\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n    if (lineNumber !== foldingRegion.startLineNumber) {\n      return foldingRegion.startLineNumber;\n    } else {\n      // Find min line number to stay within parent.\n      const expectedParentIndex = foldingRegion.parentIndex;\n      let minLineNumber = 0;\n      if (expectedParentIndex !== -1) {\n        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n      }\n      // Find fold at same level.\n      while (foldingRegion !== null) {\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n          // Keep at same level.\n          if (foldingRegion.startLineNumber <= minLineNumber) {\n            return null;\n          } else if (foldingRegion.parentIndex === expectedParentIndex) {\n            return foldingRegion.startLineNumber;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  } else {\n    // Go to last fold that's before the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n      while (foldingRegion !== null) {\n        // Found fold before current line.\n        if (foldingRegion.startLineNumber < lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n  return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  // If on the folding range start line, go to next sibling.\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // Find max line number to stay within parent.\n    const expectedParentIndex = foldingRegion.parentIndex;\n    let maxLineNumber = 0;\n    if (expectedParentIndex !== -1) {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n    } else if (foldingModel.regions.length === 0) {\n      return null;\n    } else {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n    }\n    // Find fold at same level.\n    while (foldingRegion !== null) {\n      if (foldingRegion.regionIndex < foldingModel.regions.length) {\n        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n        // Keep at same level.\n        if (foldingRegion.startLineNumber >= maxLineNumber) {\n          return null;\n        } else if (foldingRegion.parentIndex === expectedParentIndex) {\n          return foldingRegion.startLineNumber;\n        }\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // Go to first fold that's after the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(0);\n      while (foldingRegion !== null) {\n        // Found fold after current line.\n        if (foldingRegion.startLineNumber > lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n        if (foldingRegion.regionIndex < foldingModel.regions.length) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["Emitter","FoldingRegions","hash","FoldingModel","regions","_regions","textModel","_textModel","constructor","decorationProvider","_updateEventEmitter","onDidChange","event","_decorationProvider","Uint32Array","_editorDecorationIds","toggleCollapseState","toggledRegions","length","sort","r1","r2","regionIndex","processed","changeDecorations","accessor","k","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","index","endLineNumber","getEndLineNumber","isCollapsed","isManual","getSource","changeDecorationOptions","getDecorationOption","region","editorDecorationId","newCollapseState","setCollapsed","Math","max","fire","model","collapseStateChanged","removeManualRanges","ranges","newFoldingRanges","Array","intersects","foldRange","range","startLineNumber","i","toFoldRange","source","push","updatePost","fromFoldRanges","update","newRegions","blockedLineNumers","foldedOrManualRanges","_currentFoldedOrManualRanges","newRanges","sanitizeAndMerge","getLineCount","newEditorDecorations","limit","getStartLineNumber","decorationRange","startColumn","getLineMaxColumn","endColumn","options","deltaDecorations","isBlocked","blockedLineNumber","foldedRanges","decRange","getDecorationRange","type","getMemento","result","maxLineNumber","checksum","_getLinesChecksum","undefined","applyMemento","state","_a","_b","isArray","rangesToRestore","lineNumber1","lineNumber2","h","getLineContent","dispose","removeDecorations","getAllRegionsAtLine","lineNumber","filter","findRange","level","current","toRegion","parentIndex","getRegionAtLine","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","doCollapse","regionsInside","r","setCollapseStateLevelsDown","setCollapseStateLevelsUp","setCollapseStateUp","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForRest","filteredRegions","every","filteredRegion","setCollapseStateForMatchingLines","regExp","editorModel","test","setCollapseStateForType","getType","getParentFoldLine","foldingRegion","parentFoldingIdx","getPreviousFoldLine","expectedParentIndex","minLineNumber","getNextFoldLine"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nexport class FoldingModel {\n    get regions() { return this._regions; }\n    get textModel() { return this._textModel; }\n    constructor(textModel, decorationProvider) {\n        this._updateEventEmitter = new Emitter();\n        this.onDidChange = this._updateEventEmitter.event;\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n    }\n    toggleCollapseState(toggledRegions) {\n        if (!toggledRegions.length) {\n            return;\n        }\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n        const processed = {};\n        this._decorationProvider.changeDecorations(accessor => {\n            let k = 0; // index from [0 ... this.regions.length]\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n            let lastHiddenLine = -1; // the end of the last hidden lines\n            const updateDecorationsUntil = (index) => {\n                while (k < index) {\n                    const endLineNumber = this._regions.getEndLineNumber(k);\n                    const isCollapsed = this._regions.isCollapsed(k);\n                    if (endLineNumber <= dirtyRegionEndLine) {\n                        const isManual = this.regions.getSource(k) !== 0 /* FoldSource.provider */;\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n                    }\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\n                        lastHiddenLine = endLineNumber;\n                    }\n                    k++;\n                }\n            };\n            for (const region of toggledRegions) {\n                const index = region.regionIndex;\n                const editorDecorationId = this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n                    const newCollapseState = !this._regions.isCollapsed(index);\n                    this._regions.setCollapsed(index, newCollapseState);\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n                }\n            }\n            updateDecorationsUntil(this._regions.length);\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n    }\n    removeManualRanges(ranges) {\n        const newFoldingRanges = new Array();\n        const intersects = (foldRange) => {\n            for (const range of ranges) {\n                if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        for (let i = 0; i < this._regions.length; i++) {\n            const foldRange = this._regions.toFoldRange(i);\n            if (foldRange.source === 0 /* FoldSource.provider */ || !intersects(foldRange)) {\n                newFoldingRanges.push(foldRange);\n            }\n        }\n        this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n    }\n    update(newRegions, blockedLineNumers = []) {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n        const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    updatePost(newRegions) {\n        const newEditorDecorations = [];\n        let lastHiddenLine = -1;\n        for (let index = 0, limit = newRegions.length; index < limit; index++) {\n            const startLineNumber = newRegions.getStartLineNumber(index);\n            const endLineNumber = newRegions.getEndLineNumber(index);\n            const isCollapsed = newRegions.isCollapsed(index);\n            const isManual = newRegions.getSource(index) !== 0 /* FoldSource.provider */;\n            const decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: this._textModel.getLineMaxColumn(startLineNumber),\n                endLineNumber: endLineNumber,\n                endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n            };\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n                lastHiddenLine = endLineNumber;\n            }\n        }\n        this._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n        this._regions = newRegions;\n        this._updateEventEmitter.fire({ model: this });\n    }\n    _currentFoldedOrManualRanges(blockedLineNumers = []) {\n        const isBlocked = (startLineNumber, endLineNumber) => {\n            for (const blockedLineNumber of blockedLineNumers) {\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        const foldedRanges = [];\n        for (let i = 0, limit = this._regions.length; i < limit; i++) {\n            let isCollapsed = this.regions.isCollapsed(i);\n            const source = this.regions.getSource(i);\n            if (isCollapsed || source !== 0 /* FoldSource.provider */) {\n                const foldRange = this._regions.toFoldRange(i);\n                const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (decRange) {\n                    if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n                        isCollapsed = false; // uncollapse is the range is blocked\n                    }\n                    foldedRanges.push({\n                        startLineNumber: decRange.startLineNumber,\n                        endLineNumber: decRange.endLineNumber,\n                        type: foldRange.type,\n                        isCollapsed,\n                        source\n                    });\n                }\n            }\n        }\n        return foldedRanges;\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n    getMemento() {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges();\n        const result = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n            const range = foldedOrManualRanges[i];\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            result.push({\n                startLineNumber: range.startLineNumber,\n                endLineNumber: range.endLineNumber,\n                isCollapsed: range.isCollapsed,\n                source: range.source,\n                checksum: checksum\n            });\n        }\n        return (result.length > 0) ? result : undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n    applyMemento(state) {\n        var _a, _b;\n        if (!Array.isArray(state)) {\n            return;\n        }\n        const rangesToRestore = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (const range of state) {\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            if (!range.checksum || checksum === range.checksum) {\n                rangesToRestore.push({\n                    startLineNumber: range.startLineNumber,\n                    endLineNumber: range.endLineNumber,\n                    type: undefined,\n                    isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,\n                    source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */\n                });\n            }\n        }\n        const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    _getLinesChecksum(lineNumber1, lineNumber2) {\n        const h = hash(this._textModel.getLineContent(lineNumber1)\n            + this._textModel.getLineContent(lineNumber2));\n        return h % 1000000; // 6 digits is plenty\n    }\n    dispose() {\n        this._decorationProvider.removeDecorations(this._editorDecorationIds);\n    }\n    getAllRegionsAtLine(lineNumber, filter) {\n        const result = [];\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            let level = 1;\n            while (index >= 0) {\n                const current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    }\n    getRegionAtLine(lineNumber) {\n        if (this._regions) {\n            const index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    }\n    getRegionsInside(region, filter) {\n        const result = [];\n        const index = region ? region.regionIndex + 1 : 0;\n        const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            const levelStack = [];\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n            const doCollapse = !region.isCollapsed;\n            toToggle.push(region);\n            if (levels > 1) {\n                const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                toToggle.push(...regionsInside);\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n    const toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (const lineNumber of lineNumbers) {\n            const region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                    toToggle.push(...regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n        toToggle.push(...regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\n        if (regions.length > 0) {\n            toToggle.push(regions[0]);\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n    const filteredRegions = [];\n    for (const lineNumber of blockedLineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n        if (regions.length > 0) {\n            filteredRegions.push(regions[0]);\n        }\n    }\n    const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    const editorModel = foldingModel.textModel;\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            const startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n    let startLineNumber = null;\n    const foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    if (foldingRegion !== null) {\n        startLineNumber = foldingRegion.startLineNumber;\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n        if (lineNumber === startLineNumber) {\n            const parentFoldingIdx = foldingRegion.parentIndex;\n            if (parentFoldingIdx !== -1) {\n                startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n            }\n            else {\n                startLineNumber = null;\n            }\n        }\n    }\n    return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to previous sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n        if (lineNumber !== foldingRegion.startLineNumber) {\n            return foldingRegion.startLineNumber;\n        }\n        else {\n            // Find min line number to stay within parent.\n            const expectedParentIndex = foldingRegion.parentIndex;\n            let minLineNumber = 0;\n            if (expectedParentIndex !== -1) {\n                minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n            }\n            // Find fold at same level.\n            while (foldingRegion !== null) {\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                    // Keep at same level.\n                    if (foldingRegion.startLineNumber <= minLineNumber) {\n                        return null;\n                    }\n                    else if (foldingRegion.parentIndex === expectedParentIndex) {\n                        return foldingRegion.startLineNumber;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    else {\n        // Go to last fold that's before the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n            while (foldingRegion !== null) {\n                // Found fold before current line.\n                if (foldingRegion.startLineNumber < lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to next sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // Find max line number to stay within parent.\n        const expectedParentIndex = foldingRegion.parentIndex;\n        let maxLineNumber = 0;\n        if (expectedParentIndex !== -1) {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n        }\n        else if (foldingModel.regions.length === 0) {\n            return null;\n        }\n        else {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n        }\n        // Find fold at same level.\n        while (foldingRegion !== null) {\n            if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                // Keep at same level.\n                if (foldingRegion.startLineNumber >= maxLineNumber) {\n                    return null;\n                }\n                else if (foldingRegion.parentIndex === expectedParentIndex) {\n                    return foldingRegion.startLineNumber;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    else {\n        // Go to first fold that's after the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(0);\n            while (foldingRegion !== null) {\n                // Found fold after current line.\n                if (foldingRegion.startLineNumber > lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,kCAAkC;AAC1D,SAASC,cAAc,QAAQ,oBAAoB;AACnD,SAASC,IAAI,QAAQ,iCAAiC;AACtD,OAAO,MAAMC,YAAY,CAAC;EACtB,IAAIC,OAAOA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACC,QAAQ;EAAE;EACtC,IAAIC,SAASA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACC,UAAU;EAAE;EAC1CC,WAAWA,CAACF,SAAS,EAAEG,kBAAkB,EAAE;IACvC,IAAI,CAACC,mBAAmB,GAAG,IAAIV,OAAO,CAAC,CAAC;IACxC,IAAI,CAACW,WAAW,GAAG,IAAI,CAACD,mBAAmB,CAACE,KAAK;IACjD,IAAI,CAACL,UAAU,GAAGD,SAAS;IAC3B,IAAI,CAACO,mBAAmB,GAAGJ,kBAAkB;IAC7C,IAAI,CAACJ,QAAQ,GAAG,IAAIJ,cAAc,CAAC,IAAIa,WAAW,CAAC,CAAC,CAAC,EAAE,IAAIA,WAAW,CAAC,CAAC,CAAC,CAAC;IAC1E,IAAI,CAACC,oBAAoB,GAAG,EAAE;EAClC;EACAC,mBAAmBA,CAACC,cAAc,EAAE;IAChC,IAAI,CAACA,cAAc,CAACC,MAAM,EAAE;MACxB;IACJ;IACAD,cAAc,GAAGA,cAAc,CAACE,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAACE,WAAW,GAAGD,EAAE,CAACC,WAAW,CAAC;IACjF,MAAMC,SAAS,GAAG,CAAC,CAAC;IACpB,IAAI,CAACV,mBAAmB,CAACW,iBAAiB,CAACC,QAAQ,IAAI;MACnD,IAAIC,CAAC,GAAG,CAAC,CAAC,CAAC;MACX,IAAIC,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;MAC7B,IAAIC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;MACzB,MAAMC,sBAAsB,GAAIC,KAAK,IAAK;QACtC,OAAOJ,CAAC,GAAGI,KAAK,EAAE;UACd,MAAMC,aAAa,GAAG,IAAI,CAAC1B,QAAQ,CAAC2B,gBAAgB,CAACN,CAAC,CAAC;UACvD,MAAMO,WAAW,GAAG,IAAI,CAAC5B,QAAQ,CAAC4B,WAAW,CAACP,CAAC,CAAC;UAChD,IAAIK,aAAa,IAAIJ,kBAAkB,EAAE;YACrC,MAAMO,QAAQ,GAAG,IAAI,CAAC9B,OAAO,CAAC+B,SAAS,CAACT,CAAC,CAAC,KAAK,CAAC,CAAC;YACjDD,QAAQ,CAACW,uBAAuB,CAAC,IAAI,CAACrB,oBAAoB,CAACW,CAAC,CAAC,EAAE,IAAI,CAACb,mBAAmB,CAACwB,mBAAmB,CAACJ,WAAW,EAAEF,aAAa,IAAIH,cAAc,EAAEM,QAAQ,CAAC,CAAC;UACxK;UACA,IAAID,WAAW,IAAIF,aAAa,GAAGH,cAAc,EAAE;YAC/CA,cAAc,GAAGG,aAAa;UAClC;UACAL,CAAC,EAAE;QACP;MACJ,CAAC;MACD,KAAK,MAAMY,MAAM,IAAIrB,cAAc,EAAE;QACjC,MAAMa,KAAK,GAAGQ,MAAM,CAAChB,WAAW;QAChC,MAAMiB,kBAAkB,GAAG,IAAI,CAACxB,oBAAoB,CAACe,KAAK,CAAC;QAC3D,IAAIS,kBAAkB,IAAI,CAAChB,SAAS,CAACgB,kBAAkB,CAAC,EAAE;UACtDhB,SAAS,CAACgB,kBAAkB,CAAC,GAAG,IAAI;UACpCV,sBAAsB,CAACC,KAAK,CAAC,CAAC,CAAC;UAC/B,MAAMU,gBAAgB,GAAG,CAAC,IAAI,CAACnC,QAAQ,CAAC4B,WAAW,CAACH,KAAK,CAAC;UAC1D,IAAI,CAACzB,QAAQ,CAACoC,YAAY,CAACX,KAAK,EAAEU,gBAAgB,CAAC;UACnDb,kBAAkB,GAAGe,IAAI,CAACC,GAAG,CAAChB,kBAAkB,EAAE,IAAI,CAACtB,QAAQ,CAAC2B,gBAAgB,CAACF,KAAK,CAAC,CAAC;QAC5F;MACJ;MACAD,sBAAsB,CAAC,IAAI,CAACxB,QAAQ,CAACa,MAAM,CAAC;IAChD,CAAC,CAAC;IACF,IAAI,CAACR,mBAAmB,CAACkC,IAAI,CAAC;MAAEC,KAAK,EAAE,IAAI;MAAEC,oBAAoB,EAAE7B;IAAe,CAAC,CAAC;EACxF;EACA8B,kBAAkBA,CAACC,MAAM,EAAE;IACvB,MAAMC,gBAAgB,GAAG,IAAIC,KAAK,CAAC,CAAC;IACpC,MAAMC,UAAU,GAAIC,SAAS,IAAK;MAC9B,KAAK,MAAMC,KAAK,IAAIL,MAAM,EAAE;QACxB,IAAI,EAAEK,KAAK,CAACC,eAAe,GAAGF,SAAS,CAACrB,aAAa,IAAIqB,SAAS,CAACE,eAAe,GAAGD,KAAK,CAACtB,aAAa,CAAC,EAAE;UACvG,OAAO,IAAI;QACf;MACJ;MACA,OAAO,KAAK;IAChB,CAAC;IACD,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAClD,QAAQ,CAACa,MAAM,EAAEqC,CAAC,EAAE,EAAE;MAC3C,MAAMH,SAAS,GAAG,IAAI,CAAC/C,QAAQ,CAACmD,WAAW,CAACD,CAAC,CAAC;MAC9C,IAAIH,SAAS,CAACK,MAAM,KAAK,CAAC,CAAC,6BAA6B,CAACN,UAAU,CAACC,SAAS,CAAC,EAAE;QAC5EH,gBAAgB,CAACS,IAAI,CAACN,SAAS,CAAC;MACpC;IACJ;IACA,IAAI,CAACO,UAAU,CAAC1D,cAAc,CAAC2D,cAAc,CAACX,gBAAgB,CAAC,CAAC;EACpE;EACAY,MAAMA,CAACC,UAAU,EAAEC,iBAAiB,GAAG,EAAE,EAAE;IACvC,MAAMC,oBAAoB,GAAG,IAAI,CAACC,4BAA4B,CAACF,iBAAiB,CAAC;IACjF,MAAMG,SAAS,GAAGjE,cAAc,CAACkE,gBAAgB,CAACL,UAAU,EAAEE,oBAAoB,EAAE,IAAI,CAACzD,UAAU,CAAC6D,YAAY,CAAC,CAAC,CAAC;IACnH,IAAI,CAACT,UAAU,CAAC1D,cAAc,CAAC2D,cAAc,CAACM,SAAS,CAAC,CAAC;EAC7D;EACAP,UAAUA,CAACG,UAAU,EAAE;IACnB,MAAMO,oBAAoB,GAAG,EAAE;IAC/B,IAAIzC,cAAc,GAAG,CAAC,CAAC;IACvB,KAAK,IAAIE,KAAK,GAAG,CAAC,EAAEwC,KAAK,GAAGR,UAAU,CAAC5C,MAAM,EAAEY,KAAK,GAAGwC,KAAK,EAAExC,KAAK,EAAE,EAAE;MACnE,MAAMwB,eAAe,GAAGQ,UAAU,CAACS,kBAAkB,CAACzC,KAAK,CAAC;MAC5D,MAAMC,aAAa,GAAG+B,UAAU,CAAC9B,gBAAgB,CAACF,KAAK,CAAC;MACxD,MAAMG,WAAW,GAAG6B,UAAU,CAAC7B,WAAW,CAACH,KAAK,CAAC;MACjD,MAAMI,QAAQ,GAAG4B,UAAU,CAAC3B,SAAS,CAACL,KAAK,CAAC,KAAK,CAAC,CAAC;MACnD,MAAM0C,eAAe,GAAG;QACpBlB,eAAe,EAAEA,eAAe;QAChCmB,WAAW,EAAE,IAAI,CAAClE,UAAU,CAACmE,gBAAgB,CAACpB,eAAe,CAAC;QAC9DvB,aAAa,EAAEA,aAAa;QAC5B4C,SAAS,EAAE,IAAI,CAACpE,UAAU,CAACmE,gBAAgB,CAAC3C,aAAa,CAAC,GAAG;MACjE,CAAC;MACDsC,oBAAoB,CAACX,IAAI,CAAC;QAAEL,KAAK,EAAEmB,eAAe;QAAEI,OAAO,EAAE,IAAI,CAAC/D,mBAAmB,CAACwB,mBAAmB,CAACJ,WAAW,EAAEF,aAAa,IAAIH,cAAc,EAAEM,QAAQ;MAAE,CAAC,CAAC;MACpK,IAAID,WAAW,IAAIF,aAAa,GAAGH,cAAc,EAAE;QAC/CA,cAAc,GAAGG,aAAa;MAClC;IACJ;IACA,IAAI,CAAClB,mBAAmB,CAACW,iBAAiB,CAACC,QAAQ,IAAI,IAAI,CAACV,oBAAoB,GAAGU,QAAQ,CAACoD,gBAAgB,CAAC,IAAI,CAAC9D,oBAAoB,EAAEsD,oBAAoB,CAAC,CAAC;IAC9J,IAAI,CAAChE,QAAQ,GAAGyD,UAAU;IAC1B,IAAI,CAACpD,mBAAmB,CAACkC,IAAI,CAAC;MAAEC,KAAK,EAAE;IAAK,CAAC,CAAC;EAClD;EACAoB,4BAA4BA,CAACF,iBAAiB,GAAG,EAAE,EAAE;IACjD,MAAMe,SAAS,GAAGA,CAACxB,eAAe,EAAEvB,aAAa,KAAK;MAClD,KAAK,MAAMgD,iBAAiB,IAAIhB,iBAAiB,EAAE;QAC/C,IAAIT,eAAe,GAAGyB,iBAAiB,IAAIA,iBAAiB,IAAIhD,aAAa,EAAE;UAAE;UAC7E,OAAO,IAAI;QACf;MACJ;MACA,OAAO,KAAK;IAChB,CAAC;IACD,MAAMiD,YAAY,GAAG,EAAE;IACvB,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEe,KAAK,GAAG,IAAI,CAACjE,QAAQ,CAACa,MAAM,EAAEqC,CAAC,GAAGe,KAAK,EAAEf,CAAC,EAAE,EAAE;MAC1D,IAAItB,WAAW,GAAG,IAAI,CAAC7B,OAAO,CAAC6B,WAAW,CAACsB,CAAC,CAAC;MAC7C,MAAME,MAAM,GAAG,IAAI,CAACrD,OAAO,CAAC+B,SAAS,CAACoB,CAAC,CAAC;MACxC,IAAItB,WAAW,IAAIwB,MAAM,KAAK,CAAC,CAAC,2BAA2B;QACvD,MAAML,SAAS,GAAG,IAAI,CAAC/C,QAAQ,CAACmD,WAAW,CAACD,CAAC,CAAC;QAC9C,MAAM0B,QAAQ,GAAG,IAAI,CAAC1E,UAAU,CAAC2E,kBAAkB,CAAC,IAAI,CAACnE,oBAAoB,CAACwC,CAAC,CAAC,CAAC;QACjF,IAAI0B,QAAQ,EAAE;UACV,IAAIhD,WAAW,IAAI6C,SAAS,CAACG,QAAQ,CAAC3B,eAAe,EAAE2B,QAAQ,CAAClD,aAAa,CAAC,EAAE;YAC5EE,WAAW,GAAG,KAAK,CAAC,CAAC;UACzB;UACA+C,YAAY,CAACtB,IAAI,CAAC;YACdJ,eAAe,EAAE2B,QAAQ,CAAC3B,eAAe;YACzCvB,aAAa,EAAEkD,QAAQ,CAAClD,aAAa;YACrCoD,IAAI,EAAE/B,SAAS,CAAC+B,IAAI;YACpBlD,WAAW;YACXwB;UACJ,CAAC,CAAC;QACN;MACJ;IACJ;IACA,OAAOuB,YAAY;EACvB;EACA;AACJ;AACA;EACII,UAAUA,CAAA,EAAG;IACT,MAAMpB,oBAAoB,GAAG,IAAI,CAACC,4BAA4B,CAAC,CAAC;IAChE,MAAMoB,MAAM,GAAG,EAAE;IACjB,MAAMC,aAAa,GAAG,IAAI,CAAC/E,UAAU,CAAC6D,YAAY,CAAC,CAAC;IACpD,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEe,KAAK,GAAGN,oBAAoB,CAAC9C,MAAM,EAAEqC,CAAC,GAAGe,KAAK,EAAEf,CAAC,EAAE,EAAE;MACjE,MAAMF,KAAK,GAAGW,oBAAoB,CAACT,CAAC,CAAC;MACrC,IAAIF,KAAK,CAACC,eAAe,IAAID,KAAK,CAACtB,aAAa,IAAIsB,KAAK,CAACC,eAAe,GAAG,CAAC,IAAID,KAAK,CAACtB,aAAa,GAAGuD,aAAa,EAAE;QAClH;MACJ;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACnC,KAAK,CAACC,eAAe,GAAG,CAAC,EAAED,KAAK,CAACtB,aAAa,CAAC;MACvFsD,MAAM,CAAC3B,IAAI,CAAC;QACRJ,eAAe,EAAED,KAAK,CAACC,eAAe;QACtCvB,aAAa,EAAEsB,KAAK,CAACtB,aAAa;QAClCE,WAAW,EAAEoB,KAAK,CAACpB,WAAW;QAC9BwB,MAAM,EAAEJ,KAAK,CAACI,MAAM;QACpB8B,QAAQ,EAAEA;MACd,CAAC,CAAC;IACN;IACA,OAAQF,MAAM,CAACnE,MAAM,GAAG,CAAC,GAAImE,MAAM,GAAGI,SAAS;EACnD;EACA;AACJ;AACA;EACIC,YAAYA,CAACC,KAAK,EAAE;IAChB,IAAIC,EAAE,EAAEC,EAAE;IACV,IAAI,CAAC3C,KAAK,CAAC4C,OAAO,CAACH,KAAK,CAAC,EAAE;MACvB;IACJ;IACA,MAAMI,eAAe,GAAG,EAAE;IAC1B,MAAMT,aAAa,GAAG,IAAI,CAAC/E,UAAU,CAAC6D,YAAY,CAAC,CAAC;IACpD,KAAK,MAAMf,KAAK,IAAIsC,KAAK,EAAE;MACvB,IAAItC,KAAK,CAACC,eAAe,IAAID,KAAK,CAACtB,aAAa,IAAIsB,KAAK,CAACC,eAAe,GAAG,CAAC,IAAID,KAAK,CAACtB,aAAa,GAAGuD,aAAa,EAAE;QAClH;MACJ;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACnC,KAAK,CAACC,eAAe,GAAG,CAAC,EAAED,KAAK,CAACtB,aAAa,CAAC;MACvF,IAAI,CAACsB,KAAK,CAACkC,QAAQ,IAAIA,QAAQ,KAAKlC,KAAK,CAACkC,QAAQ,EAAE;QAChDQ,eAAe,CAACrC,IAAI,CAAC;UACjBJ,eAAe,EAAED,KAAK,CAACC,eAAe;UACtCvB,aAAa,EAAEsB,KAAK,CAACtB,aAAa;UAClCoD,IAAI,EAAEM,SAAS;UACfxD,WAAW,EAAE,CAAC2D,EAAE,GAAGvC,KAAK,CAACpB,WAAW,MAAM,IAAI,IAAI2D,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI;UAC3EnC,MAAM,EAAE,CAACoC,EAAE,GAAGxC,KAAK,CAACI,MAAM,MAAM,IAAI,IAAIoC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;QACnE,CAAC,CAAC;MACN;IACJ;IACA,MAAM3B,SAAS,GAAGjE,cAAc,CAACkE,gBAAgB,CAAC,IAAI,CAAC9D,QAAQ,EAAE0F,eAAe,EAAET,aAAa,CAAC;IAChG,IAAI,CAAC3B,UAAU,CAAC1D,cAAc,CAAC2D,cAAc,CAACM,SAAS,CAAC,CAAC;EAC7D;EACAsB,iBAAiBA,CAACQ,WAAW,EAAEC,WAAW,EAAE;IACxC,MAAMC,CAAC,GAAGhG,IAAI,CAAC,IAAI,CAACK,UAAU,CAAC4F,cAAc,CAACH,WAAW,CAAC,GACpD,IAAI,CAACzF,UAAU,CAAC4F,cAAc,CAACF,WAAW,CAAC,CAAC;IAClD,OAAOC,CAAC,GAAG,OAAO,CAAC,CAAC;EACxB;EACAE,OAAOA,CAAA,EAAG;IACN,IAAI,CAACvF,mBAAmB,CAACwF,iBAAiB,CAAC,IAAI,CAACtF,oBAAoB,CAAC;EACzE;EACAuF,mBAAmBA,CAACC,UAAU,EAAEC,MAAM,EAAE;IACpC,MAAMnB,MAAM,GAAG,EAAE;IACjB,IAAI,IAAI,CAAChF,QAAQ,EAAE;MACf,IAAIyB,KAAK,GAAG,IAAI,CAACzB,QAAQ,CAACoG,SAAS,CAACF,UAAU,CAAC;MAC/C,IAAIG,KAAK,GAAG,CAAC;MACb,OAAO5E,KAAK,IAAI,CAAC,EAAE;QACf,MAAM6E,OAAO,GAAG,IAAI,CAACtG,QAAQ,CAACuG,QAAQ,CAAC9E,KAAK,CAAC;QAC7C,IAAI,CAAC0E,MAAM,IAAIA,MAAM,CAACG,OAAO,EAAED,KAAK,CAAC,EAAE;UACnCrB,MAAM,CAAC3B,IAAI,CAACiD,OAAO,CAAC;QACxB;QACAD,KAAK,EAAE;QACP5E,KAAK,GAAG6E,OAAO,CAACE,WAAW;MAC/B;IACJ;IACA,OAAOxB,MAAM;EACjB;EACAyB,eAAeA,CAACP,UAAU,EAAE;IACxB,IAAI,IAAI,CAAClG,QAAQ,EAAE;MACf,MAAMyB,KAAK,GAAG,IAAI,CAACzB,QAAQ,CAACoG,SAAS,CAACF,UAAU,CAAC;MACjD,IAAIzE,KAAK,IAAI,CAAC,EAAE;QACZ,OAAO,IAAI,CAACzB,QAAQ,CAACuG,QAAQ,CAAC9E,KAAK,CAAC;MACxC;IACJ;IACA,OAAO,IAAI;EACf;EACAiF,gBAAgBA,CAACzE,MAAM,EAAEkE,MAAM,EAAE;IAC7B,MAAMnB,MAAM,GAAG,EAAE;IACjB,MAAMvD,KAAK,GAAGQ,MAAM,GAAGA,MAAM,CAAChB,WAAW,GAAG,CAAC,GAAG,CAAC;IACjD,MAAMS,aAAa,GAAGO,MAAM,GAAGA,MAAM,CAACP,aAAa,GAAGiF,MAAM,CAACC,SAAS;IACtE,IAAIT,MAAM,IAAIA,MAAM,CAACtF,MAAM,KAAK,CAAC,EAAE;MAC/B,MAAMgG,UAAU,GAAG,EAAE;MACrB,KAAK,IAAI3D,CAAC,GAAGzB,KAAK,EAAEqF,GAAG,GAAG,IAAI,CAAC9G,QAAQ,CAACa,MAAM,EAAEqC,CAAC,GAAG4D,GAAG,EAAE5D,CAAC,EAAE,EAAE;QAC1D,MAAMoD,OAAO,GAAG,IAAI,CAACtG,QAAQ,CAACuG,QAAQ,CAACrD,CAAC,CAAC;QACzC,IAAI,IAAI,CAAClD,QAAQ,CAACkE,kBAAkB,CAAChB,CAAC,CAAC,GAAGxB,aAAa,EAAE;UACrD,OAAOmF,UAAU,CAAChG,MAAM,GAAG,CAAC,IAAI,CAACyF,OAAO,CAACS,WAAW,CAACF,UAAU,CAACA,UAAU,CAAChG,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;YACrFgG,UAAU,CAACG,GAAG,CAAC,CAAC;UACpB;UACAH,UAAU,CAACxD,IAAI,CAACiD,OAAO,CAAC;UACxB,IAAIH,MAAM,CAACG,OAAO,EAAEO,UAAU,CAAChG,MAAM,CAAC,EAAE;YACpCmE,MAAM,CAAC3B,IAAI,CAACiD,OAAO,CAAC;UACxB;QACJ,CAAC,MACI;UACD;QACJ;MACJ;IACJ,CAAC,MACI;MACD,KAAK,IAAIpD,CAAC,GAAGzB,KAAK,EAAEqF,GAAG,GAAG,IAAI,CAAC9G,QAAQ,CAACa,MAAM,EAAEqC,CAAC,GAAG4D,GAAG,EAAE5D,CAAC,EAAE,EAAE;QAC1D,MAAMoD,OAAO,GAAG,IAAI,CAACtG,QAAQ,CAACuG,QAAQ,CAACrD,CAAC,CAAC;QACzC,IAAI,IAAI,CAAClD,QAAQ,CAACkE,kBAAkB,CAAChB,CAAC,CAAC,GAAGxB,aAAa,EAAE;UACrD,IAAI,CAACyE,MAAM,IAAIA,MAAM,CAACG,OAAO,CAAC,EAAE;YAC5BtB,MAAM,CAAC3B,IAAI,CAACiD,OAAO,CAAC;UACxB;QACJ,CAAC,MACI;UACD;QACJ;MACJ;IACJ;IACA,OAAOtB,MAAM;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASrE,mBAAmBA,CAACsG,YAAY,EAAEC,MAAM,EAAEC,WAAW,EAAE;EACnE,MAAMC,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMlB,UAAU,IAAIiB,WAAW,EAAE;IAClC,MAAMlF,MAAM,GAAGgF,YAAY,CAACR,eAAe,CAACP,UAAU,CAAC;IACvD,IAAIjE,MAAM,EAAE;MACR,MAAMoF,UAAU,GAAG,CAACpF,MAAM,CAACL,WAAW;MACtCwF,QAAQ,CAAC/D,IAAI,CAACpB,MAAM,CAAC;MACrB,IAAIiF,MAAM,GAAG,CAAC,EAAE;QACZ,MAAMI,aAAa,GAAGL,YAAY,CAACP,gBAAgB,CAACzE,MAAM,EAAE,CAACsF,CAAC,EAAElB,KAAK,KAAKkB,CAAC,CAAC3F,WAAW,KAAKyF,UAAU,IAAIhB,KAAK,GAAGa,MAAM,CAAC;QACzHE,QAAQ,CAAC/D,IAAI,CAAC,GAAGiE,aAAa,CAAC;MACnC;IACJ;EACJ;EACAL,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,0BAA0BA,CAACP,YAAY,EAAEI,UAAU,EAAEH,MAAM,GAAGP,MAAM,CAACC,SAAS,EAAEO,WAAW,EAAE;EACzG,MAAMC,QAAQ,GAAG,EAAE;EACnB,IAAID,WAAW,IAAIA,WAAW,CAACtG,MAAM,GAAG,CAAC,EAAE;IACvC,KAAK,MAAMqF,UAAU,IAAIiB,WAAW,EAAE;MAClC,MAAMlF,MAAM,GAAGgF,YAAY,CAACR,eAAe,CAACP,UAAU,CAAC;MACvD,IAAIjE,MAAM,EAAE;QACR,IAAIA,MAAM,CAACL,WAAW,KAAKyF,UAAU,EAAE;UACnCD,QAAQ,CAAC/D,IAAI,CAACpB,MAAM,CAAC;QACzB;QACA,IAAIiF,MAAM,GAAG,CAAC,EAAE;UACZ,MAAMI,aAAa,GAAGL,YAAY,CAACP,gBAAgB,CAACzE,MAAM,EAAE,CAACsF,CAAC,EAAElB,KAAK,KAAKkB,CAAC,CAAC3F,WAAW,KAAKyF,UAAU,IAAIhB,KAAK,GAAGa,MAAM,CAAC;UACzHE,QAAQ,CAAC/D,IAAI,CAAC,GAAGiE,aAAa,CAAC;QACnC;MACJ;IACJ;EACJ,CAAC,MACI;IACD,MAAMA,aAAa,GAAGL,YAAY,CAACP,gBAAgB,CAAC,IAAI,EAAE,CAACa,CAAC,EAAElB,KAAK,KAAKkB,CAAC,CAAC3F,WAAW,KAAKyF,UAAU,IAAIhB,KAAK,GAAGa,MAAM,CAAC;IACvHE,QAAQ,CAAC/D,IAAI,CAAC,GAAGiE,aAAa,CAAC;EACnC;EACAL,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,wBAAwBA,CAACR,YAAY,EAAEI,UAAU,EAAEH,MAAM,EAAEC,WAAW,EAAE;EACpF,MAAMC,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMlB,UAAU,IAAIiB,WAAW,EAAE;IAClC,MAAMpH,OAAO,GAAGkH,YAAY,CAAChB,mBAAmB,CAACC,UAAU,EAAE,CAACjE,MAAM,EAAEoE,KAAK,KAAKpE,MAAM,CAACL,WAAW,KAAKyF,UAAU,IAAIhB,KAAK,IAAIa,MAAM,CAAC;IACrIE,QAAQ,CAAC/D,IAAI,CAAC,GAAGtD,OAAO,CAAC;EAC7B;EACAkH,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,kBAAkBA,CAACT,YAAY,EAAEI,UAAU,EAAEF,WAAW,EAAE;EACtE,MAAMC,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMlB,UAAU,IAAIiB,WAAW,EAAE;IAClC,MAAMpH,OAAO,GAAGkH,YAAY,CAAChB,mBAAmB,CAACC,UAAU,EAAGjE,MAAM,IAAKA,MAAM,CAACL,WAAW,KAAKyF,UAAU,CAAC;IAC3G,IAAItH,OAAO,CAACc,MAAM,GAAG,CAAC,EAAE;MACpBuG,QAAQ,CAAC/D,IAAI,CAACtD,OAAO,CAAC,CAAC,CAAC,CAAC;IAC7B;EACJ;EACAkH,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,uBAAuBA,CAACV,YAAY,EAAEW,SAAS,EAAEP,UAAU,EAAEQ,kBAAkB,EAAE;EAC7F,MAAM1B,MAAM,GAAGA,CAAClE,MAAM,EAAEoE,KAAK,KAAKA,KAAK,KAAKuB,SAAS,IAAI3F,MAAM,CAACL,WAAW,KAAKyF,UAAU,IAAI,CAACQ,kBAAkB,CAACC,IAAI,CAACC,IAAI,IAAI9F,MAAM,CAAC+F,YAAY,CAACD,IAAI,CAAC,CAAC;EACzJ,MAAMX,QAAQ,GAAGH,YAAY,CAACP,gBAAgB,CAAC,IAAI,EAAEP,MAAM,CAAC;EAC5Dc,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,uBAAuBA,CAAChB,YAAY,EAAEI,UAAU,EAAEQ,kBAAkB,EAAE;EAClF,MAAMK,eAAe,GAAG,EAAE;EAC1B,KAAK,MAAMhC,UAAU,IAAI2B,kBAAkB,EAAE;IACzC,MAAM9H,OAAO,GAAGkH,YAAY,CAAChB,mBAAmB,CAACC,UAAU,EAAEd,SAAS,CAAC;IACvE,IAAIrF,OAAO,CAACc,MAAM,GAAG,CAAC,EAAE;MACpBqH,eAAe,CAAC7E,IAAI,CAACtD,OAAO,CAAC,CAAC,CAAC,CAAC;IACpC;EACJ;EACA,MAAMoG,MAAM,GAAIlE,MAAM,IAAKiG,eAAe,CAACC,KAAK,CAAEC,cAAc,IAAK,CAACA,cAAc,CAACrB,WAAW,CAAC9E,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC8E,WAAW,CAACqB,cAAc,CAAC,CAAC,IAAInG,MAAM,CAACL,WAAW,KAAKyF,UAAU;EACrL,MAAMD,QAAQ,GAAGH,YAAY,CAACP,gBAAgB,CAAC,IAAI,EAAEP,MAAM,CAAC;EAC5Dc,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,gCAAgCA,CAACpB,YAAY,EAAEqB,MAAM,EAAEjB,UAAU,EAAE;EAC/E,MAAMkB,WAAW,GAAGtB,YAAY,CAAChH,SAAS;EAC1C,MAAMF,OAAO,GAAGkH,YAAY,CAAClH,OAAO;EACpC,MAAMqH,QAAQ,GAAG,EAAE;EACnB,KAAK,IAAIlE,CAAC,GAAGnD,OAAO,CAACc,MAAM,GAAG,CAAC,EAAEqC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1C,IAAImE,UAAU,KAAKtH,OAAO,CAAC6B,WAAW,CAACsB,CAAC,CAAC,EAAE;MACvC,MAAMD,eAAe,GAAGlD,OAAO,CAACmE,kBAAkB,CAAChB,CAAC,CAAC;MACrD,IAAIoF,MAAM,CAACE,IAAI,CAACD,WAAW,CAACzC,cAAc,CAAC7C,eAAe,CAAC,CAAC,EAAE;QAC1DmE,QAAQ,CAAC/D,IAAI,CAACtD,OAAO,CAACwG,QAAQ,CAACrD,CAAC,CAAC,CAAC;MACtC;IACJ;EACJ;EACA+D,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqB,uBAAuBA,CAACxB,YAAY,EAAEnC,IAAI,EAAEuC,UAAU,EAAE;EACpE,MAAMtH,OAAO,GAAGkH,YAAY,CAAClH,OAAO;EACpC,MAAMqH,QAAQ,GAAG,EAAE;EACnB,KAAK,IAAIlE,CAAC,GAAGnD,OAAO,CAACc,MAAM,GAAG,CAAC,EAAEqC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1C,IAAImE,UAAU,KAAKtH,OAAO,CAAC6B,WAAW,CAACsB,CAAC,CAAC,IAAI4B,IAAI,KAAK/E,OAAO,CAAC2I,OAAO,CAACxF,CAAC,CAAC,EAAE;MACtEkE,QAAQ,CAAC/D,IAAI,CAACtD,OAAO,CAACwG,QAAQ,CAACrD,CAAC,CAAC,CAAC;IACtC;EACJ;EACA+D,YAAY,CAACtG,mBAAmB,CAACyG,QAAQ,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuB,iBAAiBA,CAACzC,UAAU,EAAEe,YAAY,EAAE;EACxD,IAAIhE,eAAe,GAAG,IAAI;EAC1B,MAAM2F,aAAa,GAAG3B,YAAY,CAACR,eAAe,CAACP,UAAU,CAAC;EAC9D,IAAI0C,aAAa,KAAK,IAAI,EAAE;IACxB3F,eAAe,GAAG2F,aAAa,CAAC3F,eAAe;IAC/C;IACA,IAAIiD,UAAU,KAAKjD,eAAe,EAAE;MAChC,MAAM4F,gBAAgB,GAAGD,aAAa,CAACpC,WAAW;MAClD,IAAIqC,gBAAgB,KAAK,CAAC,CAAC,EAAE;QACzB5F,eAAe,GAAGgE,YAAY,CAAClH,OAAO,CAACmE,kBAAkB,CAAC2E,gBAAgB,CAAC;MAC/E,CAAC,MACI;QACD5F,eAAe,GAAG,IAAI;MAC1B;IACJ;EACJ;EACA,OAAOA,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS6F,mBAAmBA,CAAC5C,UAAU,EAAEe,YAAY,EAAE;EAC1D,IAAI2B,aAAa,GAAG3B,YAAY,CAACR,eAAe,CAACP,UAAU,CAAC;EAC5D;EACA,IAAI0C,aAAa,KAAK,IAAI,IAAIA,aAAa,CAAC3F,eAAe,KAAKiD,UAAU,EAAE;IACxE;IACA,IAAIA,UAAU,KAAK0C,aAAa,CAAC3F,eAAe,EAAE;MAC9C,OAAO2F,aAAa,CAAC3F,eAAe;IACxC,CAAC,MACI;MACD;MACA,MAAM8F,mBAAmB,GAAGH,aAAa,CAACpC,WAAW;MACrD,IAAIwC,aAAa,GAAG,CAAC;MACrB,IAAID,mBAAmB,KAAK,CAAC,CAAC,EAAE;QAC5BC,aAAa,GAAG/B,YAAY,CAAClH,OAAO,CAACmE,kBAAkB,CAAC0E,aAAa,CAACpC,WAAW,CAAC;MACtF;MACA;MACA,OAAOoC,aAAa,KAAK,IAAI,EAAE;QAC3B,IAAIA,aAAa,CAAC3H,WAAW,GAAG,CAAC,EAAE;UAC/B2H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAACqC,aAAa,CAAC3H,WAAW,GAAG,CAAC,CAAC;UAC5E;UACA,IAAI2H,aAAa,CAAC3F,eAAe,IAAI+F,aAAa,EAAE;YAChD,OAAO,IAAI;UACf,CAAC,MACI,IAAIJ,aAAa,CAACpC,WAAW,KAAKuC,mBAAmB,EAAE;YACxD,OAAOH,aAAa,CAAC3F,eAAe;UACxC;QACJ,CAAC,MACI;UACD,OAAO,IAAI;QACf;MACJ;IACJ;EACJ,CAAC,MACI;IACD;IACA,IAAIgE,YAAY,CAAClH,OAAO,CAACc,MAAM,GAAG,CAAC,EAAE;MACjC+H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAACU,YAAY,CAAClH,OAAO,CAACc,MAAM,GAAG,CAAC,CAAC;MAC9E,OAAO+H,aAAa,KAAK,IAAI,EAAE;QAC3B;QACA,IAAIA,aAAa,CAAC3F,eAAe,GAAGiD,UAAU,EAAE;UAC5C,OAAO0C,aAAa,CAAC3F,eAAe;QACxC;QACA,IAAI2F,aAAa,CAAC3H,WAAW,GAAG,CAAC,EAAE;UAC/B2H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAACqC,aAAa,CAAC3H,WAAW,GAAG,CAAC,CAAC;QAChF,CAAC,MACI;UACD2H,aAAa,GAAG,IAAI;QACxB;MACJ;IACJ;EACJ;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,eAAeA,CAAC/C,UAAU,EAAEe,YAAY,EAAE;EACtD,IAAI2B,aAAa,GAAG3B,YAAY,CAACR,eAAe,CAACP,UAAU,CAAC;EAC5D;EACA,IAAI0C,aAAa,KAAK,IAAI,IAAIA,aAAa,CAAC3F,eAAe,KAAKiD,UAAU,EAAE;IACxE;IACA,MAAM6C,mBAAmB,GAAGH,aAAa,CAACpC,WAAW;IACrD,IAAIvB,aAAa,GAAG,CAAC;IACrB,IAAI8D,mBAAmB,KAAK,CAAC,CAAC,EAAE;MAC5B9D,aAAa,GAAGgC,YAAY,CAAClH,OAAO,CAAC4B,gBAAgB,CAACiH,aAAa,CAACpC,WAAW,CAAC;IACpF,CAAC,MACI,IAAIS,YAAY,CAAClH,OAAO,CAACc,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO,IAAI;IACf,CAAC,MACI;MACDoE,aAAa,GAAGgC,YAAY,CAAClH,OAAO,CAAC4B,gBAAgB,CAACsF,YAAY,CAAClH,OAAO,CAACc,MAAM,GAAG,CAAC,CAAC;IAC1F;IACA;IACA,OAAO+H,aAAa,KAAK,IAAI,EAAE;MAC3B,IAAIA,aAAa,CAAC3H,WAAW,GAAGgG,YAAY,CAAClH,OAAO,CAACc,MAAM,EAAE;QACzD+H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAACqC,aAAa,CAAC3H,WAAW,GAAG,CAAC,CAAC;QAC5E;QACA,IAAI2H,aAAa,CAAC3F,eAAe,IAAIgC,aAAa,EAAE;UAChD,OAAO,IAAI;QACf,CAAC,MACI,IAAI2D,aAAa,CAACpC,WAAW,KAAKuC,mBAAmB,EAAE;UACxD,OAAOH,aAAa,CAAC3F,eAAe;QACxC;MACJ,CAAC,MACI;QACD,OAAO,IAAI;MACf;IACJ;EACJ,CAAC,MACI;IACD;IACA,IAAIgE,YAAY,CAAClH,OAAO,CAACc,MAAM,GAAG,CAAC,EAAE;MACjC+H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAAC,CAAC,CAAC;MAChD,OAAOqC,aAAa,KAAK,IAAI,EAAE;QAC3B;QACA,IAAIA,aAAa,CAAC3F,eAAe,GAAGiD,UAAU,EAAE;UAC5C,OAAO0C,aAAa,CAAC3F,eAAe;QACxC;QACA,IAAI2F,aAAa,CAAC3H,WAAW,GAAGgG,YAAY,CAAClH,OAAO,CAACc,MAAM,EAAE;UACzD+H,aAAa,GAAG3B,YAAY,CAAClH,OAAO,CAACwG,QAAQ,CAACqC,aAAa,CAAC3H,WAAW,GAAG,CAAC,CAAC;QAChF,CAAC,MACI;UACD2H,aAAa,GAAG,IAAI;QACxB;MACJ;IACJ;EACJ;EACA,OAAO,IAAI;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}