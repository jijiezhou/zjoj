{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n  constructor(injectionOffsets,\n  /**\n   * `injectionOptions.length` must equal `injectionOffsets.length`\n   */\n  injectionOptions,\n  /**\n   * Refers to offsets after applying injections to the source.\n   * The last break offset indicates the length of the source after applying injections.\n   */\n  breakOffsets,\n  /**\n   * Refers to offsets after applying injections\n   */\n  breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n    this.injectionOffsets = injectionOffsets;\n    this.injectionOptions = injectionOptions;\n    this.breakOffsets = breakOffsets;\n    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n    this.wrappedTextIndentLength = wrappedTextIndentLength;\n  }\n  getOutputLineCount() {\n    return this.breakOffsets.length;\n  }\n  getMinOutputOffset(outputLineIndex) {\n    if (outputLineIndex > 0) {\n      return this.wrappedTextIndentLength;\n    }\n    return 0;\n  }\n  getLineLength(outputLineIndex) {\n    // These offsets refer to model text with injected text.\n    const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffset = this.breakOffsets[outputLineIndex];\n    let lineLength = endOffset - startOffset;\n    if (outputLineIndex > 0) {\n      lineLength += this.wrappedTextIndentLength;\n    }\n    return lineLength;\n  }\n  getMaxOutputOffset(outputLineIndex) {\n    return this.getLineLength(outputLineIndex);\n  }\n  translateToInputOffset(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n    const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n    let offsetInInput = offsetInInputWithInjection;\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (offsetInInput > this.injectionOffsets[i]) {\n          if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n            // `inputOffset` is within injected text\n            offsetInInput = this.injectionOffsets[i];\n          } else {\n            offsetInInput -= this.injectionOptions[i].content.length;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return offsetInInput;\n  }\n  translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n    let inputOffsetInInputWithInjection = inputOffset;\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (inputOffset < this.injectionOffsets[i]) {\n          break;\n        }\n        if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n          break;\n        }\n        inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n      }\n    }\n    return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n  }\n  offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n    let low = 0;\n    let high = this.breakOffsets.length - 1;\n    let mid = 0;\n    let midStart = 0;\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      const midStop = this.breakOffsets[mid];\n      midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n      if (affinity === 0 /* PositionAffinity.Left */) {\n        if (offsetInInputWithInjections <= midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections > midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      } else {\n        if (offsetInInputWithInjections < midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n    }\n    let outputOffset = offsetInInputWithInjections - midStart;\n    if (mid > 0) {\n      outputOffset += this.wrappedTextIndentLength;\n    }\n    return new OutputPosition(mid, outputOffset);\n  }\n  normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n    if (this.injectionOffsets !== null) {\n      const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n      const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n      if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n        // injected text caused a change\n        return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n      }\n    }\n    if (affinity === 0 /* PositionAffinity.Left */) {\n      if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n      }\n    } else if (affinity === 1 /* PositionAffinity.Right */) {\n      const maxOutputLineIndex = this.getOutputLineCount() - 1;\n      if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n      }\n    }\n    return new OutputPosition(outputLineIndex, outputOffset);\n  }\n  outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n    const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n    return result;\n  }\n  normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n    const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n    if (!injectedText) {\n      return offsetInInputWithInjections;\n    }\n    if (affinity === 2 /* PositionAffinity.None */) {\n      if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n        return injectedText.offsetInInputWithInjections + injectedText.length;\n      } else {\n        let result = injectedText.offsetInInputWithInjections;\n        if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n          return result;\n        }\n        let index = injectedText.injectedTextIndex - 1;\n        while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n          if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n          result -= this.injectionOptions[index].content.length;\n          if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n          index--;\n        }\n        return result;\n      }\n    } else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n      let result = injectedText.offsetInInputWithInjections + injectedText.length;\n      let index = injectedText.injectedTextIndex;\n      // traverse all injected text that touch each other\n      while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n        result += this.injectionOptions[index + 1].content.length;\n        index++;\n      }\n      return result;\n    } else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n      // affinity is left\n      let result = injectedText.offsetInInputWithInjections;\n      let index = injectedText.injectedTextIndex;\n      // traverse all injected text that touch each other\n      while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n        result -= this.injectionOptions[index - 1].content.length;\n        index--;\n      }\n      return result;\n    }\n    assertNever(affinity);\n  }\n  getInjectedText(outputLineIndex, outputOffset) {\n    const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n    const injectedText = this.getInjectedTextAtOffset(offset);\n    if (!injectedText) {\n      return null;\n    }\n    return {\n      options: this.injectionOptions[injectedText.injectedTextIndex]\n    };\n  }\n  getInjectedTextAtOffset(offsetInInputWithInjections) {\n    const injectionOffsets = this.injectionOffsets;\n    const injectionOptions = this.injectionOptions;\n    if (injectionOffsets !== null) {\n      let totalInjectedTextLengthBefore = 0;\n      for (let i = 0; i < injectionOffsets.length; i++) {\n        const length = injectionOptions[i].content.length;\n        const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n        const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n        if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n          // Injected text starts later.\n          break; // All later injected texts have an even larger offset.\n        }\n        if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n          // Injected text ends after or with the given position (but also starts with or before it).\n          return {\n            injectedTextIndex: i,\n            offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n            length\n          };\n        }\n        totalInjectedTextLengthBefore += length;\n      }\n    }\n    return undefined;\n  }\n}\nfunction hasRightCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n  constructor(options) {\n    this.options = options;\n  }\n}\nexport class OutputPosition {\n  constructor(outputLineIndex, outputOffset) {\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n  toString() {\n    return `${this.outputLineIndex}:${this.outputOffset}`;\n  }\n  toPosition(baseLineNumber) {\n    return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n  }\n}","map":{"version":3,"names":["assertNever","Position","InjectedTextCursorStops","ModelLineProjectionData","constructor","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","getOutputLineCount","length","getMinOutputOffset","outputLineIndex","getLineLength","startOffset","endOffset","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","Math","max","offsetInInputWithInjection","offsetInInput","i","content","translateToOutputPosition","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","maxOutputLineIndex","result","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","index","getInjectedText","offset","options","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","undefined","cursorStop","Right","Both","Left","InjectedText","toString","toPosition","baseLineNumber"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}