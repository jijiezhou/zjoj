{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n  if (typeof selector === 'string') {\n    return false;\n  } else if (Array.isArray(selector)) {\n    return selector.every(isExclusive);\n  } else {\n    return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n  }\n}\nclass MatchCandidate {\n  constructor(uri, languageId, notebookUri, notebookType) {\n    this.uri = uri;\n    this.languageId = languageId;\n    this.notebookUri = notebookUri;\n    this.notebookType = notebookType;\n  }\n  equals(other) {\n    var _a, _b;\n    return this.notebookType === other.notebookType && this.languageId === other.languageId && this.uri.toString() === other.uri.toString() && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n  }\n}\nexport class LanguageFeatureRegistry {\n  constructor(_notebookInfoResolver) {\n    this._notebookInfoResolver = _notebookInfoResolver;\n    this._clock = 0;\n    this._entries = [];\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  register(selector, provider) {\n    let entry = {\n      selector,\n      provider,\n      _score: -1,\n      _time: this._clock++\n    };\n    this._entries.push(entry);\n    this._lastCandidate = undefined;\n    this._onDidChange.fire(this._entries.length);\n    return toDisposable(() => {\n      if (entry) {\n        const idx = this._entries.indexOf(entry);\n        if (idx >= 0) {\n          this._entries.splice(idx, 1);\n          this._lastCandidate = undefined;\n          this._onDidChange.fire(this._entries.length);\n          entry = undefined;\n        }\n      }\n    });\n  }\n  has(model) {\n    return this.all(model).length > 0;\n  }\n  all(model) {\n    if (!model) {\n      return [];\n    }\n    this._updateScores(model);\n    const result = [];\n    // from registry\n    for (const entry of this._entries) {\n      if (entry._score > 0) {\n        result.push(entry.provider);\n      }\n    }\n    return result;\n  }\n  ordered(model) {\n    const result = [];\n    this._orderedForEach(model, entry => result.push(entry.provider));\n    return result;\n  }\n  orderedGroups(model) {\n    const result = [];\n    let lastBucket;\n    let lastBucketScore;\n    this._orderedForEach(model, entry => {\n      if (lastBucket && lastBucketScore === entry._score) {\n        lastBucket.push(entry.provider);\n      } else {\n        lastBucketScore = entry._score;\n        lastBucket = [entry.provider];\n        result.push(lastBucket);\n      }\n    });\n    return result;\n  }\n  _orderedForEach(model, callback) {\n    this._updateScores(model);\n    for (const entry of this._entries) {\n      if (entry._score > 0) {\n        callback(entry);\n      }\n    }\n  }\n  _updateScores(model) {\n    var _a, _b;\n    const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n    // use the uri (scheme, pattern) of the notebook info iff we have one\n    // otherwise it's the model's/document's uri\n    const candidate = notebookInfo ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type) : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n    if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n      // nothing has changed\n      return;\n    }\n    this._lastCandidate = candidate;\n    for (const entry of this._entries) {\n      entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n      if (isExclusive(entry.selector) && entry._score > 0) {\n        // support for one exclusive selector that overwrites\n        // any other selector\n        for (const entry of this._entries) {\n          entry._score = 0;\n        }\n        entry._score = 1000;\n        break;\n      }\n    }\n    // needs sorting\n    this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n  }\n  static _compareByScoreAndTime(a, b) {\n    if (a._score < b._score) {\n      return 1;\n    } else if (a._score > b._score) {\n      return -1;\n    }\n    // De-prioritize built-in providers\n    if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n      return 1;\n    } else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n      return -1;\n    }\n    if (a._time < b._time) {\n      return 1;\n    } else if (a._time > b._time) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n}\nfunction isBuiltinSelector(selector) {\n  if (typeof selector === 'string') {\n    return false;\n  }\n  if (Array.isArray(selector)) {\n    return selector.some(isBuiltinSelector);\n  }\n  return Boolean(selector.isBuiltin);\n}","map":{"version":3,"names":["Emitter","toDisposable","shouldSynchronizeModel","score","isExclusive","selector","Array","isArray","every","exclusive","MatchCandidate","constructor","uri","languageId","notebookUri","notebookType","equals","other","_a","_b","toString","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","onDidChange","event","register","provider","entry","_score","_time","push","_lastCandidate","undefined","fire","length","idx","indexOf","splice","has","model","all","_updateScores","result","ordered","_orderedForEach","orderedGroups","lastBucket","lastBucketScore","callback","notebookInfo","call","candidate","getLanguageId","type","sort","_compareByScoreAndTime","a","b","isBuiltinSelector","some","Boolean","isBuiltin"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}