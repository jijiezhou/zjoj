{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, toRefs, computed, reactive, ref, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, withCtx, createVNode, Fragment, renderList } from \"vue\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport { TreeInjectionKey } from \"./context.js\";\nimport usePickSlots from \"../_hooks/use-pick-slots.js\";\nimport { isLeafNode, isNodeSelectable, isNodeExpandable } from \"./utils/index.js\";\nimport { isNodeCheckable, getCheckedStateByCheck } from \"./utils/check-utils.js\";\nimport TreeNode from \"./node.js\";\nimport { isUndefined, isFunction, isArray } from \"../_utils/is.js\";\nimport useMergeState from \"../_hooks/use-merge-state.js\";\nimport useCheckedState from \"./hooks/use-checked-state.js\";\nimport useTreeData from \"./hooks/use-tree-data.js\";\nimport VirtualList from \"../_components/virtual-list-v2/virtual-list.js\";\nimport _export_sfc from \"../_virtual/plugin-vue_export-helper.js\";\nconst _sfc_main = defineComponent({\n  name: \"Tree\",\n  components: {\n    VirtualList,\n    TreeNode\n  },\n  props: {\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    blockNode: {\n      type: Boolean\n    },\n    defaultExpandAll: {\n      type: Boolean,\n      default: true\n    },\n    multiple: {\n      type: Boolean\n    },\n    checkable: {\n      type: [Boolean, String, Function],\n      default: false\n    },\n    selectable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    checkStrictly: {\n      type: Boolean\n    },\n    checkedStrategy: {\n      type: String,\n      default: \"all\"\n    },\n    defaultSelectedKeys: {\n      type: Array\n    },\n    selectedKeys: {\n      type: Array\n    },\n    defaultCheckedKeys: {\n      type: Array\n    },\n    checkedKeys: {\n      type: Array\n    },\n    defaultExpandedKeys: {\n      type: Array\n    },\n    expandedKeys: {\n      type: Array\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    fieldNames: {\n      type: Object\n    },\n    showLine: {\n      type: Boolean\n    },\n    loadMore: {\n      type: Function\n    },\n    draggable: {\n      type: Boolean\n    },\n    allowDrop: {\n      type: Function\n    },\n    filterTreeNode: {\n      type: Function\n    },\n    searchValue: {\n      type: String,\n      default: \"\"\n    },\n    virtualListProps: {\n      type: Object\n    },\n    defaultExpandSelected: {\n      type: Boolean\n    },\n    defaultExpandChecked: {\n      type: Boolean\n    },\n    autoExpandParent: {\n      type: Boolean,\n      default: true\n    },\n    halfCheckedKeys: {\n      type: Array\n    },\n    onlyCheckLeaf: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      default: true\n    },\n    actionOnNodeClick: {\n      type: String\n    },\n    disableSelectActionOnly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: {\n    \"select\": (selectedKeys, data) => true,\n    \"update:selectedKeys\": selectedKeys => true,\n    \"check\": (checkedKeys, data) => true,\n    \"update:checkedKeys\": checkedKeys => true,\n    \"update:halfCheckedKeys\": halfCheckedKeys => true,\n    \"expand\": (expandKeys, data) => true,\n    \"update:expandedKeys\": expandKeys => true,\n    \"dragStart\": (ev, node) => true,\n    \"dragEnd\": (ev, node) => true,\n    \"dragOver\": (ev, node) => true,\n    \"dragLeave\": (ev, node) => true,\n    \"drop\": data => true\n  },\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const {\n      data: propTreeData,\n      showLine,\n      multiple,\n      loadMore,\n      checkStrictly,\n      checkedKeys: propCheckedKeys,\n      defaultCheckedKeys,\n      selectedKeys: propSelectedKeys,\n      defaultSelectedKeys,\n      expandedKeys: propExpandedKeys,\n      defaultExpandedKeys,\n      checkedStrategy,\n      selectable,\n      checkable,\n      blockNode,\n      fieldNames,\n      size,\n      defaultExpandAll,\n      filterTreeNode,\n      draggable,\n      allowDrop,\n      defaultExpandSelected,\n      defaultExpandChecked,\n      autoExpandParent,\n      halfCheckedKeys,\n      onlyCheckLeaf,\n      animation\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tree\");\n    const classNames = computed(() => [`${prefixCls}`, {\n      [`${prefixCls}-checkable`]: checkable.value,\n      [`${prefixCls}-show-line`]: showLine.value\n    }, `${prefixCls}-size-${size.value}`]);\n    const switcherIcon = usePickSlots(slots, \"switcher-icon\");\n    const loadingIcon = usePickSlots(slots, \"loading-icon\");\n    const dragIcon = usePickSlots(slots, \"drag-icon\");\n    const nodeIcon = usePickSlots(slots, \"icon\");\n    const nodeTitle = usePickSlots(slots, \"title\");\n    const nodeExtra = usePickSlots(slots, \"extra\");\n    const {\n      treeData,\n      flattenTreeData,\n      key2TreeNode\n    } = useTreeData(reactive({\n      treeData: propTreeData,\n      selectable,\n      showLine,\n      blockNode,\n      checkable,\n      fieldNames,\n      loadMore,\n      draggable\n    }));\n    const {\n      checkedKeys,\n      indeterminateKeys,\n      setCheckedState\n    } = useCheckedState(reactive({\n      defaultCheckedKeys,\n      checkedKeys: propCheckedKeys,\n      checkStrictly,\n      key2TreeNode,\n      halfCheckedKeys,\n      onlyCheckLeaf\n    }));\n    const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({\n      value: propSelectedKeys\n    }));\n    const loadingKeys = ref([]);\n    const dragNode = ref();\n    function getDefaultExpandedKeys() {\n      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {\n        const expandedKeysSet = new Set([]);\n        defaultExpandedKeys.value.forEach(_key => {\n          if (expandedKeysSet.has(_key)) return;\n          const node = key2TreeNode.value.get(_key);\n          if (!node) return;\n          [...(autoExpandParent.value ? node.pathParentKeys : []), _key].forEach(_key2 => expandedKeysSet.add(_key2));\n        });\n        return [...expandedKeysSet];\n      }\n      if (defaultExpandAll.value) {\n        return flattenTreeData.value.filter(node => node.children && node.children.length).map(node => node.key);\n      }\n      if (defaultExpandSelected.value || defaultExpandChecked.value) {\n        const expandedKeysSet = new Set([]);\n        const addToExpandKeysSet = keys => {\n          keys.forEach(key => {\n            const node = key2TreeNode.value.get(key);\n            if (!node) return;\n            (node.pathParentKeys || []).forEach(k => expandedKeysSet.add(k));\n          });\n        };\n        if (defaultExpandSelected.value) {\n          addToExpandKeysSet(selectedKeys.value);\n        }\n        if (defaultExpandChecked.value) {\n          addToExpandKeysSet(checkedKeys.value);\n        }\n        return [...expandedKeysSet];\n      }\n      return [];\n    }\n    const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), reactive({\n      value: propExpandedKeys\n    }));\n    const currentExpandKeys = ref([]);\n    const visibleTreeNodeList = computed(() => {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      const currentExpandKeysSet = new Set(currentExpandKeys.value);\n      return flattenTreeData.value.filter(node => {\n        var _a;\n        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));\n        if (!passFilter) return false;\n        const isRoot = isUndefined(node.parentKey);\n        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every(_key => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));\n        return isRoot || isVisibleNode;\n      });\n    });\n    function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {\n      let publicCheckedKeys = [...rawCheckedKeys];\n      if (rawCheckedStrategy === \"parent\") {\n        publicCheckedKeys = rawCheckedKeys.filter(_key => {\n          const item = key2TreeNode.value.get(_key);\n          return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));\n        });\n      } else if (rawCheckedStrategy === \"child\") {\n        publicCheckedKeys = rawCheckedKeys.filter(_key => {\n          var _a, _b;\n          return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);\n        });\n      }\n      return publicCheckedKeys;\n    }\n    function getNodes(keys) {\n      return keys.map(key => {\n        var _a;\n        return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;\n      }).filter(Boolean);\n    }\n    function emitCheckEvent(options) {\n      const {\n        targetKey,\n        targetChecked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);\n      emit(\"update:checkedKeys\", publicCheckedKeys);\n      emit(\"update:halfCheckedKeys\", newIndeterminateKeys);\n      emit(\"check\", publicCheckedKeys, {\n        checked: targetChecked,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        checkedNodes: getNodes(publicCheckedKeys),\n        halfCheckedKeys: newIndeterminateKeys,\n        halfCheckedNodes: getNodes(newIndeterminateKeys),\n        e: event\n      });\n    }\n    function emitSelectEvent(options) {\n      const {\n        targetKey,\n        targetSelected,\n        newSelectedKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"update:selectedKeys\", newSelectedKeys);\n      emit(\"select\", newSelectedKeys, {\n        selected: targetSelected,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        selectedNodes: getNodes(newSelectedKeys),\n        e: event\n      });\n    }\n    function emitExpandEvent(options) {\n      const {\n        targetKey,\n        targetExpanded,\n        newExpandedKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"expand\", newExpandedKeys, {\n        expanded: targetExpanded,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        expandedNodes: getNodes(newExpandedKeys),\n        e: event\n      });\n      emit(\"update:expandedKeys\", newExpandedKeys);\n    }\n    function setCheckedKeys(keys) {\n      const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);\n      emitCheckEvent({\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n    function setSelectedKeys(keys) {\n      let newSelectedKeys = keys;\n      if (!multiple.value && keys.length > 1) {\n        newSelectedKeys = [keys[0]];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        newSelectedKeys\n      });\n    }\n    function setExpandedKeys(keys) {\n      currentExpandKeys.value = [];\n      setExpandState(keys);\n      emitExpandEvent({\n        newExpandedKeys: keys\n      });\n    }\n    function checkNodes(keys, checked, targetKey) {\n      if (!keys.length) return;\n      let newCheckedKeys = [...checkedKeys.value];\n      let newIndeterminateKeys = [...indeterminateKeys.value];\n      keys.forEach(key => {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n            node,\n            checked,\n            checkedKeys: [...newCheckedKeys],\n            indeterminateKeys: [...newIndeterminateKeys],\n            checkStrictly: checkStrictly.value\n          });\n        }\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey,\n        targetChecked: isUndefined(targetKey) ? void 0 : checked,\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n    function selectNodes(keys, selected, targetKey) {\n      if (!keys.length) return;\n      let newSelectedKeys;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        keys.forEach(key => {\n          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        });\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        newSelectedKeys = selected ? [keys[0]] : [];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey,\n        targetSelected: isUndefined(targetKey) ? void 0 : selected,\n        newSelectedKeys\n      });\n    }\n    function expandNodes(keys, expanded, targetKey) {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      keys.forEach(key => {\n        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n        onExpandEnd(key);\n      });\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      emitExpandEvent({\n        targetKey,\n        targetExpanded: isUndefined(targetKey) ? void 0 : expanded,\n        newExpandedKeys\n      });\n    }\n    function onCheck(checked, key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n        node,\n        checked,\n        checkedKeys: checkedKeys.value,\n        indeterminateKeys: indeterminateKeys.value,\n        checkStrictly: checkStrictly.value\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey: key,\n        targetChecked: checked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event: e\n      });\n    }\n    function onSelect(key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      let newSelectedKeys;\n      let selected;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        selected = !selectedKeysSet.has(key);\n        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        selected = true;\n        newSelectedKeys = [key];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey: key,\n        targetSelected: selected,\n        newSelectedKeys,\n        event: e\n      });\n    }\n    function onExpand(expanded, key, e) {\n      if (currentExpandKeys.value.includes(key)) return;\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const expandedKeysSet = new Set(expandedKeys.value);\n      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      if (animation.value) {\n        currentExpandKeys.value.push(key);\n      }\n      emitExpandEvent({\n        targetKey: key,\n        targetExpanded: expanded,\n        newExpandedKeys,\n        event: e\n      });\n    }\n    function onExpandEnd(key) {\n      const index = currentExpandKeys.value.indexOf(key);\n      currentExpandKeys.value.splice(index, 1);\n    }\n    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async key => {\n      if (!isFunction(loadMore.value)) return;\n      const node = key2TreeNode.value.get(key);\n      if (!node) return;\n      const {\n        treeNodeData\n      } = node;\n      loadingKeys.value = [...new Set([...loadingKeys.value, key])];\n      try {\n        await loadMore.value(treeNodeData);\n        loadingKeys.value = loadingKeys.value.filter(v => v !== key);\n        onExpand(true, key);\n        if (checkedKeys.value.includes(key)) {\n          onCheck(true, key);\n        }\n      } catch (err) {\n        loadingKeys.value = loadingKeys.value.filter(v => v !== key);\n        console.error(\"[tree]load data error: \", err);\n      }\n    } : void 0);\n    const treeContext = reactive({\n      treeProps: props,\n      switcherIcon,\n      loadingIcon,\n      dragIcon,\n      nodeIcon,\n      nodeTitle,\n      nodeExtra,\n      treeData,\n      flattenTreeData,\n      key2TreeNode,\n      checkedKeys,\n      indeterminateKeys,\n      selectedKeys,\n      expandedKeys,\n      loadingKeys,\n      currentExpandKeys,\n      onLoadMore,\n      filterTreeNode,\n      onCheck,\n      onSelect,\n      onExpand,\n      onExpandEnd,\n      allowDrop(key, dropPosition) {\n        const node = key2TreeNode.value.get(key);\n        if (node && isFunction(allowDrop.value)) {\n          return !!allowDrop.value({\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n        return true;\n      },\n      onDragStart(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = node;\n        if (node) {\n          emit(\"dragStart\", e, node.treeNodeData);\n        }\n      },\n      onDragEnd(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = void 0;\n        if (node) {\n          emit(\"dragEnd\", e, node.treeNodeData);\n        }\n      },\n      onDragOver(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragOver\", e, node.treeNodeData);\n        }\n      },\n      onDragLeave(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragLeave\", e, node.treeNodeData);\n        }\n      },\n      onDrop(key, dropPosition, e) {\n        const node = key2TreeNode.value.get(key);\n        if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || \"\"))) {\n          emit(\"drop\", {\n            e,\n            dragNode: dragNode.value.treeNodeData,\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n      }\n    });\n    provide(TreeInjectionKey, treeContext);\n    return {\n      classNames,\n      visibleTreeNodeList,\n      treeContext,\n      virtualListRef: ref(),\n      computedSelectedKeys: selectedKeys,\n      computedExpandedKeys: expandedKeys,\n      computedCheckedKeys: checkedKeys,\n      computedIndeterminateKeys: indeterminateKeys,\n      getPublicCheckedKeys,\n      getNodes,\n      internalCheckNodes: checkNodes,\n      internalSetCheckedKeys: setCheckedKeys,\n      internalSelectNodes: selectNodes,\n      internalSetSelectedKeys: setSelectedKeys,\n      internalExpandNodes: expandNodes,\n      internalSetExpandedKeys: setExpandedKeys\n    };\n  },\n  methods: {\n    toggleCheck(key, e) {\n      const {\n        key2TreeNode,\n        onCheck,\n        checkedKeys\n      } = this.treeContext;\n      const checked = !checkedKeys.includes(key);\n      const node = key2TreeNode.get(key);\n      if (node && isNodeCheckable(node)) {\n        onCheck(checked, key, e);\n      }\n    },\n    scrollIntoView(options) {\n      this.virtualListRef && this.virtualListRef.scrollTo(options);\n    },\n    getSelectedNodes() {\n      return this.getNodes(this.computedSelectedKeys);\n    },\n    getCheckedNodes(options = {}) {\n      const {\n        checkedStrategy,\n        includeHalfChecked\n      } = options;\n      const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);\n      const checkedNodes = this.getNodes(checkedKeys);\n      return [...checkedNodes, ...(includeHalfChecked ? this.getHalfCheckedNodes() : [])];\n    },\n    getHalfCheckedNodes() {\n      return this.getNodes(this.computedIndeterminateKeys);\n    },\n    getExpandedNodes() {\n      return this.getNodes(this.computedExpandedKeys);\n    },\n    checkAll(checked = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = checked ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeCheckable(node);\n      }) : [];\n      this.internalSetCheckedKeys(newKeys);\n    },\n    checkNode(key, checked = true, onlyCheckLeaf = false) {\n      const {\n        checkStrictly,\n        treeContext\n      } = this;\n      const {\n        key2TreeNode\n      } = treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));\n      });\n      this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);\n    },\n    selectAll(selected = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = selected ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeSelectable(node);\n      }) : [];\n      this.internalSetSelectedKeys(newKeys);\n    },\n    selectNode(key, selected = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeSelectable(node);\n      });\n      this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);\n    },\n    expandAll(expanded = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const newKeys = expanded ? [...key2TreeNode.keys()].filter(key => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeExpandable(node);\n      }) : [];\n      this.internalSetExpandedKeys(newKeys);\n    },\n    expandNode(key, expanded = true) {\n      const {\n        key2TreeNode\n      } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter(key2 => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeExpandable(node);\n      });\n      this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);\n    }\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = resolveComponent(\"TreeNode\");\n  const _component_VirtualList = resolveComponent(\"VirtualList\");\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass(_ctx.classNames)\n  }, [_ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({\n    key: 0,\n    ref: \"virtualListRef\"\n  }, _ctx.virtualListProps, {\n    data: _ctx.visibleTreeNodeList\n  }), {\n    item: withCtx(({\n      item: node\n    }) => [createVNode(_component_TreeNode, mergeProps({\n      key: `${_ctx.searchValue}-${node.key}`\n    }, node.treeNodeProps), null, 16)]),\n    _: 1\n  }, 16, [\"data\"])) : (openBlock(true), createElementBlock(Fragment, {\n    key: 1\n  }, renderList(_ctx.visibleTreeNodeList, node => {\n    return openBlock(), createBlock(_component_TreeNode, mergeProps({\n      key: node.key\n    }, node.treeNodeProps), null, 16);\n  }), 128))], 2);\n}\nvar _Tree = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { _Tree as default };","map":{"version":3,"names":["defineComponent","toRefs","computed","reactive","ref","provide","resolveComponent","openBlock","createElementBlock","normalizeClass","createBlock","mergeProps","withCtx","createVNode","Fragment","renderList","getPrefixCls","TreeInjectionKey","usePickSlots","isLeafNode","isNodeSelectable","isNodeExpandable","isNodeCheckable","getCheckedStateByCheck","TreeNode","isUndefined","isFunction","isArray","useMergeState","useCheckedState","useTreeData","VirtualList","_export_sfc","_sfc_main","name","components","props","size","type","String","default","blockNode","Boolean","defaultExpandAll","multiple","checkable","Function","selectable","checkStrictly","checkedStrategy","defaultSelectedKeys","Array","selectedKeys","defaultCheckedKeys","checkedKeys","defaultExpandedKeys","expandedKeys","data","fieldNames","Object","showLine","loadMore","draggable","allowDrop","filterTreeNode","searchValue","virtualListProps","defaultExpandSelected","defaultExpandChecked","autoExpandParent","halfCheckedKeys","onlyCheckLeaf","animation","actionOnNodeClick","disableSelectActionOnly","emits","select","check","expand","expandKeys","dragStart","ev","node","dragEnd","dragOver","dragLeave","setup","emit","slots","propTreeData","propCheckedKeys","propSelectedKeys","propExpandedKeys","prefixCls","classNames","value","switcherIcon","loadingIcon","dragIcon","nodeIcon","nodeTitle","nodeExtra","treeData","flattenTreeData","key2TreeNode","indeterminateKeys","setCheckedState","setSelectedState","loadingKeys","dragNode","getDefaultExpandedKeys","expandedKeysSet","Set","forEach","_key","has","get","pathParentKeys","_key2","add","filter","children","length","map","key","addToExpandKeysSet","keys","k","setExpandState","currentExpandKeys","visibleTreeNodeList","currentExpandKeysSet","_a","passFilter","treeNodeData","isRoot","parentKey","isVisibleNode","every","getPublicCheckedKeys","rawCheckedKeys","rawCheckedStrategy","publicCheckedKeys","item","includes","_b","getNodes","emitCheckEvent","options","targetKey","targetChecked","newCheckedKeys","newIndeterminateKeys","event","targetNode","checked","checkedNodes","halfCheckedNodes","e","emitSelectEvent","targetSelected","newSelectedKeys","selected","selectedNodes","emitExpandEvent","targetExpanded","newExpandedKeys","expanded","expandedNodes","setCheckedKeys","setSelectedKeys","setExpandedKeys","checkNodes","selectNodes","selectedKeysSet","delete","expandNodes","onExpandEnd","onCheck","onSelect","onExpand","push","index","indexOf","splice","onLoadMore","v","err","console","error","treeContext","treeProps","dropPosition","dropNode","onDragStart","onDragEnd","onDragOver","onDragLeave","onDrop","virtualListRef","computedSelectedKeys","computedExpandedKeys","computedCheckedKeys","computedIndeterminateKeys","internalCheckNodes","internalSetCheckedKeys","internalSelectNodes","internalSetSelectedKeys","internalExpandNodes","internalSetExpandedKeys","methods","toggleCheck","scrollIntoView","scrollTo","getSelectedNodes","getCheckedNodes","includeHalfChecked","getHalfCheckedNodes","getExpandedNodes","checkAll","newKeys","checkNode","isBatch","key2","selectAll","selectNode","expandAll","expandNode","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_component_TreeNode","_component_VirtualList","class","treeNodeProps","_","_Tree"],"sources":["/Users/zj/projects/zjoj/zjoj-frontend/node_modules/@arco-design/web-vue/es/tree/tree.js"],"sourcesContent":["import { defineComponent, toRefs, computed, reactive, ref, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, withCtx, createVNode, Fragment, renderList } from \"vue\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport { TreeInjectionKey } from \"./context.js\";\nimport usePickSlots from \"../_hooks/use-pick-slots.js\";\nimport { isLeafNode, isNodeSelectable, isNodeExpandable } from \"./utils/index.js\";\nimport { isNodeCheckable, getCheckedStateByCheck } from \"./utils/check-utils.js\";\nimport TreeNode from \"./node.js\";\nimport { isUndefined, isFunction, isArray } from \"../_utils/is.js\";\nimport useMergeState from \"../_hooks/use-merge-state.js\";\nimport useCheckedState from \"./hooks/use-checked-state.js\";\nimport useTreeData from \"./hooks/use-tree-data.js\";\nimport VirtualList from \"../_components/virtual-list-v2/virtual-list.js\";\nimport _export_sfc from \"../_virtual/plugin-vue_export-helper.js\";\nconst _sfc_main = defineComponent({\n  name: \"Tree\",\n  components: {\n    VirtualList,\n    TreeNode\n  },\n  props: {\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    blockNode: {\n      type: Boolean\n    },\n    defaultExpandAll: {\n      type: Boolean,\n      default: true\n    },\n    multiple: {\n      type: Boolean\n    },\n    checkable: {\n      type: [Boolean, String, Function],\n      default: false\n    },\n    selectable: {\n      type: [Boolean, Function],\n      default: true\n    },\n    checkStrictly: {\n      type: Boolean\n    },\n    checkedStrategy: {\n      type: String,\n      default: \"all\"\n    },\n    defaultSelectedKeys: {\n      type: Array\n    },\n    selectedKeys: {\n      type: Array\n    },\n    defaultCheckedKeys: {\n      type: Array\n    },\n    checkedKeys: {\n      type: Array\n    },\n    defaultExpandedKeys: {\n      type: Array\n    },\n    expandedKeys: {\n      type: Array\n    },\n    data: {\n      type: Array,\n      default: () => []\n    },\n    fieldNames: {\n      type: Object\n    },\n    showLine: {\n      type: Boolean\n    },\n    loadMore: {\n      type: Function\n    },\n    draggable: {\n      type: Boolean\n    },\n    allowDrop: {\n      type: Function\n    },\n    filterTreeNode: {\n      type: Function\n    },\n    searchValue: {\n      type: String,\n      default: \"\"\n    },\n    virtualListProps: {\n      type: Object\n    },\n    defaultExpandSelected: {\n      type: Boolean\n    },\n    defaultExpandChecked: {\n      type: Boolean\n    },\n    autoExpandParent: {\n      type: Boolean,\n      default: true\n    },\n    halfCheckedKeys: {\n      type: Array\n    },\n    onlyCheckLeaf: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      default: true\n    },\n    actionOnNodeClick: {\n      type: String\n    },\n    disableSelectActionOnly: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: {\n    \"select\": (selectedKeys, data) => true,\n    \"update:selectedKeys\": (selectedKeys) => true,\n    \"check\": (checkedKeys, data) => true,\n    \"update:checkedKeys\": (checkedKeys) => true,\n    \"update:halfCheckedKeys\": (halfCheckedKeys) => true,\n    \"expand\": (expandKeys, data) => true,\n    \"update:expandedKeys\": (expandKeys) => true,\n    \"dragStart\": (ev, node) => true,\n    \"dragEnd\": (ev, node) => true,\n    \"dragOver\": (ev, node) => true,\n    \"dragLeave\": (ev, node) => true,\n    \"drop\": (data) => true\n  },\n  setup(props, { emit, slots }) {\n    const {\n      data: propTreeData,\n      showLine,\n      multiple,\n      loadMore,\n      checkStrictly,\n      checkedKeys: propCheckedKeys,\n      defaultCheckedKeys,\n      selectedKeys: propSelectedKeys,\n      defaultSelectedKeys,\n      expandedKeys: propExpandedKeys,\n      defaultExpandedKeys,\n      checkedStrategy,\n      selectable,\n      checkable,\n      blockNode,\n      fieldNames,\n      size,\n      defaultExpandAll,\n      filterTreeNode,\n      draggable,\n      allowDrop,\n      defaultExpandSelected,\n      defaultExpandChecked,\n      autoExpandParent,\n      halfCheckedKeys,\n      onlyCheckLeaf,\n      animation\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tree\");\n    const classNames = computed(() => [\n      `${prefixCls}`,\n      {\n        [`${prefixCls}-checkable`]: checkable.value,\n        [`${prefixCls}-show-line`]: showLine.value\n      },\n      `${prefixCls}-size-${size.value}`\n    ]);\n    const switcherIcon = usePickSlots(slots, \"switcher-icon\");\n    const loadingIcon = usePickSlots(slots, \"loading-icon\");\n    const dragIcon = usePickSlots(slots, \"drag-icon\");\n    const nodeIcon = usePickSlots(slots, \"icon\");\n    const nodeTitle = usePickSlots(slots, \"title\");\n    const nodeExtra = usePickSlots(slots, \"extra\");\n    const { treeData, flattenTreeData, key2TreeNode } = useTreeData(reactive({\n      treeData: propTreeData,\n      selectable,\n      showLine,\n      blockNode,\n      checkable,\n      fieldNames,\n      loadMore,\n      draggable\n    }));\n    const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(reactive({\n      defaultCheckedKeys,\n      checkedKeys: propCheckedKeys,\n      checkStrictly,\n      key2TreeNode,\n      halfCheckedKeys,\n      onlyCheckLeaf\n    }));\n    const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({\n      value: propSelectedKeys\n    }));\n    const loadingKeys = ref([]);\n    const dragNode = ref();\n    function getDefaultExpandedKeys() {\n      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {\n        const expandedKeysSet = new Set([]);\n        defaultExpandedKeys.value.forEach((_key) => {\n          if (expandedKeysSet.has(_key))\n            return;\n          const node = key2TreeNode.value.get(_key);\n          if (!node)\n            return;\n          [\n            ...autoExpandParent.value ? node.pathParentKeys : [],\n            _key\n          ].forEach((_key2) => expandedKeysSet.add(_key2));\n        });\n        return [...expandedKeysSet];\n      }\n      if (defaultExpandAll.value) {\n        return flattenTreeData.value.filter((node) => node.children && node.children.length).map((node) => node.key);\n      }\n      if (defaultExpandSelected.value || defaultExpandChecked.value) {\n        const expandedKeysSet = new Set([]);\n        const addToExpandKeysSet = (keys) => {\n          keys.forEach((key) => {\n            const node = key2TreeNode.value.get(key);\n            if (!node)\n              return;\n            (node.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));\n          });\n        };\n        if (defaultExpandSelected.value) {\n          addToExpandKeysSet(selectedKeys.value);\n        }\n        if (defaultExpandChecked.value) {\n          addToExpandKeysSet(checkedKeys.value);\n        }\n        return [...expandedKeysSet];\n      }\n      return [];\n    }\n    const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), reactive({\n      value: propExpandedKeys\n    }));\n    const currentExpandKeys = ref([]);\n    const visibleTreeNodeList = computed(() => {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      const currentExpandKeysSet = new Set(currentExpandKeys.value);\n      return flattenTreeData.value.filter((node) => {\n        var _a;\n        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));\n        if (!passFilter)\n          return false;\n        const isRoot = isUndefined(node.parentKey);\n        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));\n        return isRoot || isVisibleNode;\n      });\n    });\n    function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {\n      let publicCheckedKeys = [...rawCheckedKeys];\n      if (rawCheckedStrategy === \"parent\") {\n        publicCheckedKeys = rawCheckedKeys.filter((_key) => {\n          const item = key2TreeNode.value.get(_key);\n          return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));\n        });\n      } else if (rawCheckedStrategy === \"child\") {\n        publicCheckedKeys = rawCheckedKeys.filter((_key) => {\n          var _a, _b;\n          return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);\n        });\n      }\n      return publicCheckedKeys;\n    }\n    function getNodes(keys) {\n      return keys.map((key) => {\n        var _a;\n        return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;\n      }).filter(Boolean);\n    }\n    function emitCheckEvent(options) {\n      const {\n        targetKey,\n        targetChecked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event\n      } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);\n      emit(\"update:checkedKeys\", publicCheckedKeys);\n      emit(\"update:halfCheckedKeys\", newIndeterminateKeys);\n      emit(\"check\", publicCheckedKeys, {\n        checked: targetChecked,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        checkedNodes: getNodes(publicCheckedKeys),\n        halfCheckedKeys: newIndeterminateKeys,\n        halfCheckedNodes: getNodes(newIndeterminateKeys),\n        e: event\n      });\n    }\n    function emitSelectEvent(options) {\n      const { targetKey, targetSelected, newSelectedKeys, event } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"update:selectedKeys\", newSelectedKeys);\n      emit(\"select\", newSelectedKeys, {\n        selected: targetSelected,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        selectedNodes: getNodes(newSelectedKeys),\n        e: event\n      });\n    }\n    function emitExpandEvent(options) {\n      const { targetKey, targetExpanded, newExpandedKeys, event } = options;\n      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;\n      emit(\"expand\", newExpandedKeys, {\n        expanded: targetExpanded,\n        node: targetNode == null ? void 0 : targetNode.treeNodeData,\n        expandedNodes: getNodes(newExpandedKeys),\n        e: event\n      });\n      emit(\"update:expandedKeys\", newExpandedKeys);\n    }\n    function setCheckedKeys(keys) {\n      const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);\n      emitCheckEvent({ newCheckedKeys, newIndeterminateKeys });\n    }\n    function setSelectedKeys(keys) {\n      let newSelectedKeys = keys;\n      if (!multiple.value && keys.length > 1) {\n        newSelectedKeys = [keys[0]];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        newSelectedKeys\n      });\n    }\n    function setExpandedKeys(keys) {\n      currentExpandKeys.value = [];\n      setExpandState(keys);\n      emitExpandEvent({ newExpandedKeys: keys });\n    }\n    function checkNodes(keys, checked, targetKey) {\n      if (!keys.length)\n        return;\n      let newCheckedKeys = [...checkedKeys.value];\n      let newIndeterminateKeys = [...indeterminateKeys.value];\n      keys.forEach((key) => {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n            node,\n            checked,\n            checkedKeys: [...newCheckedKeys],\n            indeterminateKeys: [...newIndeterminateKeys],\n            checkStrictly: checkStrictly.value\n          });\n        }\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey,\n        targetChecked: isUndefined(targetKey) ? void 0 : checked,\n        newCheckedKeys,\n        newIndeterminateKeys\n      });\n    }\n    function selectNodes(keys, selected, targetKey) {\n      if (!keys.length)\n        return;\n      let newSelectedKeys;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        keys.forEach((key) => {\n          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        });\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        newSelectedKeys = selected ? [keys[0]] : [];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey,\n        targetSelected: isUndefined(targetKey) ? void 0 : selected,\n        newSelectedKeys\n      });\n    }\n    function expandNodes(keys, expanded, targetKey) {\n      const expandedKeysSet = new Set(expandedKeys.value);\n      keys.forEach((key) => {\n        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n        onExpandEnd(key);\n      });\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      emitExpandEvent({\n        targetKey,\n        targetExpanded: isUndefined(targetKey) ? void 0 : expanded,\n        newExpandedKeys\n      });\n    }\n    function onCheck(checked, key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({\n        node,\n        checked,\n        checkedKeys: checkedKeys.value,\n        indeterminateKeys: indeterminateKeys.value,\n        checkStrictly: checkStrictly.value\n      });\n      setCheckedState(newCheckedKeys, newIndeterminateKeys);\n      emitCheckEvent({\n        targetKey: key,\n        targetChecked: checked,\n        newCheckedKeys,\n        newIndeterminateKeys,\n        event: e\n      });\n    }\n    function onSelect(key, e) {\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      let newSelectedKeys;\n      let selected;\n      if (multiple.value) {\n        const selectedKeysSet = new Set(selectedKeys.value);\n        selected = !selectedKeysSet.has(key);\n        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);\n        newSelectedKeys = [...selectedKeysSet];\n      } else {\n        selected = true;\n        newSelectedKeys = [key];\n      }\n      setSelectedState(newSelectedKeys);\n      emitSelectEvent({\n        targetKey: key,\n        targetSelected: selected,\n        newSelectedKeys,\n        event: e\n      });\n    }\n    function onExpand(expanded, key, e) {\n      if (currentExpandKeys.value.includes(key))\n        return;\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const expandedKeysSet = new Set(expandedKeys.value);\n      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);\n      const newExpandedKeys = [...expandedKeysSet];\n      setExpandState(newExpandedKeys);\n      if (animation.value) {\n        currentExpandKeys.value.push(key);\n      }\n      emitExpandEvent({\n        targetKey: key,\n        targetExpanded: expanded,\n        newExpandedKeys,\n        event: e\n      });\n    }\n    function onExpandEnd(key) {\n      const index = currentExpandKeys.value.indexOf(key);\n      currentExpandKeys.value.splice(index, 1);\n    }\n    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {\n      if (!isFunction(loadMore.value))\n        return;\n      const node = key2TreeNode.value.get(key);\n      if (!node)\n        return;\n      const { treeNodeData } = node;\n      loadingKeys.value = [...new Set([...loadingKeys.value, key])];\n      try {\n        await loadMore.value(treeNodeData);\n        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);\n        onExpand(true, key);\n        if (checkedKeys.value.includes(key)) {\n          onCheck(true, key);\n        }\n      } catch (err) {\n        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);\n        console.error(\"[tree]load data error: \", err);\n      }\n    } : void 0);\n    const treeContext = reactive({\n      treeProps: props,\n      switcherIcon,\n      loadingIcon,\n      dragIcon,\n      nodeIcon,\n      nodeTitle,\n      nodeExtra,\n      treeData,\n      flattenTreeData,\n      key2TreeNode,\n      checkedKeys,\n      indeterminateKeys,\n      selectedKeys,\n      expandedKeys,\n      loadingKeys,\n      currentExpandKeys,\n      onLoadMore,\n      filterTreeNode,\n      onCheck,\n      onSelect,\n      onExpand,\n      onExpandEnd,\n      allowDrop(key, dropPosition) {\n        const node = key2TreeNode.value.get(key);\n        if (node && isFunction(allowDrop.value)) {\n          return !!allowDrop.value({\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n        return true;\n      },\n      onDragStart(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = node;\n        if (node) {\n          emit(\"dragStart\", e, node.treeNodeData);\n        }\n      },\n      onDragEnd(key, e) {\n        const node = key2TreeNode.value.get(key);\n        dragNode.value = void 0;\n        if (node) {\n          emit(\"dragEnd\", e, node.treeNodeData);\n        }\n      },\n      onDragOver(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragOver\", e, node.treeNodeData);\n        }\n      },\n      onDragLeave(key, e) {\n        const node = key2TreeNode.value.get(key);\n        if (node) {\n          emit(\"dragLeave\", e, node.treeNodeData);\n        }\n      },\n      onDrop(key, dropPosition, e) {\n        const node = key2TreeNode.value.get(key);\n        if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || \"\"))) {\n          emit(\"drop\", {\n            e,\n            dragNode: dragNode.value.treeNodeData,\n            dropNode: node.treeNodeData,\n            dropPosition\n          });\n        }\n      }\n    });\n    provide(TreeInjectionKey, treeContext);\n    return {\n      classNames,\n      visibleTreeNodeList,\n      treeContext,\n      virtualListRef: ref(),\n      computedSelectedKeys: selectedKeys,\n      computedExpandedKeys: expandedKeys,\n      computedCheckedKeys: checkedKeys,\n      computedIndeterminateKeys: indeterminateKeys,\n      getPublicCheckedKeys,\n      getNodes,\n      internalCheckNodes: checkNodes,\n      internalSetCheckedKeys: setCheckedKeys,\n      internalSelectNodes: selectNodes,\n      internalSetSelectedKeys: setSelectedKeys,\n      internalExpandNodes: expandNodes,\n      internalSetExpandedKeys: setExpandedKeys\n    };\n  },\n  methods: {\n    toggleCheck(key, e) {\n      const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;\n      const checked = !checkedKeys.includes(key);\n      const node = key2TreeNode.get(key);\n      if (node && isNodeCheckable(node)) {\n        onCheck(checked, key, e);\n      }\n    },\n    scrollIntoView(options) {\n      this.virtualListRef && this.virtualListRef.scrollTo(options);\n    },\n    getSelectedNodes() {\n      return this.getNodes(this.computedSelectedKeys);\n    },\n    getCheckedNodes(options = {}) {\n      const { checkedStrategy, includeHalfChecked } = options;\n      const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);\n      const checkedNodes = this.getNodes(checkedKeys);\n      return [\n        ...checkedNodes,\n        ...includeHalfChecked ? this.getHalfCheckedNodes() : []\n      ];\n    },\n    getHalfCheckedNodes() {\n      return this.getNodes(this.computedIndeterminateKeys);\n    },\n    getExpandedNodes() {\n      return this.getNodes(this.computedExpandedKeys);\n    },\n    checkAll(checked = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = checked ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeCheckable(node);\n      }) : [];\n      this.internalSetCheckedKeys(newKeys);\n    },\n    checkNode(key, checked = true, onlyCheckLeaf = false) {\n      const { checkStrictly, treeContext } = this;\n      const { key2TreeNode } = treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));\n      });\n      this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);\n    },\n    selectAll(selected = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = selected ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeSelectable(node);\n      }) : [];\n      this.internalSetSelectedKeys(newKeys);\n    },\n    selectNode(key, selected = true) {\n      const { key2TreeNode } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeSelectable(node);\n      });\n      this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);\n    },\n    expandAll(expanded = true) {\n      const { key2TreeNode } = this.treeContext;\n      const newKeys = expanded ? [...key2TreeNode.keys()].filter((key) => {\n        const node = key2TreeNode.get(key);\n        return node && isNodeExpandable(node);\n      }) : [];\n      this.internalSetExpandedKeys(newKeys);\n    },\n    expandNode(key, expanded = true) {\n      const { key2TreeNode } = this.treeContext;\n      const isBatch = isArray(key);\n      const keys = (isBatch ? key : [key]).filter((key2) => {\n        const node = key2TreeNode.get(key2);\n        return node && isNodeExpandable(node);\n      });\n      this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);\n    }\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_TreeNode = resolveComponent(\"TreeNode\");\n  const _component_VirtualList = resolveComponent(\"VirtualList\");\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass(_ctx.classNames)\n  }, [\n    _ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({\n      key: 0,\n      ref: \"virtualListRef\"\n    }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {\n      item: withCtx(({ item: node }) => [\n        createVNode(_component_TreeNode, mergeProps({\n          key: `${_ctx.searchValue}-${node.key}`\n        }, node.treeNodeProps), null, 16)\n      ]),\n      _: 1\n    }, 16, [\"data\"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.visibleTreeNodeList, (node) => {\n      return openBlock(), createBlock(_component_TreeNode, mergeProps({\n        key: node.key\n      }, node.treeNodeProps), null, 16);\n    }), 128))\n  ], 2);\n}\nvar _Tree = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { _Tree as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}